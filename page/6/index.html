<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/stun-logo.jpg?v=2.8.0" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/stun-logo.jpg?v=2.8.0" type="image/png" sizes="32x32"><meta property="og:type" content="website">
<meta property="og:title" content="linyuww&#39;s blog">
<meta property="og:url" content="https://linyuww.github.io/page/6/index.html">
<meta property="og:site_name" content="linyuww&#39;s blog">
<meta property="og:locale" content="en_US">
<meta name="twitter:card" content="summary"><title>linyuww's blog</title><link ref="canonical" href="https://linyuww.github.io/page/6/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.8.0"><link rel="stylesheet" href="css/custom.css"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":false,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"Copy","copySuccess":"Copy Success","copyError":"Copy Error"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="linyuww's blog" type="application/atom+xml">
</head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">Home</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">Archives</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">Categories</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">Search</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">Hello Welcome to my blog</div><div class="header-banner-info__subtitle">一个大学生的个人博客</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2025/09/10/pstree/">pstree</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2025-09-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2025-11-26</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>1.解析参数</p>
<p>2.创建根节点</p>
<p>3.遍历进程文件建树，用read_proc_info读取父进程，创建节点</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name[<span class="number">100</span>] = <span class="string">&quot;\0&quot;</span>; </span><br><span class="line">            <span class="type">pid_t</span> p = <span class="number">0</span>; </span><br><span class="line">            <span class="type">pid_t</span> pp = <span class="number">0</span>; </span><br><span class="line">            getPPid(stat_detail, &amp;p, name, &amp;pp);</span><br><span class="line"></span><br><span class="line">            ProcessNode* node = creatnode(name, p, pp);</span><br><span class="line">            ProcessNode* proc = process_table[pp];</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(pp == <span class="number">0</span>)<span class="keyword">continue</span>;<span class="comment">//加上这一段就只能打印init</span></span><br><span class="line"></span><br><span class="line">            proc -&gt; children[proc -&gt; childrencount++] = node;</span><br></pre></td></tr></table></div></figure>

<p>本意是想取掉一个多余的0号进程，不打印</p>
<p>调试发现是出现了段错误，把print_tree改成打印table[0]就可以了</p>
<p>具体错误有待查询</p>
<p>打印节点</p>
<p>加前缀</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">init(Ubuntu-22.</span><br><span class="line">      ├──── init</span><br><span class="line">      ├──── SessionLeader</span><br><span class="line">      │     └──── Relay(17)</span><br><span class="line">      │           ├──── zsh</span><br><span class="line">      │           │     └──── pstree-64</span><br><span class="line">      │           ├──── zsh</span><br><span class="line">      │           │     └──── gitstatusd-linu</span><br><span class="line">      │           ├──── zsh</span><br><span class="line">      │           └──── zsh</span><br><span class="line">      └──── SessionLeader</span><br></pre></td></tr></table></div></figure>

<p>分三种情况</p>
<p>1.没有父进程，不加前缀</p>
<p>2.有父进程，但没有兄弟进程或者是兄弟进程中的最后一个<code>└──── </code></p>
<p>3.有父进程，有兄弟进程，且不是最后一个<code>├────</code></p>
<p>根据深度，加<code>|</code>或者空格</p>
<p>可以选择打印传入参数的子进程</p>
<p>修改printf函数之后就可以了</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print_tree</span><span class="params">(ProcessNode* node, <span class="type">int</span> level,<span class="type">char</span>* prefix)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node -&gt; childrencount == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; node -&gt; childrencount;i++)</span><br><span class="line">    &#123;   </span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, prefix);<span class="comment">//打印前缀</span></span><br><span class="line">        assert(node -&gt; children[i] != <span class="literal">NULL</span>);</span><br><span class="line">         <span class="comment">//printf(&quot;%s(%d)\n&quot;, node-&gt;children[i] -&gt; name,node-&gt;children[i] -&gt; pid);</span></span><br><span class="line">        <span class="keyword">if</span> (level &gt; <span class="number">0</span>) <span class="comment">//如果不是根节点，若是最后一个孩子，则打印└────，否则打印├────</span></span><br><span class="line">            <span class="built_in">printf</span>(node -&gt; childrencount == (i + <span class="number">1</span>) ? <span class="string">&quot;└──── &quot;</span> : <span class="string">&quot;├──── &quot;</span>);</span><br><span class="line">   </span><br><span class="line">        <span class="comment">//参数为true时，打印pid</span></span><br><span class="line">        <span class="keyword">if</span> (showpid == <span class="number">1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s(%d)\n&quot;</span>, node-&gt;children[i] -&gt; name,node-&gt;children[i] -&gt; pid);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, node-&gt;children[i] -&gt; name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> new_prefix[MAX_SIZE];</span><br><span class="line">        <span class="built_in">strncpy</span>(new_prefix, prefix, <span class="keyword">sizeof</span>(new_prefix) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (level &gt; <span class="number">0</span>)<span class="comment">//如果不是根节点，若是最后一个孩子，则前缀加空格，否则加竖线 </span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcat</span>(new_prefix, node-&gt;childrencount == (i + <span class="number">1</span>) ? <span class="string">&quot;      &quot;</span> : <span class="string">&quot;│     &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        print_tree(node-&gt;children[i], level + <span class="number">1</span>, new_prefix);<span class="comment">//递归打印孩子的孩子节点</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2025/09/10/vptr%E5%92%8Ctbl%EF%BC%8Ctypedef/">vptr和tbl，typedef</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2025-09-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2025-11-26</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>vptr和tbl，typedef</p>
<p>动态绑定</p>
<p>函数指针</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">base</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">base</span>(<span class="type">int</span> x):<span class="built_in">a</span>(x)&#123;&#125;</span><br><span class="line">    <span class="built_in">base</span>()&#123;&#125;</span><br><span class="line">    ~<span class="built_in">base</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;cout &lt;&lt; <span class="string">&quot;base print&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derived</span>: <span class="keyword">public</span> base&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">derived</span>(<span class="type">int</span> x):<span class="built_in">base</span>(x)&#123;&#125;</span><br><span class="line">    ~<span class="built_in">derived</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;cout &lt;&lt; <span class="string">&quot;derived print&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">derived <span class="title">d</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    base* p = <span class="keyword">new</span> <span class="built_in">base</span>(<span class="number">1</span>); </span><br><span class="line">    p-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    base c ;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*Fun)</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">    Fun pFun = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;虚函数表地址&quot;</span> &lt;&lt; (<span class="type">int</span>*)(&amp;c) &lt;&lt; endl;   </span><br><span class="line">    <span class="comment">// 其实就是虚指针vbtr的值,因为vbtr的地址和对象的地址相同</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;虚函数表: 第一个函数地址&quot;</span> &lt;&lt; (<span class="type">int</span>*)*(<span class="type">int</span>*)(&amp;c) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    pFun = (Fun)*((<span class="type">int</span>*)*(<span class="type">int</span>*)(&amp;c));</span><br><span class="line">    <span class="built_in">pFun</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Fun pFun = <span class="literal">NULL</span>;：这里，pFun是一个Fun类型的指针，也就是一个函数指针。它被初始化为<span class="literal">NULL</span>，表示它不指向任何函数。</span><br><span class="line"></span><br><span class="line">pFun = (Fun)*((<span class="type">int</span>*)*(<span class="type">int</span>*)(&amp;c));：这里，pFun被赋值为c对象的虚函数表中的第一个函数的地址。这行代码首先获取c的地址&amp;c，然后将其转换为<span class="type">int</span>*类型，解引用得到虚函数表的地址，再次将其转换为<span class="type">int</span>*类型，解引用得到第一个虚函数的地址，最后将其转换为Fun类型。</span><br></pre></td></tr></table></div></figure>

<p><code>  typedef</code></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/Andrewniu/article/details/80566324" >C&#x2F;C++ typedef用法详解（真的很详细）-CSDN博客</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type (*)(....)函数指针 </span><br><span class="line">type (*)[]数组指针</span><br></pre></td></tr></table></div></figure>

<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">理解复杂声明可用的“右左法则”：</span><br><span class="line">从变量名看起，先往右，再往左，碰到一个圆括号就调转阅读的方向；括号内分析完就跳出括号，还是按先右后左的顺序，如此循环，直到整个声明分析完。举例：</span><br><span class="line"><span class="type">int</span> (*func)(<span class="type">int</span> *p);</span><br><span class="line">首 先找到变量名func，外面有一对圆括号，而且左边是一个*号，这说明func是一个指针；然后跳出这个圆括号，先看右边，又遇到圆括号，这说明 (*func)是一个函数，所以func是一个指向这类函数的指针，即函数指针，这类函数具有<span class="type">int</span>*类型的形参，返回值类型是<span class="type">int</span>。</span><br><span class="line"><span class="type">int</span> (*func[<span class="number">5</span>])(<span class="type">int</span> *);</span><br><span class="line">func 右边是一个[]运算符，说明func是具有<span class="number">5</span>个元素的数组；func的左边有一个*，说明func的元素是指针（注意这里的*不是修饰func，而是修饰 func[<span class="number">5</span>]的，原因是[]运算符优先级比*高，func先跟[]结合）。跳出这个括号，看右边，又遇到圆括号，说明func数组的元素是函数类型的指 针，它指向的函数具有<span class="type">int</span>*类型的形参，返回值类型为<span class="type">int</span>。</span><br></pre></td></tr></table></div></figure>

<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 原声明：<span class="type">int</span> *(*a[<span class="number">5</span>])(<span class="type">int</span>, <span class="type">char</span>*);</span><br><span class="line">变量名为a，直接用一个新别名pFun替换a就可以了：</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> *(*pFun)(<span class="type">int</span>, <span class="type">char</span>*); </span><br><span class="line">原声明的最简化版：</span><br><span class="line">pFun a[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 原声明：<span class="built_in">void</span> (*b[<span class="number">10</span>]) (<span class="built_in">void</span> (*)());</span><br><span class="line">变量名为b，先替换右边部分括号里的，pFunParam为别名一：</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*pFunParam)</span><span class="params">()</span></span>;</span><br><span class="line">再替换左边的变量b，pFunx为别名二：</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*pFunx)</span><span class="params">(pFunParam)</span></span>;</span><br><span class="line">原声明的最简化版：</span><br><span class="line">pFunx b[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 原声明：<span class="built_in">doube</span>(*)() (*e)[<span class="number">9</span>]; </span><br><span class="line">变量名为e，先替换左边部分，pFuny为别名一：</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">double</span><span class="params">(*pFuny)</span><span class="params">()</span></span>;</span><br><span class="line">再替换右边的变量e，pFunParamy为别名二</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">pFuny</span> <span class="params">(*pFunParamy)</span>[9]</span>;</span><br><span class="line">原声明的最简化版：</span><br><span class="line">pFunParamy e;</span><br></pre></td></tr></table></div></figure>

</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2025/09/10/%E4%BA%92%E6%96%A5/">互斥</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2025-09-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2025-11-26</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>实现原子指令用到了什么，一小段的不可被打断的指令</p>
<p>自旋锁，把<code>1</code>交换出去，其他的线程只能交换出<code>0</code>，并不断循环交换，临界区结束了之后把<code>1</code>还回去</p>
<p>另一个线程就把锁换过来</p>
<p>如果<code>lock</code> <code>unlock</code>函数加上参数，就相当于可以设多个锁，试图得到同一把锁的线程就实现了互斥</p>
<p><code>lock(&amp;status)</code></p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">holding</span><span class="params">(<span class="type">spinlock_t</span> *lk)</span> &#123;<span class="comment">//当前是有锁状态，且锁的拥有者是当前cpu</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        lk-&gt;status == LOCKED &amp;&amp;</span><br><span class="line">        lk-&gt;cpu == &amp;cpus[cpu_current()]</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>





<p>要正确使用锁很难，要经常使用断言，检查中断是否符合预测<code>assert</code>，可以读读<strong>xv6源码</strong></p>
<p>在用户态</p>
<p>用户程序<code>sum++</code>拥有锁，被操作系统中断了，切换到了其他程序，</p>
<p>其他各个线程都无法获得锁，要等操作系统切回去</p>
<p>在操作系统中</p>
<p>会中断来实现锁</p>
<p>在操作系统内核：</p>
<p>连续上两次锁，中断一次再上锁，无法获得锁，就发生死锁</p>
<p>正确性准则</p>
<p>单处理器上锁解锁前后，中断状态不可改变，原来是中断还是中断，原来不中断还是不中断</p>
<p>多处理器，</p>
<p>使用栈保存中断状态</p>
<p>为了实现自旋一定要中断吗？</p>
<p>在用户态</p>
<p>因为自旋锁资源浪费严重</p>
<p>互斥锁（mutex）的实现使用了syscall，具有较好的scalability</p>
<p>futex如果没有锁直接访问，fast path</p>
<p>如何唤醒被syscall挂起的线程？</p>

        <h2 id="06-并发控制：互斥-1"   >
          <a href="#06-并发控制：互斥-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#06-并发控制：互斥-1" class="headerlink" title="06-并发控制：互斥 (1)"></a>06-并发控制：互斥 (1)</h2>
      <p>自己思考一下，想各种情况，修改后可以立即用model checker来验证</p>

        <h2 id="互斥-2"   >
          <a href="#互斥-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#互斥-2" class="headerlink" title="互斥 2)"></a>互斥 2)</h2>
      <p>关中断+自旋实现互斥</p>
<p>保存锁前中断状态</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2025/09/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2025-09-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2025-11-26</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>多线程</p>
<p>独立的栈，共享的内存空间</p>
<p>阅读thread.h源码</p>
<p>在thread-qa中</p>
<p>将thread.h移入文件夹，执行make报错找不到库</p>
<p>解决方法：设置TLIB_PATH路径为thread.h所在的文件夹</p>
<figure class="highlight makefile"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS := -O1 -g -I<span class="variable">$(TLIB_PATH)</span></span><br></pre></td></tr></table></div></figure>

<p>解释</p>
<ol>
<li><code>-I$(TLIB_PATH)</code>：<ul>
<li>这个选项指定了一个包含路径，该路径由 <code>$(TLIB_PATH)</code> 变量定义。</li>
<li><code>$(TLIB_PATH)</code> 可能在 [Makefile](vscode-file:&#x2F;&#x2F;vscode-app&#x2F;c:&#x2F;Users&#x2F;86147&#x2F;AppData&#x2F;Local&#x2F;Programs&#x2F;Microsoft VS Code&#x2F;resources&#x2F;app&#x2F;out&#x2F;vs&#x2F;code&#x2F;electron-sandbox&#x2F;workbench&#x2F;workbench.html) 的其他地方定义，或者在运行 <code>make</code> 命令时通过环境变量传递。</li>
<li>编译器会在 <code>$(TLIB_PATH)</code> 指定的目录中查找头文件。</li>
</ul>
</li>
<li><code>-I.</code>：<ul>
<li>这个选项指定当前目录（<code>.</code>）作为包含路径。</li>
<li>编译器会在当前目录中查找头文件。</li>
</ul>
</li>
</ol>
<p>多个进程读取写入</p>
<p>支付宝，第一个减去100，第二个在该进程没有减去的时候进行条件判断，也减去100，由于是unsigned long 结果变成很大的数</p>

        <h3 id="copilot解释"   >
          <a href="#copilot解释" class="heading-link"><i class="fas fa-link"></i></a><a href="#copilot解释" class="headerlink" title="copilot解释"></a>copilot解释</h3>
      
        <h4 id="竞态条件的发生"   >
          <a href="#竞态条件的发生" class="heading-link"><i class="fas fa-link"></i></a><a href="#竞态条件的发生" class="headerlink" title="竞态条件的发生"></a>竞态条件的发生</h4>
      <ol>
<li><strong>共享变量</strong>：[<code>balance</code>](vscode-file:&#x2F;&#x2F;vscode-app&#x2F;c:&#x2F;Users&#x2F;86147&#x2F;AppData&#x2F;Local&#x2F;Programs&#x2F;Microsoft VS Code&#x2F;resources&#x2F;app&#x2F;out&#x2F;vs&#x2F;code&#x2F;electron-sandbox&#x2F;workbench&#x2F;workbench.html) 是一个全局变量，多个线程可以同时访问和修改它。</li>
<li><strong>线程创建</strong>：[<code>main</code>](vscode-file:&#x2F;&#x2F;vscode-app&#x2F;c:&#x2F;Users&#x2F;86147&#x2F;AppData&#x2F;Local&#x2F;Programs&#x2F;Microsoft VS Code&#x2F;resources&#x2F;app&#x2F;out&#x2F;vs&#x2F;code&#x2F;electron-sandbox&#x2F;workbench&#x2F;workbench.html) 函数中创建了两个线程，分别执行 [<code>T_alipay</code>](vscode-file:&#x2F;&#x2F;vscode-app&#x2F;c:&#x2F;Users&#x2F;86147&#x2F;AppData&#x2F;Local&#x2F;Programs&#x2F;Microsoft VS Code&#x2F;resources&#x2F;app&#x2F;out&#x2F;vs&#x2F;code&#x2F;electron-sandbox&#x2F;workbench&#x2F;workbench.html) 函数。</li>
<li><strong>函数调用</strong>：每个线程调用 <code>Alipay_withdraw(100)</code>，尝试从 [<code>balance</code>](vscode-file:&#x2F;&#x2F;vscode-app&#x2F;c:&#x2F;Users&#x2F;86147&#x2F;AppData&#x2F;Local&#x2F;Programs&#x2F;Microsoft VS Code&#x2F;resources&#x2F;app&#x2F;out&#x2F;vs&#x2F;code&#x2F;electron-sandbox&#x2F;workbench&#x2F;workbench.html) 中扣除 100。</li>
</ol>

        <h4 id="竞态条件的具体过程"   >
          <a href="#竞态条件的具体过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#竞态条件的具体过程" class="headerlink" title="竞态条件的具体过程"></a>竞态条件的具体过程</h4>
      <ol>
<li><p><strong>线程1和线程2同时检查 [<code>balance</code>](vscode-file:&#x2F;&#x2F;vscode-app&#x2F;c:&#x2F;Users&#x2F;86147&#x2F;AppData&#x2F;Local&#x2F;Programs&#x2F;Microsoft VS Code&#x2F;resources&#x2F;app&#x2F;out&#x2F;vs&#x2F;code&#x2F;electron-sandbox&#x2F;workbench&#x2F;workbench.html)</strong>：</p>
<ul>
<li>线程1检查 [<code>balance</code>](vscode-file:&#x2F;&#x2F;vscode-app&#x2F;c:&#x2F;Users&#x2F;86147&#x2F;AppData&#x2F;Local&#x2F;Programs&#x2F;Microsoft VS Code&#x2F;resources&#x2F;app&#x2F;out&#x2F;vs&#x2F;code&#x2F;electron-sandbox&#x2F;workbench&#x2F;workbench.html) 是否大于等于 100，结果为真。</li>
<li>线程2也检查 [<code>balance</code>](vscode-file:&#x2F;&#x2F;vscode-app&#x2F;c:&#x2F;Users&#x2F;86147&#x2F;AppData&#x2F;Local&#x2F;Programs&#x2F;Microsoft VS Code&#x2F;resources&#x2F;app&#x2F;out&#x2F;vs&#x2F;code&#x2F;electron-sandbox&#x2F;workbench&#x2F;workbench.html) 是否大于等于 100，结果也为真。</li>
</ul>
</li>
<li><p><strong>线程1和线程2同时进入 [<code>if</code>](vscode-file:&#x2F;&#x2F;vscode-app&#x2F;c:&#x2F;Users&#x2F;86147&#x2F;AppData&#x2F;Local&#x2F;Programs&#x2F;Microsoft VS Code&#x2F;resources&#x2F;app&#x2F;out&#x2F;vs&#x2F;code&#x2F;electron-sandbox&#x2F;workbench&#x2F;workbench.html) 块</strong>：</p>
<ul>
<li>线程1进入 [<code>if</code>](vscode-file:&#x2F;&#x2F;vscode-app&#x2F;c:&#x2F;Users&#x2F;86147&#x2F;AppData&#x2F;Local&#x2F;Programs&#x2F;Microsoft VS Code&#x2F;resources&#x2F;app&#x2F;out&#x2F;vs&#x2F;code&#x2F;electron-sandbox&#x2F;workbench&#x2F;workbench.html) 块并调用 <code>usleep(1)</code>，暂时让出CPU。</li>
<li>线程2也进入 [<code>if</code>](vscode-file:&#x2F;&#x2F;vscode-app&#x2F;c:&#x2F;Users&#x2F;86147&#x2F;AppData&#x2F;Local&#x2F;Programs&#x2F;Microsoft VS Code&#x2F;resources&#x2F;app&#x2F;out&#x2F;vs&#x2F;code&#x2F;electron-sandbox&#x2F;workbench&#x2F;workbench.html) 块并调用 <code>usleep(1)</code>，暂时让出CPU。</li>
</ul>
</li>
<li><p><strong>线程1和线程2同时修改 [<code>balance</code>](vscode-file:&#x2F;&#x2F;vscode-app&#x2F;c:&#x2F;Users&#x2F;86147&#x2F;AppData&#x2F;Local&#x2F;Programs&#x2F;Microsoft VS Code&#x2F;resources&#x2F;app&#x2F;out&#x2F;vs&#x2F;code&#x2F;electron-sandbox&#x2F;workbench&#x2F;workbench.html)</strong>：</p>
<ul>
<li>线程1从 [<code>balance</code>](vscode-file:&#x2F;&#x2F;vscode-app&#x2F;c:&#x2F;Users&#x2F;86147&#x2F;AppData&#x2F;Local&#x2F;Programs&#x2F;Microsoft VS Code&#x2F;resources&#x2F;app&#x2F;out&#x2F;vs&#x2F;code&#x2F;electron-sandbox&#x2F;workbench&#x2F;workbench.html) 中减去 100，[<code>balance</code>](vscode-file:&#x2F;&#x2F;vscode-app&#x2F;c:&#x2F;Users&#x2F;86147&#x2F;AppData&#x2F;Local&#x2F;Programs&#x2F;Microsoft VS Code&#x2F;resources&#x2F;app&#x2F;out&#x2F;vs&#x2F;code&#x2F;electron-sandbox&#x2F;workbench&#x2F;workbench.html) 变为 0。</li>
<li>线程2也从 [<code>balance</code>](vscode-file:&#x2F;&#x2F;vscode-app&#x2F;c:&#x2F;Users&#x2F;86147&#x2F;AppData&#x2F;Local&#x2F;Programs&#x2F;Microsoft VS Code&#x2F;resources&#x2F;app&#x2F;out&#x2F;vs&#x2F;code&#x2F;electron-sandbox&#x2F;workbench&#x2F;workbench.html) 中减去 100，[<code>balance</code>](vscode-file:&#x2F;&#x2F;vscode-app&#x2F;c:&#x2F;Users&#x2F;86147&#x2F;AppData&#x2F;Local&#x2F;Programs&#x2F;Microsoft VS Code&#x2F;resources&#x2F;app&#x2F;out&#x2F;vs&#x2F;code&#x2F;electron-sandbox&#x2F;workbench&#x2F;workbench.html) 无符号整数会溢出</li>
</ul>
</li>
</ol>
<p>如果是两个进程都循环加1加到10000，结果不会是20000</p>
<p>原代码反汇编</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">13ea:       48 8b 05 4f 2c 00 00    mov    0x2c4f(%rip),%rax       </span><br><span class="line"># 4040 &lt;sum&gt;</span><br><span class="line">13f1:       48 83 c0 01             add    $0x1,%rax</span><br><span class="line">13f5:       48 89 05 44 2c 00 00    mov    %rax,0x2c44(%rip) </span><br></pre></td></tr></table></div></figure>

<p>修改成一条汇编指令</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13ea:       48 ff 05 4f 2c 00 00    incq   0x2c4f(%rip)  </span><br></pre></td></tr></table></div></figure>

<p>改成一条指令，如果在一个处理器上还能正确，但是在多处理器上还会错误。</p>
<p>看着是一条指令，实际上不是原子指令。</p>
<p><code>printf</code>是线程安全的</p>
<p>因为汇编指令取值，在中间寄存器加1后可能会中断，再放入变量对应地址中，结果可能就只是加一个1，而不是两个1</p>
<p>最小可以小于10000，可以改成汇编指令</p>
<p>为什么是2？</p>
<p>每个进程有一个n次循环，n个进程</p>
<p>在关键进程中，最后一步store，之前，已经循环了n-1次了，这两次的最小值为1（进程A第一个循环store()时，关键进程第n-1个循环正好结束，进程A，store后sum&#x3D;1）关键进程执行前两步，然后关键进程等待其他进程结束后执行store(2,sum)</p>
<p>编译器优化，可能会隐藏并发的bug(都假设状态迁移是原子性，顺序执行)</p>
<p>O1优化sum&#x3D;100000000</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">load(sum + N)</span><br><span class="line">;循环N次</span><br><span class="line">store(num)</span><br></pre></td></tr></table></div></figure>



<p>O2优化sum&#x3D;200000000</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0000000000001260 &lt;T_sum&gt;:</span><br><span class="line">    1264:       48 81 05 d1 2d 00 00    addq   $0x5f5e100,0x2dd1(%rip)       </span><br><span class="line"> ;改成了一条指令，两个进程碰在一起的概率很低</span><br></pre></td></tr></table></div></figure>



<p>处理器也是编译器，所以单线程的处理器可能会优化，调换程序执行的顺序（在结果不变的情况下）</p>
<p>也是状态机，流水线，读写不冲突就能同时执行</p>
<p>所以……相对论？</p>
<p>共享内存只是一个简化的假象</p>
<p>mem-modle</p>
<p>一个是写Y读X，一个是写X读Y，得按特定顺序才能输出1，1，所以很少</p>
<p>arm与x86的内存模型不同，对于多线程的程序模拟难度大</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2025/09/10/%E5%AE%9E%E7%8E%B0%E5%BA%93%E5%87%BD%E6%95%B0printf/">实现库函数printf</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2025-09-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2025-11-26</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>实现库函数printf</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>    <span class="title function_">printf</span>    <span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></div></figure>

<p>这个程序除了调用的库函数不同 (例如没有 stdio.h；多了 am.h) 之外，它就是一个完全符合 C 标准的普通程序，但因为没有操作系统和标准库的支持，我们需要编写所有的库函数。例如，printf 也来自我们的代码，它调用了 AbstractMachine 提供的 putch API:</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2025/09/10/%E5%B5%8C%E5%A5%97%E7%B1%BB/">嵌套类</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2025-09-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2025-11-26</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>Club嵌套Coach</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Coach</span>&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> winRate;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Coach</span>(string n, <span class="type">int</span> wr)&#123;</span><br><span class="line">        name=n; winRate=wr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Club</span>&#123;</span><br><span class="line">    string name;</span><br><span class="line">    Coach c;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Club</span>(string n1, <span class="type">int</span> y, string n2, <span class="type">int</span> wr);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>Club的初始化和show函数要利用Club类中的东西</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Club::<span class="built_in">Club</span>(string n1,<span class="type">int</span> y,string n2,<span class="type">int</span> wr):<span class="built_in">c</span>(n2,wr)&#123;</span><br><span class="line">    name = n1;</span><br><span class="line">    year = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Club::show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; year &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    c.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>同样，在下面Circle调用内部Point类型的变量，要有Point中的get函数配合才能取出相应的x,y</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">double</span> x,y;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Point</span>(<span class="type">int</span> n,<span class="type">int</span> m):<span class="built_in">x</span>(n),<span class="built_in">y</span>(m)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">get_x</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">get_y</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> y;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>&#123;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            Point o;</span><br><span class="line">            <span class="type">double</span> r;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(Point p,<span class="type">double</span> x):<span class="built_in">o</span>(p)&#123;r = x;&#125;</span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">isPointIn</span><span class="params">(Point p)</span></span>&#123;</span><br><span class="line">                <span class="type">double</span> a = o.<span class="built_in">get_x</span>();</span><br><span class="line">                <span class="type">double</span> b = o.<span class="built_in">get_y</span>();</span><br><span class="line">                <span class="type">double</span> c = p.<span class="built_in">get_x</span>();</span><br><span class="line">                <span class="type">double</span> d = p.<span class="built_in">get_y</span>();</span><br><span class="line">                <span class="type">double</span> x = <span class="built_in">sqrt</span>((a - c) * (a - c) + (b - d) * (b - d));</span><br><span class="line">                <span class="keyword">if</span>(x &lt; r)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2025/09/10/%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/">并发问题</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2025-09-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2025-11-26</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>该例子是一个生产者一个消费者，缓冲区是1，如果缓冲区很大这个问题就会被忽视了，如果生产者和消费者数量增加，那么死锁概率也会增加</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误的</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait</span><span class="params">(<span class="keyword">struct</span> condvar *cv, <span class="type">mutex_t</span> *mutex)</span>&#123;</span><br><span class="line">    mutex_lock(&amp;cv -&gt; lock);</span><br><span class="line">    cv -&gt; nwait++;</span><br><span class="line">    mutex_unlock(&amp;cv -&gt; lock);</span><br><span class="line"><span class="comment">//理想状态是球在生产者和消费者之间传递    </span></span><br><span class="line">    mutex_unlock(mutex);</span><br><span class="line">    <span class="comment">//但是如果在这里broadcast抢占，先唤醒了，然后nwait=0了，</span></span><br><span class="line">    <span class="comment">//就相当于唤醒了另一个同样是生产者或者是消费者线程甚至是自己把球抢走了，再检查条件再进入wait,但是没有线程再放球了就会死锁</span></span><br><span class="line">    P(&amp;cv -&gt; sleep);<span class="comment">//这个睡眠和解锁顺序不能更改</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    mutex_lock(mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>问题是，为什么前一个线程执行完的broadcast后，consumer（12896）为什么没被唤醒，而后面的producer(12897)被唤醒了，而且例子中只有一个生产者和一个消费者，缓冲区大小为1</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">------Consumer: begin, execution count: <span class="number">12896</span>------</span><br><span class="line">Consumer: Waiting</span><br><span class="line">------waiting------</span><br><span class="line">in wait nwait: <span class="number">1</span></span><br><span class="line">waiting before sleep</span><br><span class="line"></span><br><span class="line">------Producer: begin, execution count: <span class="number">12896</span>------</span><br><span class="line">(</span><br><span class="line">depth = <span class="number">1</span></span><br><span class="line">Producer: Broadcast</span><br><span class="line">------broadcast_start------</span><br><span class="line">start broadcast</span><br><span class="line"><span class="type">int</span> broadcast nwait: <span class="number">1</span></span><br><span class="line">------broadcast_end------</span><br><span class="line">------Producer: end, execution count: <span class="number">12896</span>------</span><br><span class="line">    </span><br><span class="line">------Producer: begin, execution count: <span class="number">12897</span>------</span><br><span class="line">Producer: Waiting</span><br><span class="line">------waiting------</span><br><span class="line">in wait nwait: <span class="number">1</span></span><br><span class="line">waiting before sleep</span><br><span class="line">------waiting out------</span><br><span class="line">Producer: Waiting</span><br><span class="line">------waiting------</span><br><span class="line">in wait nwait: <span class="number">2</span></span><br><span class="line">waiting before sleep</span><br></pre></td></tr></table></div></figure>

</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2025/09/10/%E6%A0%87%E5%87%86C%EF%BC%8B%EF%BC%8B%E7%B1%BBstdstring%E7%9A%84%E5%86%85%E5%AD%98%E5%85%B1%E4%BA%AB%E5%92%8CCopy-On-Write%E6%8A%80%E6%9C%AF/">标准C＋＋类stdstring的内存共享和Copy-On-Write技术</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2025-09-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2025-11-26</span></span></div></header><div class="post-body"><div class="post-excerpt"><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/armman/article/details/1741261" >标准C＋＋类std::string的内存共享和Copy-On-Write技术_std::string重新分配内存拷贝字符串-CSDN博客</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><strong>string的懒拷贝</strong></p>
<p>当函数返回一个静态字符串时，这个字符串存储在函数的静态存储区域中。这个静态存储区域在程序的整个生命周期内都存在，并且在程序加载时分配，在程序退出时释放。</p>
<p>在你描述的情况中，函数<code>GetIPAddress</code>返回一个静态字符串，它在动态链接库的地址空间中分配。当动态链接库被释放时，这个地址空间也被释放，导致返回的静态字符串指向的内存变得无效。但是，由于字符串对象的值是存储在这个无效内存中的，所以在后续程序中使用这个字符串时就会出现未定义行为，因为访问了无效的内存地址。</p>
<p>这种情况下，即使程序在后续没有使用到这个字符串，当程序退出时，会调用字符串对象的析构函数，尝试释放这个无效内存，进而导致内存访问异常，导致程序崩溃。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2025/09/10/%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%85%A8%E7%89%B9%E5%8C%96%E4%B8%8E%E5%81%8F%E7%89%B9%E5%8C%96/">模板的全特化与偏特化</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2025-09-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2025-11-26</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="模板的全特化与偏特化"   >
          <a href="#模板的全特化与偏特化" class="heading-link"><i class="fas fa-link"></i></a><a href="#模板的全特化与偏特化" class="headerlink" title="模板的全特化与偏特化"></a>模板的全特化与偏特化</h1>
      <p>模板函数和模板类有的时候可能需要对传入的不同类型进行不同的处理，比如说有的模板传入int或double类型都可以处理，但是传入char型则会出错，这时就需要模板特化的方式。</p>

        <h2 id="类模板全特化："   >
          <a href="#类模板全特化：" class="heading-link"><i class="fas fa-link"></i></a><a href="#类模板全特化：" class="headerlink" title="类模板全特化："></a>类模板全特化：</h2>
      <p>全特化即将模板类型里的所有类型参数全部具体指明之后处理，如下</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;泛化版本构造函数&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;泛化版本&quot;</span>&lt;&lt;endl;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="comment">//把类型取出</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;int,int特化版本构造函数&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       cout&lt;&lt;<span class="string">&quot;int,int特化版本&quot;</span>&lt;&lt;endl;    </span><br><span class="line">   &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p><code>template&lt;&gt;</code>中为空，代表所有类型都在下面特殊化处理，上面相当于对int,int进行了分别的处理，其他类型依然是泛化版本。</p>

        <h3 id="对类中的某个成员函数进行特化处理"   >
          <a href="#对类中的某个成员函数进行特化处理" class="heading-link"><i class="fas fa-link"></i></a><a href="#对类中的某个成员函数进行特化处理" class="headerlink" title="对类中的某个成员函数进行特化处理"></a>对类中的某个成员函数进行特化处理</h3>
      <p>还是以上面给的例子为基础，特化func()成员函数，当A的模板参数为&lt;int,double&gt;时，调用特化版的func()。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> A&lt;<span class="type">int</span>,<span class="type">double</span>&gt;::func</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;int,double特化版本函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="类模板的偏特化"   >
          <a href="#类模板的偏特化" class="heading-link"><i class="fas fa-link"></i></a><a href="#类模板的偏特化" class="headerlink" title="类模板的偏特化"></a>类模板的偏特化</h2>
      <p>类模板偏特化（局部特化）：顾名思义，只特殊化几个参数或者一定的参数范围</p>

        <h3 id="个数偏特化"   >
          <a href="#个数偏特化" class="heading-link"><i class="fas fa-link"></i></a><a href="#个数偏特化" class="headerlink" title="个数偏特化"></a>个数偏特化</h3>
      <figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> C,<span class="keyword">typename</span> D&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;泛化版本&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&lt;<span class="type">int</span>,C,<span class="type">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;int,C,int偏特化版本&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p><code>template&lt;&gt;</code>括号中存留的参数是依然可以任意填的参数。</p>
<p>STL中的一个个数偏特化例子：</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> vector&#123;&#125;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span>&lt;<span class="type">bool</span>, Alloc&gt;  </span><br><span class="line">&#123;&#125;;</span><br></pre></td></tr></table></div></figure>




        <h3 id="范围偏特化"   >
          <a href="#范围偏特化" class="heading-link"><i class="fas fa-link"></i></a><a href="#范围偏特化" class="headerlink" title="范围偏特化"></a>范围偏特化</h3>
      <p><strong>记住这种情况的template&lt;&gt;中还是要填上原有的大类型</strong>，且<code>const T*属于T*不属于const T</code>。</p>
<p>注意范围二字，<code>比如const int属于int的一个小范围，int *和const int*属于int的一个小范围，int&amp;属于int的一个小范围，int&amp;&amp;属于int的一个小范围</code></p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;泛化版本&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&lt;<span class="type">const</span> T&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;const T版本&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&lt;T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;T*版本&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>



<p>STL中的一个范围偏特化例子：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/5dfcc94de47d1100dba17b4524b6b7b6.png" alt="在这里插入图片描述"></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2025/09/10/%E8%B0%83%E8%AF%95/">调试</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2025-09-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2025-11-26</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h3 id="理解状态机执行：不是-“调试”，也是-“调试”"   >
          <a href="#理解状态机执行：不是-“调试”，也是-“调试”" class="heading-link"><i class="fas fa-link"></i></a><a href="#理解状态机执行：不是-“调试”，也是-“调试”" class="headerlink" title="理解状态机执行：不是 “调试”，也是 “调试”"></a>理解状态机执行：不是 “调试”，也是 “调试”</h3>
      <ul>
<li><code>ssh</code>：使用 <code>-v</code> 选项检查日志</li>
<li><code>gcc</code>：使用 <code>-v</code> 选项打印各种过程</li>
<li><code>make</code>：使用 <code>-nB</code> 选项查看完整命令历史</li>
</ul>

        <h3 id="调试：不仅是-“调试器”"   >
          <a href="#调试：不仅是-“调试器”" class="heading-link"><i class="fas fa-link"></i></a><a href="#调试：不仅是-“调试器”" class="headerlink" title="调试：不仅是 “调试器”"></a>调试：不仅是 “调试器”</h3>
      <ul>
<li>Profiler: <code>perf</code> - “采样” 状态机</li>
<li>Trace: <code>strace</code> - 追踪系统调用</li>
</ul>
<p>将日志文件重定向到vim进行各种操作</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -f g++ a.cc |&amp; vim -</span><br></pre></td></tr></table></div></figure>

<p>执行 <code>grep</code> 命令进行过滤，可以通过 <code>:!</code> 来运行外部命令并将结果显示在 <code>vim</code> 中。</p>
<p>步骤如下：</p>
<ol>
<li><p>在 <code>vim</code> 中输入：</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:!grep <span class="string">&quot;关键词&quot;</span> 文件名</span><br></pre></td></tr></table></div></figure>

<p>或者，你可以直接对 <code>vim</code> 缓冲区的内容使用管道进行过滤：</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%!grep <span class="string">&quot;关键词&quot;</span></span><br></pre></td></tr></table></div></figure>

<ul>
<li><code>:!grep &quot;关键词&quot;</code>：会在当前终端执行 <code>grep</code>，但不影响你在 <code>vim</code> 中的内容。</li>
<li><code>:%!grep &quot;关键词&quot;</code>：会将当前文件内容通过管道传递给 <code>grep</code>，然后将过滤结果替换当前文件的内容。</li>
</ul>
</li>
<li><p>例如：</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%!grep <span class="string">&quot;error&quot;</span></span><br></pre></td></tr></table></div></figure>

<p>这会将所有包含 <code>error</code> 的行保留，并替换掉当前缓冲区的内容。</p>
</li>
</ol>
<p>如果包含.h这种，使用转义字符</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%!grep <span class="string">&quot;\.h&quot;</span></span><br></pre></td></tr></table></div></figure>

</div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/page/5/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/stun-logo.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">hello world</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/linyuww" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="http://47.104.22.42:3000/" target="_blank" rel="noopener" data-popover="social.Tetris" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fas fa-gamepad"></i></span></a><div class="sidebar-ov-ha" style="text-align: center; margin-top: 10px;"><span class="sidebar-ov-social-item sidebar-ha-btn" style="cursor: pointer; display: inline-block;">哈</span><img class="sidebar-ha-img" src="/images/cat_ha.gif" style="display: none; width: 100%; margin-top: 10px;" alt="Ha"></div><script>document.addEventListener('DOMContentLoaded', function() {
  var container = document.querySelector('.sidebar-ov-ha');
  var btn = document.querySelector('.sidebar-ha-btn');
  var img = document.querySelector('.sidebar-ha-img');
  if (btn && img && container) {
    btn.addEventListener('click', function() {
      img.style.display = 'block';
    });
    container.addEventListener('mouseleave', function() {
      img.style.display = 'none';
    });
  }
});
</script></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">64</div><div class="sidebar-ov-state-item__name">Archives</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">5</div><div class="sidebar-ov-state-item__name">Categories</div></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="Search for Posts (Support multiple keywords)"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ Untitled ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', 'Please enter characters');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><div class="aplayer-container"><link class="aplayer-secondary-style-marker" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><meting-js server="netease" type="playlist" id="2556780013" fixed="true" autoplay="false" loop="all" order="list" preload="auto" list-folded="true" list-max-height="500px" lrc-type="0"></meting-js></div><script src="/js/utils.js?v=2.8.0"></script><script src="/js/stun-boot.js?v=2.8.0"></script><script src="/js/scroll.js?v=2.8.0"></script><script src="/js/header.js?v=2.8.0"></script><script src="/js/sidebar.js?v=2.8.0"></script><script type="application/json" src="/search.json"></script><canvas id="snow" style="position:fixed;top:0;left:0;width:100%;height:100%;z-index:99999;pointer-events:none"></canvas><script src="/js/snow.js"></script></body></html>