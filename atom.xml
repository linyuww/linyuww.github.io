<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title></title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-09-10T12:19:36.933Z</updated>
  <id>http://example.com/</id>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++11新特性总结</title>
    <link href="http://example.com/2025/09/10/C++11%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2025/09/10/C++11%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/</id>
    <published>2025-09-10T00:24:18.000Z</published>
    <updated>2025-09-10T12:19:36.933Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="C-11新特性总结"   >          <a href="#C-11新特性总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#C-11新特性总结" class="headerlink" title="C++11新特性总结"></a>C++11新特性总结</h1>              <h3 id="final关键字"   >          <a href="#final关键字" class="heading-link"><i class="fas fa-link"></i></a><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3>      <p>使派生类不可覆盖它所修饰的虚函数</p>        <h3 id="override描述符"   >          <a href="#override描述符" class="heading-link"><i class="fas fa-link"></i></a><a href="#override描述符" class="headerlink" title="override描述符"></a>override描述符</h3>      <p>如果派生类在虚函数声明时使用了override描述符，那么该函数必须重载其基类中的同名函数</p>        <h3 id="关于左值，右值"   >          <a href="#关于左值，右值" class="heading-link"><i class="fas fa-link"></i></a><a href="#关于左值，右值" class="headerlink" title="关于左值，右值"></a>关于左值，右值</h3>      <p><code>C++</code>中所有的值都必然属于左值、右值二者之一。左值是指表达式结束后依然存在的<em>持久化对象</em>，右值是指表达式结束时就不再存在的<em>临时对象</em>。所有的具名变量或者对象都是左值，而右值不具名。很难得到左值和右值的真正定义，但是有一个可以区分左值和右值的便捷方法：<strong>看能不能对表达式取地址，如果能，则为左值，否则为右值</strong>。</p>        <h3 id="右值引用"   >          <a href="#右值引用" class="heading-link"><i class="fas fa-link"></i></a><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3>      <p>左值是指可以出现在&#x3D;左侧者，</p><p>右值是指只能出现在&#x3D;右侧者</p><p>临时对象是个右值</p>        <h5 id="右值引用与move语义的关系"   >          <a href="#右值引用与move语义的关系" class="heading-link"><i class="fas fa-link"></i></a><a href="#右值引用与move语义的关系" class="headerlink" title="右值引用与move语义的关系"></a>右值引用与move语义的关系</h5>      <ul><li>关联性: 右值引用是实现move语义的基础</li><li>作用: 允许”偷取”临时对象的资源而非复制</li><li>应用场景: 容器操作中大量临时对象的处理</li></ul>        <h3 id="移动语义"   >          <a href="#移动语义" class="heading-link"><i class="fas fa-link"></i></a><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h3>      <p>右值则临时对象</p><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.<span class="built_in">insert</span>(ite,<span class="built_in">Vtype</span>(buf));</span><br></pre></td></tr></table></div></figure><p>左值则使用move关键字</p><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">M <span class="title">c1</span><span class="params">(c)</span></span>;</span><br><span class="line"><span class="function">M <span class="title">c2</span><span class="params">(std::move(c1))</span></span>;</span><br></pre></td></tr></table></div></figure><ul><li>核心机制<ul><li>当赋值右侧是右值时，左侧对象可直接”偷取”资源</li><li>避免不必要的资源分配和拷贝</li></ul></li><li>实现要点<ul><li>类需要同时实现拷贝和移动语义版本</li><li>移动操作后原对象应处于有效但未定义状态</li><li>容器需要支持右值版本的插入操作</li></ul></li><li>注意事项<ul><li>被移动后的对象不应再使用</li><li>移动构造函数应标记为noexcept</li><li>临时对象自动被视为右值</li></ul></li><li>典型应用<ul><li>容器扩容时的元素迁移</li><li>返回临时对象的优化</li><li>明确不再使用的左值资源转移</li></ul></li></ul><p>应用</p><ol><li><strong>函数返回值优化</strong>。</li><li><strong>STL 容器的高效插入与操作</strong>。</li><li><strong>动态资源管理（如智能指针）</strong>。</li></ol>        <h3 id="完美转发"   >          <a href="#完美转发" class="heading-link"><i class="fas fa-link"></i></a><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h3>      ]]></content>
    
    
      
      
    <summary type="html">
        &lt;h1 id=&quot;C-11新特性总结&quot;   &gt;
          &lt;a href=&quot;#C-11新特性总结&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;a href=&quot;#C-11新特性总结&quot; clas</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>STL的对比</title>
    <link href="http://example.com/2025/09/10/STL%E7%9A%84%E5%AF%B9%E6%AF%94/"/>
    <id>http://example.com/2025/09/10/STL%E7%9A%84%E5%AF%B9%E6%AF%94/</id>
    <published>2025-09-10T00:24:18.000Z</published>
    <updated>2025-09-10T12:19:36.933Z</updated>
    
    <content type="html"><![CDATA[<div class="table-container"><table><thead><tr><th>容器类型</th><th>底层数据结构</th><th>元素存储特点</th><th>访问方式</th><th>是否支持随机访问</th><th>动态大小调整</th><th>典型应用场景</th></tr></thead><tbody><tr><td><strong><code>vector</code></strong></td><td>动态数组 (连续内存)</td><td>按加入顺序连续存储</td><td>下标访问 (<code>[]</code>)</td><td>是</td><td>是</td><td>动态数组的替代，快速随机访问，大量数据按顺序存取。</td></tr><tr><td><strong><code>deque</code></strong></td><td>分段连续内存</td><td>按加入顺序存储（分段实现）</td><td>双向访问（头尾操作快）</td><td>是</td><td>是</td><td>需要快速在首尾插入与删除，而仍然支持随机访问的场景。</td></tr><tr><td><strong><code>list</code></strong></td><td>双向链表</td><td>不连续，每个元素存储指针</td><td>双向遍历</td><td>否</td><td>是</td><td>频繁插入&#x2F;删除操作的场景，尤其在需要中间修改的情况下。</td></tr><tr><td><strong><code>forward_list</code></strong></td><td>单向链表</td><td>不连续，只有前向指针</td><td>单向遍历</td><td>否</td><td>是</td><td>内存占用较小的场景，在对链表操作需求简单时用作优化。</td></tr><tr><td><strong><code>array</code></strong></td><td>静态数组 (固定大小)</td><td>按加入顺序连续存储</td><td>下标访问 (<code>[]</code>)</td><td>是</td><td>否</td><td>小容量、固定大小、性能关键的场景，避免动态分配。</td></tr><tr><td><strong><code>set</code></strong></td><td>平衡二叉搜索树（通常是 Red-Black 树）</td><td>按键值自动排序</td><td>基于 key 查找和遍历</td><td>否</td><td>是</td><td>唯一值的集合，不允许重复值，支持快速有序的查找和插入。</td></tr><tr><td><strong><code>multiset</code></strong></td><td>平衡二叉搜索树</td><td>按键值自动排序</td><td>基于 key 查找和遍历</td><td>否</td><td>是</td><td>允许重复值的集合，多次插入同一值场景（按顺序存储）。</td></tr><tr><td><strong><code>map</code></strong></td><td>平衡二叉搜索树</td><td>按键值自动排序</td><td>基于 key 查找</td><td>否</td><td>是</td><td>有序的键值对储存，适合频繁按 key 查找具体值的场景。</td></tr><tr><td><strong><code>multimap</code></strong></td><td>平衡二叉搜索树</td><td>按键值自动排序</td><td>基于 key 查找</td><td>否</td><td>是</td><td>允许同一键值存在多个映射值的场景。</td></tr><tr><td><strong><code>unordered_set</code></strong></td><td>哈希表</td><td>无序存储</td><td>常数时间 key 查找</td><td>否</td><td>是</td><td>唯一值的集合，但无需排序，适合大量 key 快速判断是否存在的场景。</td></tr><tr><td><strong><code>unordered_multiset</code></strong></td><td>哈希表</td><td>无序存储</td><td>常数时间 key 查找</td><td>否</td><td>是</td><td>允许重复值的集合，但无序存储，适合大数据去重分析场景。</td></tr><tr><td><strong><code>unordered_map</code></strong></td><td>哈希表</td><td>无序存储</td><td>常数时间 key-value 查找</td><td>否</td><td>是</td><td>可快速通过 key 查找 value 的场景（无需排序）。</td></tr><tr><td><strong><code>unordered_multimap</code></strong></td><td>哈希表</td><td>无序存储</td><td>常数时间 key 查找</td><td>否</td><td>是</td><td>允许同一个 key 存储多个值（无需排序）的场景。</td></tr><tr><td><strong><code>stack</code></strong></td><td>基于 <code>deque</code> 实现</td><td>后进先出 (LIFO)</td><td>只访问顶端 (<code>top</code>)</td><td>否</td><td>是</td><td>后进先出的场景，比如函数调用栈、括号匹配等。</td></tr><tr><td><strong><code>queue</code></strong></td><td>基于 <code>deque</code> 实现</td><td>先进先出 (FIFO)</td><td>只访问头部和尾部</td><td>否</td><td>是</td><td>先进先出的场景，比如任务排队、消息队列等。</td></tr><tr><td><strong><code>priority_queue</code></strong></td><td>基于堆实现</td><td>按优先级排序</td><td>访问最大（默认情况）值</td><td>否</td><td>是</td><td>按优先级任务调度、动态获取最大&#x2F;最小值的场景。</td></tr><tr><td><strong><code>bitset</code></strong></td><td>定长的位数组</td><td>每个位存储 true&#x2F;false</td><td>位访问 (<code>[]</code>)</td><td>是</td><td>否</td><td>高效存储和操作布尔值，适合空间和位运算优化场景。</td></tr></tbody></table></div>        <h4 id="1-底层数据结构"   >          <a href="#1-底层数据结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-底层数据结构" class="headerlink" title="1. 底层数据结构"></a><strong>1. 底层数据结构</strong></h4>      <ul><li><strong>动态数组</strong>：元素连续存放且可动态扩展的数组。</li><li><strong>链表</strong>：使用指针将元素链接而成的结构，可分为单向链表与双向链表。</li><li><strong>平衡二叉树</strong>：自平衡的二叉搜索树，常用的是红黑树（Red-Black Tree）。</li><li><strong>哈希表</strong>：以哈希函数作为索引，通过哈希冲突解决机制（如拉链法）高效存储数据。</li><li><strong>堆</strong>：通常是二叉堆，支持动态调整以保证堆顶始终是最大值或最小值。</li></ul><hr>        <h4 id="2-元素存储特点"   >          <a href="#2-元素存储特点" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-元素存储特点" class="headerlink" title="2. 元素存储特点"></a><strong>2. 元素存储特点</strong></h4>      <ul><li><strong>连续存储</strong>：<code>vector</code> 和 <code>array</code> 采用连续存储，内存紧凑，随机访问快。</li><li><strong>分段连续存储</strong>：<code>deque</code> 分段实现，以保证在头尾添加数据的高效性。</li><li><strong>不连续存储</strong>：<code>list</code>、<code>forward_list</code>、<code>set</code> 等采用链表或树结构，插入&#x2F;删除效率高，但随机访问速度较慢。</li></ul><hr>        <h4 id="3-访问方式"   >          <a href="#3-访问方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-访问方式" class="headerlink" title="3. 访问方式"></a><strong>3. 访问方式</strong></h4>      <ul><li><strong>下标访问 (<code>[]</code>)</strong>：<code>vector</code>、<code>array</code> 支持随机访问，可迅速获取指定位置的元素。</li><li><strong>头尾访问</strong>：<code>stack</code> 和 <code>queue</code> 限制为某些特定操作。</li><li><strong>优先访问</strong>：<code>priority_queue</code> 只能访问堆顶元素（最大值&#x2F;最小值）。</li><li><strong>基于 key 访问</strong>：<code>map</code>、<code>unordered_map</code> 以键值对方式支持查找。</li></ul><hr>        <h4 id="4-是否支持随机访问"   >          <a href="#4-是否支持随机访问" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-是否支持随机访问" class="headerlink" title="4. 是否支持随机访问"></a><strong>4. 是否支持随机访问</strong></h4>      <ul><li>支持随机访问的容器（如 <code>vector</code>、<code>array</code>、<code>deque</code> 等）提供 O(1) 复杂度的下标访问，操作简单。</li><li>不支持随机访问的容器（如 <code>list</code>、<code>set</code> 等）需要遍历或依赖搜索结构，访问效率较低。</li></ul><hr>        <h4 id="5-动态大小调整"   >          <a href="#5-动态大小调整" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-动态大小调整" class="headerlink" title="5. 动态大小调整"></a><strong>5. 动态大小调整</strong></h4>      <ul><li>动态容器（如 <code>vector</code>、<code>deque</code>、<code>list</code>）可以根据元素数目动态分配或收缩内存。</li><li>静态容器（如 <code>array</code>）在定义时需指定固定大小。</li></ul><hr>        <h4 id="6-应用场景"   >          <a href="#6-应用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-应用场景" class="headerlink" title="6. 应用场景"></a><strong>6. 应用场景</strong></h4>      <p>每种容器都有其典型应用场景，选择合适的容器取决于业务需求（如性能、顺序性、查找效率）。</p>        <h4 id="根据需求选择不同容器："   >          <a href="#根据需求选择不同容器：" class="heading-link"><i class="fas fa-link"></i></a><a href="#根据需求选择不同容器：" class="headerlink" title="根据需求选择不同容器："></a>根据需求选择不同容器：</h4>      <ol><li><strong>需要快速随机访问</strong>：使用 <code>vector</code>、<code>array</code>。</li><li><strong>需要频繁插入和删除</strong>：使用 <code>list</code>、<code>deque</code>（插入和删除表现良好）。</li><li><strong>需要数据自动排序</strong>：使用 <code>set</code>、<code>multiset</code>（有序集合）或 <code>map</code>、<code>multimap</code>（有序键值对）。</li><li><strong>需要快速查找，不关心顺序</strong>：优先选择哈希容器，比如 <code>unordered_set</code> 和 <code>unordered_map</code>。</li><li><strong>使用栈或队列模型</strong>：考虑 <code>stack</code>、<code>queue</code> 或 <code>priority_queue</code>。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;table-container&quot;&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;容器类型&lt;/th&gt;
&lt;th&gt;底层数据结构&lt;/th&gt;
&lt;th&gt;元素存储特点&lt;/th&gt;
&lt;th&gt;访问方式&lt;/th&gt;
&lt;th&gt;是否支持随机访问&lt;/th&gt;
&lt;th&gt;动态大小调整&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于项目</title>
    <link href="http://example.com/2025/09/10/%E5%85%B3%E4%BA%8E%E9%A1%B9%E7%9B%AE/"/>
    <id>http://example.com/2025/09/10/%E5%85%B3%E4%BA%8E%E9%A1%B9%E7%9B%AE/</id>
    <published>2025-09-10T00:24:18.000Z</published>
    <updated>2025-09-10T12:19:36.933Z</updated>
    
    <content type="html"><![CDATA[<p>项目背景： 设计并实现了一个基于 Linux 平台的轻量级 HTTP 服务器，采用<strong>多 Reactor 多线程</strong>高并发模型，通过 <strong>epoll 提供高效的 I&#x2F;O 复用</strong>。结合<strong>自动增长缓冲区</strong>、<strong>定时器和异步日志</strong>等技术，实现了高性能和稳定运行的目标。 </p><p>主要工作  </p><p>内存优化：设计了<strong>内存池和 LFU 缓存</strong>，减少内存碎片，提升内存使用效率。  </p><p>高效事件处理：利用 <strong>epoll 多路复用机制</strong>，高效监听和处理客户端连接及数据传输事件。  </p><p>高并发模型：基于 <strong>Reactor 模型</strong>，实现 <strong>One Loop per Thread</strong>，支持多客户端并发连接。  </p><p>动态缓冲区：实现<strong>自动增长缓冲区</strong>，动态调整大小以适配不同请求，优化内存分配。  </p><p>连接管理：使用<strong>小根堆实现高效定时器</strong>，管理连接超时时间，防止长期空闲连接浪费资源。  </p><p>异步日志：设计<strong>异步日志</strong>模块，基于<strong>单例模式和阻塞队列</strong>，实现高效日志写入，避免同步写入的性能开销。 </p>        <h2 id="关于项目"   >          <a href="#关于项目" class="heading-link"><i class="fas fa-link"></i></a><a href="#关于项目" class="headerlink" title="关于项目"></a>关于项目</h2>              <h3 id="介绍一下"   >          <a href="#介绍一下" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍一下" class="headerlink" title="介绍一下"></a>介绍一下</h3>      <p>本项目是一个高性能的WEB服务器，使用C++实现，项目底层采用了多线程多Reactor的网络模型，并且在这基础上增加了内存池，高效的双缓冲异步日志系统，以及LFU的缓存。</p><p>服务器的网络模型是<strong>主从reactor加线程池</strong>的模式，IO处理使用了<strong>非阻塞IO和IO多路复用技术</strong>，具备<strong>处理多个客户端</strong>的http请求和ftp请求，以及对外<strong>提供轻量级储存</strong>的能力。</p><p>项目中的工作可以分为两部分，</p><p>一部分是服务器网络框架、日志系统、存储引擎等一些基本系统的搭建，</p><p>另一部分 是为了提高服务器性能所做的一些优化，比如缓存机制、内存池等一些额外系统的搭建。</p><p>最后还对系统中的部分功能进行了功能和压力测试。对于存储引擎的压力测试，</p><p>在本地测试下，存储引擎读操作的QPS可以达到36万，写操作的QPS可以达到30万。对于网络框架的测试，使用webbench创建1000个进程对服务器进行60s并发请求，测试结果表明，对于短连接的QPS为1.8万，对于长连接的QPS为5.2万。</p>        <h3 id="项目难点"   >          <a href="#项目难点" class="heading-link"><i class="fas fa-link"></i></a><a href="#项目难点" class="headerlink" title="项目难点"></a>项目难点</h3>      <p>根据工作分为两部分</p><p>一部分是服务器网络框架，日志系统，存储引擎等一些基本系统的搭建，这部分的难点主要就是技术理解和选型，以及将一些开源的框架调整后应用到我的项目中去。</p><p>另一部分就是性能优化方面，比如缓存机制，内存池等一些额外系统的搭建。这部分的难点在于找出服务器的性能瓶颈所在，然后结合自己的想法突破瓶颈，提高服务器性能。</p>        <h3 id="遇到的困难，怎么解决"   >          <a href="#遇到的困难，怎么解决" class="heading-link"><i class="fas fa-link"></i></a><a href="#遇到的困难，怎么解决" class="headerlink" title="遇到的困难，怎么解决"></a>遇到的困难，怎么解决</h3>      <p>一方面是对技术理解不够深刻，难以选出合适的技术框架，这部分主要是阅读作者的技术文档，找相关的解析文章看</p><p>另一部分是编程遇到的困难，由于工程能力不足出现bug，这部分主要是通过日志定位bug，推断bug出现的原因并尝试修复，如果以自己能力无法修复，先问问ai能提供什么思路，或者搜索相关的博客。</p>        <h2 id="内存优化"   >          <a href="#内存优化" class="heading-link"><i class="fas fa-link"></i></a><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h2>      <p>设计了<strong>内存池</strong>和 <strong>LFU 缓存</strong></p>        <h3 id="缓存机制"   >          <a href="#缓存机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h3>              <h3 id="为什么选择LFU"   >          <a href="#为什么选择LFU" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么选择LFU" class="headerlink" title="为什么选择LFU"></a>为什么选择LFU</h3>      <p>因为最近加入的数据因为起始的频率很低，容易被淘汰，而早期的热点数据会一直占据缓存。</p>        <h2 id="高效事件处理："   >          <a href="#高效事件处理：" class="heading-link"><i class="fas fa-link"></i></a><a href="#高效事件处理：" class="headerlink" title="高效事件处理："></a>高效事件处理：</h2>      <p><strong>epoll 多路复用机制</strong></p><p>采用非阻塞I&#x2F;O模型，执行系统调用就立即返回，不检查事件是否发生，没有立即发生返回-1，errno设置为在处理中。所以要采用I&#x2F;O通知机制（I&#x2F;O复用和SIGIO信号）来得知就绪事件。</p><figure class="highlight tex"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">I/O多路复用技术</span><br><span class="line">I/O 多路复用允许一个线程同时监视多个 I/O 文件描述符（如网络 socket），并在其中一个或多个文件描述符变为&quot;可操作&quot;时返回。应用程序可以据此进行相应的 I/O 操作（如读、写）。</span><br><span class="line"></span><br><span class="line">1.1 select</span><br><span class="line">简介</span><br><span class="line">select 是一种最早的 I/O 多路复用接口，几乎所有主流平台都支持。</span><br><span class="line"></span><br><span class="line">它允许程序监视多个文件描述符，查询它们是否可读、可写或出现错误。</span><br><span class="line">select 的接口会使用三个位图（readset、writeset 和 exceptset）指定文件描述符的状态。</span><br><span class="line">工作原理</span><br><span class="line">调用 select 时，程序将文件描述符集（一个位图）传递给内核。</span><br><span class="line">内核在超时时间内扫描这些文件描述符并返回那些状态发生变化的描述符（如变为可读或可写）。</span><br><span class="line">用户态程序可根据返回结果进行相应的 I/O 操作。</span><br><span class="line">缺点</span><br><span class="line">支持的文件描述符数量有限（通常受 FD<span class="built_in">_</span>SETSIZE 限制，默认 1024）。</span><br><span class="line">每次调用时都需要将文件描述符的状态从用户态复制到内核态，这带来一定的性能开销。</span><br><span class="line">内核需要线性遍历所有文件描述符（效率低），尤其在大并发连接时性能较差。</span><br><span class="line">1.2 poll</span><br><span class="line">简介</span><br><span class="line">poll 是 select 的改进版本，克服了文件描述符数量限制的问题。</span><br><span class="line"></span><br><span class="line">它使用一个数组结构而不是位图来描述文件描述符及其事件。</span><br><span class="line">工作原理</span><br><span class="line">用户定义一个 pollfd 数组，该数组中每一个元素保存一个文件描述符及其相关事件。</span><br><span class="line">调用 poll 时，内核会遍历这个数组，检查哪些文件描述符有事件发生，并返回结果。</span><br><span class="line">优点</span><br><span class="line">支持任意数量的文件描述符，突破了 select 的 FD<span class="built_in">_</span>SETSIZE 限制。</span><br><span class="line">缺点</span><br><span class="line">和 select 类似，每次调用都需要将监控的文件描述符数组从用户态复制到内核态，开销较大。</span><br><span class="line">和 select 一样，内核需要线性遍历文件描述符，在高并发场景下效率仍然较低。</span><br><span class="line">1.3 epoll</span><br><span class="line">简介</span><br><span class="line">epoll 是 Linux 平台下提供的高性能 I/O 多路复用接口，它是 select 和 poll 的替代品。</span><br><span class="line"></span><br><span class="line">epoll 被设计用于解决 select 和 poll 的性能问题，是一种效率更高的方式处理大量并发连接的技术。</span><br><span class="line">工作原理</span><br><span class="line">epoll 的核心思想是使用事件驱动机制（Event-Driven）替代轮询机制。</span><br><span class="line"></span><br><span class="line">创建一个 epoll 实例（epoll<span class="built_in">_</span>create），用作事件管理器。</span><br><span class="line">使用 epoll<span class="built_in">_</span>ctl 向内核注册需要监听的具体文件描述符及其事件类型（关注可读、可写或异常事件）。</span><br><span class="line">调用 epoll<span class="built_in">_</span>wait，等待事件发生。</span><br><span class="line">发生事件的文件描述符被加入到一个内核维护的就绪列表，并从中直接返回。</span><br><span class="line">这避免了不必要的遍历额外文件描述符的开销。</span><br><span class="line">优点</span><br><span class="line">事件驱动模型：文件描述符有变化时通过回调机制加入就绪列表，只需处理活跃文件描述符。</span><br><span class="line">无大小限制：最大受限于系统的内存资源，而非固定限制。</span><br><span class="line">高性能：避免了线性遍历，即使监视十万连接，只需处理少量已就绪的描述符。</span><br><span class="line">缺点</span><br><span class="line">仅支持 Linux 系统，不跨平台。</span><br><span class="line">epoll 的两种触发模式</span><br><span class="line">LT（Level Trigger，水平触发）： 默认模式，文件描述符只要处于就绪状态，就会不断返回。</span><br><span class="line">ET（Edge Trigger，边缘触发）： 更高效，只在文件描述符状态从未就绪到就绪时触发（适用于非阻塞 I/O）</span><br></pre></td></tr></table></div></figure>        <h3 id="IO多路复用"   >          <a href="#IO多路复用" class="heading-link"><i class="fas fa-link"></i></a><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3>              <h3 id="LT与ET"   >          <a href="#LT与ET" class="heading-link"><i class="fas fa-link"></i></a><a href="#LT与ET" class="headerlink" title="LT与ET"></a>LT与ET</h3>      <p>LT:水平触发模式，只要内核缓冲区有数据就一直通知，只要socket处于可读状态就一直返回sockfd；是默认的工作模式，支持阻塞IO和非阻塞IO</p><p>ET：边沿触发模式，只有状态发生变化才通知并且这个状态只会通知一次，只有当socket由不可写到可写或由不可读到可读，才会返回sockfd：只支持非阻塞IO</p>        <h3 id="为什么用epoll，其他多路复用方式以及区别"   >          <a href="#为什么用epoll，其他多路复用方式以及区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么用epoll，其他多路复用方式以及区别" class="headerlink" title="为什么用epoll，其他多路复用方式以及区别"></a>为什么用epoll，其他多路复用方式以及区别</h3>              <h2 id="高并发模型"   >          <a href="#高并发模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#高并发模型" class="headerlink" title="高并发模型"></a>高并发模型</h2>      <p>基于 <strong>Reactor 模型</strong>，实现 One Loop per Thread</p><p>Reactor模式通常用同步I&#x2F;O模型实现</p><p>Proactor模式通常用异步I&#x2F;O模型实现</p><ol><li>主线程往epoll内核事件表注册socket读就绪事件</li><li>主线程调用epoll_wait等待socket上有数据可读</li><li>当socket上有数据可读时，epoll_wait通知主线程，主线程将socket可读事件放入请求队列</li><li>工作线程被唤醒，读数据处理请求，然后往epoll内核事件表注测socket写就绪事件</li><li>主线程调用epoll_wait等待socket可写</li><li>当socket可写，epoll_wait通知主线程，主线程将socket可写事件放入请求队列</li><li>睡眠在请求队列的工作线程被唤醒，往socket上写入服务器处理客户请求的结果</li></ol>        <h2 id="动态缓冲区"   >          <a href="#动态缓冲区" class="heading-link"><i class="fas fa-link"></i></a><a href="#动态缓冲区" class="headerlink" title="动态缓冲区"></a>动态缓冲区</h2>      <p>实现<strong>自动增长缓冲区</strong></p><p><strong>1. 核心数据结构</strong></p><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">char</span>&gt; buffer_;  <span class="comment">// 主缓冲区（使用vector自动管理内存）</span></span><br><span class="line">    <span class="type">size_t</span> readerIndex_;         <span class="comment">// 读指针（数据起始位置）</span></span><br><span class="line">    <span class="type">size_t</span> writerIndex_;         <span class="comment">// 写指针（数据结束位置）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p>采用vector作为底层容器，自动处理内存分配&#x2F;释放</p><p>读写指针分离设计，支持零拷贝操作</p><p><code>零拷贝是指计算机执行IO操作时，CPU不需要将数据从一个存储区域复制到另一个存储区域，从而可以减少上下文切换以及CPU的拷贝时间。它是一种I/O操作优化技术。</code></p><p><strong>2. 自动增长机制</strong></p><p><strong>(1) 扩容触发条件</strong></p><p>当<code>writableBytes() &lt; 待写入数据量</code>时自动扩容</p><p>通过vector的resize实现：</p><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* data, <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">writableBytes</span>() &lt; len) &#123;</span><br><span class="line">        <span class="built_in">makeSpace</span>(len);  <span class="comment">// 扩容操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">copy</span>(data, data+len, <span class="built_in">beginWrite</span>());</span><br><span class="line">    writerIndex_ += len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><strong>(2) 智能扩容策略</strong></p><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeSpace</span><span class="params">(<span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">writableBytes</span>() + <span class="built_in">prependableBytes</span>() &lt; len) &#123;</span><br><span class="line">        <span class="comment">// 需要真正扩容：vector.resize(writerIndex_ + len)</span></span><br><span class="line">        buffer_.<span class="built_in">resize</span>(writerIndex_ + len);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 通过移动数据复用空间</span></span><br><span class="line">        <span class="type">size_t</span> readable = <span class="built_in">readableBytes</span>();</span><br><span class="line">        std::<span class="built_in">copy</span>(<span class="built_in">begin</span>()+readerIndex_, <span class="built_in">begin</span>()+writerIndex_, <span class="built_in">begin</span>());</span><br><span class="line">        readerIndex_ = <span class="number">0</span>;</span><br><span class="line">        writerIndex_ = readable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><strong>3. 高性能IO优化</strong></p><p><strong>(1) 双缓冲区读操作</strong></p><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">readFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* saveErrno)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> extrabuf[<span class="number">65536</span>]; <span class="comment">// 64KB栈缓冲区</span></span><br><span class="line">    iovec vec[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    vec[<span class="number">0</span>].iov_base = <span class="built_in">begin</span>() + writerIndex_;</span><br><span class="line">    vec[<span class="number">0</span>].iov_len = <span class="built_in">writableBytes</span>();</span><br><span class="line">    vec[<span class="number">1</span>].iov_base = extrabuf;</span><br><span class="line">    vec[<span class="number">1</span>].iov_len = <span class="built_in">sizeof</span>(extrabuf);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据剩余空间决定使用1个还是2个缓冲区</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> iovcnt = (<span class="built_in">writableBytes</span>() &lt; <span class="built_in">sizeof</span>(extrabuf)) ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="type">ssize_t</span> n = <span class="built_in">readv</span>(fd, vec, iovcnt);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理读入的数据...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>使用<code>readv</code>系统调用实现分散读</p><p>优先使用主缓冲区空间，不足时使用栈缓冲区过渡</p><p>避免频繁扩容带来的性能损耗</p><p><strong>(2) 写操作优化</strong></p><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">writeFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* saveErrno)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ::<span class="built_in">write</span>(fd, <span class="built_in">peek</span>(), <span class="built_in">readableBytes</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>直接使用<code>write</code>系统调用</p><p><code>peek()</code>返回有效数据起始指针，避免内存拷贝</p><p><strong>4. 关键特性总结</strong></p><ol><li><p><strong>智能扩容</strong>：按需自动增长，兼顾内存使用效率</p></li><li><p><strong>零拷贝设计</strong>：读写指针分离，减少内存拷贝</p></li><li><p><strong>双缓冲策略</strong>：栈空间+主缓冲区组合优化IO性能</p></li><li><p><strong>线程安全</strong>：单次IO操作原子性保证</p></li><li><p><strong>内存高效</strong>：自动回收已读区域空间</p></li></ol><p>典型工作流程：</p><ol><li><p>读取数据时优先使用主缓冲区空间</p></li><li><p>空间不足时暂存到栈缓冲区</p></li><li><p>触发自动扩容后合并数据</p></li><li><p>写入数据时直接操作有效数据区域</p></li></ol>        <h2 id="连接管理"   >          <a href="#连接管理" class="heading-link"><i class="fas fa-link"></i></a><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2>      <p>使用<strong>小根堆实现高效定时器</strong>，管理连接超时时间</p><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Entry = std::pair&lt;Timestamp, Timer*&gt;; <span class="comment">// 以时间戳作为键值获取定时器</span></span><br><span class="line"><span class="keyword">using</span> TimerList = std::set&lt;Entry&gt;;          <span class="comment">// 底层使用红黑树管理，自动按照时间戳进行排序</span></span><br></pre></td></tr></table></div></figure><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定时器管理红黑树插入此新定时器</span></span><br><span class="line">timers_.<span class="built_in">insert</span>(<span class="built_in">Entry</span>(when, timer));</span><br></pre></td></tr></table></div></figure>        <h2 id="异步日志"   >          <a href="#异步日志" class="heading-link"><i class="fas fa-link"></i></a><a href="#异步日志" class="headerlink" title="异步日志"></a>异步日志</h2>      <p>设计<strong>异步日志</strong>模块，基于<strong>单例模式和阻塞队列</strong></p><p>日志系统是多生产者，单消费者的任务场景</p><p>多生产者负责把日志写入缓冲区，单消费者负责把缓冲区数据写入文件</p><p><img   src="https://cdn.nlark.com/yuque/0/2025/png/47188040/1737792284038-49feb6bc-6920-4e1c-9c4a-516ffee44982.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_26,text_5Luj56CB6ZqP5oOz5b2V55-l6K-G5pif55CD,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" style="width: image/watermark,type_d3F5LW1pY3JvaGVp,size_26,tepx;height: t_5Luj56CB6ZqP5oOz5b2V55-l6K-G5pif55CD,color_FFFFFF,shadow_50,t_80,g_se,px;"  alt="img"></p><p>前端往后端写，后端往硬盘写</p><p>双缓冲技术 ，写满就交换，相当于将多条日志拼接成一个大buffer传送到后端然后写入文件，减少了线程开销</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;项目背景： 设计并实现了一个基于 Linux 平台的轻量级 HTTP 服务器，采用&lt;strong&gt;多 Reactor 多线程&lt;/strong&gt;高并发模型，通过 &lt;strong&gt;epoll 提供高效的 I&amp;#x2F;O 复用&lt;/strong&gt;。结合&lt;strong&gt;自动增长缓冲</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>其他项目问题</title>
    <link href="http://example.com/2025/09/10/%E5%85%B6%E4%BB%96%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2025/09/10/%E5%85%B6%E4%BB%96%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98/</id>
    <published>2025-09-10T00:24:18.000Z</published>
    <updated>2025-09-10T12:19:36.933Z</updated>
    
    <content type="html"><![CDATA[        <h3 id="为什么服务器要以root身份启动，不能以root身份运行"   >          <a href="#为什么服务器要以root身份启动，不能以root身份运行" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么服务器要以root身份启动，不能以root身份运行" class="headerlink" title="为什么服务器要以root身份启动，不能以root身份运行"></a>为什么服务器要以root身份启动，不能以root身份运行</h3>      <p>为什么要以 root 启动？</p><p>绑定低编号端口（如 80、443）。<br>配置共享内存、设备文件、调整资源等需要的高权限操作。</p><p>为什么不能以 root 运行？</p><p>潜在漏洞可能导致系统被完全攻破。<br>不符合最小权限原则。<br>服务隔离无法实现，其他服务可能受到影响。<br>意外操作可能导致灾难性的后果。<br>如何解决这个问题？</p><p>启动时以 root 完成特权操作，然后立刻降级为普通用户运行。<br>使用 setuid() 和 setgid() 等 Linux 用户管理接口实现特权降级。</p>]]></content>
    
    
      
      
    <summary type="html">
        &lt;h3 id=&quot;为什么服务器要以root身份启动，不能以root身份运行&quot;   &gt;
          &lt;a href=&quot;#为什么服务器要以root身份启动，不能以root身份运行&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-l</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>其他问题</title>
    <link href="http://example.com/2025/09/10/%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2025/09/10/%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98/</id>
    <published>2025-09-10T00:24:18.000Z</published>
    <updated>2025-09-10T12:19:36.933Z</updated>
    
    <content type="html"><![CDATA[        <h2 id="Mysql问题"   >          <a href="#Mysql问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#Mysql问题" class="headerlink" title="Mysql问题"></a>Mysql问题</h2>      <p> 说一说事物隔离级别 </p><p>SQL标准的事务隔离级别包括：</p><p>读未提交，读提交，可重复读，串行化</p><p> 事务的四大特性有哪些？ </p><p>原子性，一致性，隔离性，持久性</p>        <h2 id="Linux系统目录"   >          <a href="#Linux系统目录" class="heading-link"><i class="fas fa-link"></i></a><a href="#Linux系统目录" class="headerlink" title="Linux系统目录"></a>Linux系统目录</h2>      <p><img src="C:/Users/86147/Desktop/%E9%9D%A2%E8%AF%95/%E7%9B%AE%E5%BD%952.webp" alt="目录2"></p>]]></content>
    
    
      
      
    <summary type="html">
        &lt;h2 id=&quot;Mysql问题&quot;   &gt;
          &lt;a href=&quot;#Mysql问题&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;a href=&quot;#Mysql问题&quot; class=&quot;hea</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>字节面试准备</title>
    <link href="http://example.com/2025/09/10/%E5%AD%97%E8%8A%82%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
    <id>http://example.com/2025/09/10/%E5%AD%97%E8%8A%82%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/</id>
    <published>2025-09-10T00:24:18.000Z</published>
    <updated>2025-09-10T12:19:36.933Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="字节面试准备"   >          <a href="#字节面试准备" class="heading-link"><i class="fas fa-link"></i></a><a href="#字节面试准备" class="headerlink" title="字节面试准备"></a>字节面试准备</h1>              <h3 id="1-C-基础"   >          <a href="#1-C-基础" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-C-基础" class="headerlink" title="1. C++ 基础"></a><strong>1. C++ 基础</strong></h3>              <h4 id="1-面向对象的三个特性"   >          <a href="#1-面向对象的三个特性" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-面向对象的三个特性" class="headerlink" title="(1) 面向对象的三个特性"></a><strong>(1) 面向对象的三个特性</strong></h4>      <p>C++ 是一种支持面向对象编程的语言，其面向对象编程的三个核心特性是：封装（Encapsulation）、继承（Inheritance）、多态（Polymorphism）。</p><ul><li><p><strong>封装</strong><br>封装是将数据（成员变量）和操作这些数据的代码（成员函数）绑定在一起，形成一个整体（类）。<br><strong>优点：</strong></p><ul><li>限制对内部成员的访问，保护数据隐私（通过 <code>public</code>、<code>protected</code>、<code>private</code> 访问权限控制关键字）。</li><li>提高代码的可维护性和复用性。</li></ul></li><li><p><strong>继承</strong><br>继承是一种用于实现代码复用和建立层次化关系的机制。子类可以继承父类的属性和行为。<br><strong>优点：</strong></p><ul><li>重用父类代码。</li><li>可以通过父类指针或引用操作多态对象。</li></ul></li><li><p><strong>多态</strong><br>多态是允许通过基类引用或指针访问派生类对象，并调用派生类的重写方法。基于动态绑定（Run-time Polymorphism）的多态主要通过虚函数实现。<br><strong>优点：</strong></p><ul><li>提高代码的扩展性和灵活性，可以使用统一的接口处理不同类型的对象。</li></ul></li></ul>        <h4 id="2-多态和虚函数的底层实现"   >          <a href="#2-多态和虚函数的底层实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-多态和虚函数的底层实现" class="headerlink" title="(2) 多态和虚函数的底层实现"></a><strong>(2) 多态和虚函数的底层实现</strong></h4>      <ul><li><p><strong>多态的实现</strong></p><ul><li>多态的核心是通过 <strong>虚函数表（Virtual Table）和虚函数表指针</strong>实现的。</li><li>编译器会在类中生成一个指向虚函数表的指针，称为 <strong>vptr</strong>。</li><li>虚函数表是一个数组，存储了该类的所有虚函数的函数指针。</li><li>在运行时，通过 <code>vptr</code> 指向的虚函数表，根据实际的动态类型调用对应的方法。</li></ul></li><li><p><strong>虚函数的底层实现</strong></p><ul><li>类中有虚函数时，类会生成一个虚函数表（存储虚函数指针）。</li><li>每个对象的内存布局中会加入一个指向虚函数表的指针（vptr）。</li><li>通过 <code>vptr</code> 和虚函数表在运行时找到并调用具体的函数。</li></ul></li></ul><p>示例：</p><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* obj = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    obj-&gt;<span class="built_in">display</span>(); <span class="comment">// 执行 Derived::display()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><strong>区别场景：带虚函数与不带虚函数</strong></p><ul><li>如果类中没有虚函数，那么对象内存只存储成员变量。</li><li>带虚函数的类，内存中会存储额外的虚函数表指针。</li><li>因此，带虚函数的对象的内存占用会比没有虚函数的对象多。</li></ul><hr>        <h4 id="3-多继承的特殊情况（菱形继承问题）"   >          <a href="#3-多继承的特殊情况（菱形继承问题）" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-多继承的特殊情况（菱形继承问题）" class="headerlink" title="(3) 多继承的特殊情况（菱形继承问题）"></a><strong>(3) 多继承的特殊情况（菱形继承问题）</strong></h4>      <p>场景：如何区分多继承中调用的同名成员和方法？</p><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;A::func()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;B::func()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;C::func()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    D obj;</span><br><span class="line">    <span class="comment">// 调用 B::func 或 C::func？</span></span><br><span class="line">    obj.B::<span class="built_in">func</span>(); <span class="comment">// 通过类名加作用域区分</span></span><br><span class="line">    obj.C::<span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><strong>菱形继承问题的解决方式：</strong></p><ul><li>普通继承会导致 <code>A</code> 的成员在 <code>B</code> 和 <code>C</code> 中各有一份（两份副本）。</li><li>使用 <strong>虚继承</strong> 可以解决该问题，确保 <code>A</code> 的成员在多继承的子类中只有一份。</li></ul><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="keyword">public</span>: <span class="type">int</span> x; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;&#125;;</span><br></pre></td></tr></table></div></figure><p><code>D</code> 类中只有一份 <code>A::x</code>。</p><hr>        <h3 id="3-内存"   >          <a href="#3-内存" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-内存" class="headerlink" title="3. 内存"></a><strong>3. 内存</strong></h3>              <h4 id="1-malloc-和-new-的区别"   >          <a href="#1-malloc-和-new-的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-malloc-和-new-的区别" class="headerlink" title="(1) malloc 和 new 的区别"></a><strong>(1) malloc 和 new 的区别</strong></h4>      <ol><li><p><strong><code>malloc</code>：</strong></p><ul><li>只分配内存，不调用构造函数。</li><li>返回 <code>void*</code> 需要强制类型转换。</li><li>需要 <code>free</code> 手动释放。</li></ul></li><li><p><strong><code>new</code>：</strong></p><ul><li>分配内存并自动调用构造函数初始化对象。</li><li>返回目标类型的指针，无需强转。</li><li>使用 <code>delete</code> 释放内存并调用析构函数。</li></ul></li></ol>        <h4 id="2-只分配内存或只调用构造函数"   >          <a href="#2-只分配内存或只调用构造函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-只分配内存或只调用构造函数" class="headerlink" title="(2) 只分配内存或只调用构造函数"></a><strong>(2) 只分配内存或只调用构造函数</strong></h4>      <ol><li><p>只分配内存（不调用构造函数）：</p><ul><li>可使用 <code>operator new</code>：<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* ptr = ::<span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(MyClass)); <span class="comment">// 只分配内存</span></span><br></pre></td></tr></table></div></figure></li></ul></li><li><p>只调用构造函数（对象已分配内存）：</p><ul><li>可通过 <code>placement new</code>：<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass* obj = <span class="built_in">new</span>(ptr) <span class="built_in">MyClass</span>(args); <span class="comment">// 在已有内存 `ptr` 上构造对象</span></span><br></pre></td></tr></table></div></figure></li></ul></li></ol><p><strong>operator new：用来分配原始内存，不涉及对象的构造。</strong><br><strong>operator delete：用来释放原始内存，不涉及对象的析构。</strong><br>普通的 new 调用等价于：</p><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass* obj = <span class="built_in">static_cast</span>&lt;MyClass*&gt;(::<span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(MyClass))); <span class="comment">// 分配内存</span></span><br><span class="line"><span class="keyword">new</span> (obj) <span class="built_in">MyClass</span>(); <span class="comment">// 构造对象</span></span><br></pre></td></tr></table></div></figure><p>普通的 delete 调用等价于：</p><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj-&gt;~<span class="built_in">MyClass</span>();             <span class="comment">// 调用析构函数</span></span><br><span class="line">::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(obj)</span></span>;      <span class="comment">// 释放内存</span></span><br></pre></td></tr></table></div></figure><p><strong>注意：new不能重载，只有operator new才能重载</strong></p>        <h4 id="3-sizeof-结构体的对齐规则"   >          <a href="#3-sizeof-结构体的对齐规则" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-sizeof-结构体的对齐规则" class="headerlink" title="(3) sizeof 结构体的对齐规则"></a><strong>(3) <code>sizeof</code> 结构体的对齐规则</strong></h4>      <p>C++ 中结构体内存对齐主要受到以下因素影响：</p><ol><li>每个成员变量的对齐方式由编译器决定（通常与成员类型的大小相关）。</li><li><strong>结构体的总大小必须是最大对齐成员的倍数。</strong></li></ol><p>示例：</p><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S1</span> &#123;</span><br><span class="line">    <span class="type">char</span> A;  <span class="comment">// 1 字节</span></span><br><span class="line">    <span class="type">char</span> B;  <span class="comment">// 1 字节</span></span><br><span class="line">    <span class="type">int</span> C;   <span class="comment">// 4 字节</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S2</span> &#123;</span><br><span class="line">    <span class="type">char</span> A;  <span class="comment">// 1 字节</span></span><br><span class="line">    <span class="type">int</span> C;   <span class="comment">// 4 字节</span></span><br><span class="line">    <span class="type">char</span> B;  <span class="comment">// 1 字节</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><ul><li>对于 S1，内存布局为：<code>A + B + padding + C</code>（总大小 8）</li><li>对于 S2，内存布局为：<code>A + padding + C + B + padding</code>（总大小 12）</li></ul>        <h3 id="4-STL-和智能指针"   >          <a href="#4-STL-和智能指针" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-STL-和智能指针" class="headerlink" title="4. STL 和智能指针"></a><strong>4. STL 和智能指针</strong></h3>              <h4 id="1-智能指针概览"   >          <a href="#1-智能指针概览" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-智能指针概览" class="headerlink" title="(1) 智能指针概览"></a><strong>(1) 智能指针概览</strong></h4>      <p>C++ 标准库提供了三种智能指针：</p><ol><li><strong><code>std::unique_ptr</code></strong>: 独占所有权，不可复制。</li><li><strong><code>std::shared_ptr</code></strong>: 共享所有权，使用引用计数。</li><li><strong><code>std::weak_ptr</code></strong>: 使用弱引用，依赖 <code>shared_ptr</code>，避免循环引用。</li></ol>        <h4 id="2-std-shared-ptr-的实际应用"   >          <a href="#2-std-shared-ptr-的实际应用" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-std-shared-ptr-的实际应用" class="headerlink" title="(2) std::shared_ptr 的实际应用"></a><strong>(2) <code>std::shared_ptr</code> 的实际应用</strong></h4>      <ul><li>场景：共享资源的生命周期管理（如线程池中的任务对象）。</li><li>示例：<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; q = p; <span class="comment">// 引用计数+1</span></span><br><span class="line">&#125; <span class="comment">// q 离开作用域，引用计数-1</span></span><br></pre></td></tr></table></div></figure></li></ul><p><strong>使用智能指针（如 std::shared_ptr）的优点</strong>：</p><p>自动化的内存管理，避免内存泄漏和悬垂指针。简化代码逻辑，减少人工管理内存的复杂性。更容易与标准容器（如 std::vector）配合使用。不使用智能指针是可以的，</p><p>但代价是：</p><p>更容易引入 bug，例如内存泄漏、悬垂指针问题。<br>增加代码维护难度，并且可能需要大量的单元测试来覆盖所有的边界情况。<br>难以保证代码的健壮性，特别是在复杂的资源关系中。</p>        <h3 id="RAII是什么"   >          <a href="#RAII是什么" class="heading-link"><i class="fas fa-link"></i></a><a href="#RAII是什么" class="headerlink" title="RAII是什么"></a>RAII是什么</h3>      <p>RAII（Resource Acquisition Is Initialization，资源获取即初始化）是一种资源管理的编程惯用法，是 C++ 中处理资源管理的重要设计理念。它通过将资源的生命周期与对象的生命周期绑定来确保资源得到正确的分配和释放，从而避免资源泄漏。</p><p><strong>核心思想</strong></p><ol><li><p><strong>资源绑定到对象的生命周期</strong>：</p><ul><li>当一个对象在栈上或通过堆分配时，与该对象相关联的资源（例如内存、文件句柄、锁、网络连接等）也随之初始化。</li><li>当该对象离开作用域（或者析构）时，资源会被自动释放。</li></ul></li><li><p><strong>依靠析构函数来释放资源</strong>：</p><ul><li>C++ 中，当一个对象生命周期结束时，其析构函数会被自动调用。因此，可以利用析构函数自动释放资源，而无需手动释放。</li><li>通过 RAII，资源分配后不用担心异常、早退或其他复杂逻辑干扰正确释放。</li></ul></li></ol><p><strong>RAII 的优点</strong></p><ol><li><strong>自动化资源管理</strong>：用户不需要手动释放资源，不用担心遗漏或错误。</li><li><strong>异常安全</strong>：即使代码中间发生异常，析构函数仍然会自动释放资源。</li><li><strong>代码简洁</strong>：减少了显式的资源释放代码，避免了冗余或错误。</li></ol><p><strong>应用场景</strong></p><p>RAII 在内存分配、文件操作、线程锁、数据库连接等场景广泛应用。例如：</p><ol><li><strong>智能指针</strong>：<ul><li><code>std::unique_ptr</code>：独占资源，适合动态内存管理。</li><li><code>std::shared_ptr</code>：共享资源，适合多个对象共享动态内存。</li></ul></li><li><strong>互斥锁</strong>：<ul><li><code>std::lock_guard&lt;std::mutex&gt;</code> 和 <code>std::unique_lock</code>。</li></ul></li><li><strong>文件与流对象</strong>：<ul><li>C++ 的 IO 流类如 <code>std::ifstream</code> 和 <code>std::ofstream</code>。</li></ul></li><li><strong>其他自定义的资源管理类</strong>：<ul><li>如管理数据库连接、网络套接字、句柄等。</li></ul></li></ol><p><strong>总结</strong></p><p>RAII 的核心就是将资源的生命周期绑定到对象的生命周期，通过构造函数和析构函数确保资源的正确分配和释放。这种机制有效避免了手动管理资源时的各种问题（如资源泄漏、重复释放等），是 C++ 中非常重要的编程思想，尤其在异常安全和代码简洁性方面效果显著。</p><p>面试中，如果被问到 RAII，你可以直接引用 C++ 智能指针、文件流或锁管理类作为例子展开解释。进一步可以说明 RAII 提升了程序的安全性及简洁性，使 C++ 的资源管理更加工程化和易用化。</p>        <h3 id="5-操作系统"   >          <a href="#5-操作系统" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-操作系统" class="headerlink" title="5. 操作系统"></a><strong>5. 操作系统</strong></h3>              <h4 id="1-并发与并行的区别"   >          <a href="#1-并发与并行的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-并发与并行的区别" class="headerlink" title="(1) 并发与并行的区别"></a><strong>(1) 并发与并行的区别</strong></h4>      <ul><li><strong>并发（Concurrency）</strong>：多个任务在逻辑上<strong>同时进行</strong>，但实际上可能是按时间片交替执行。</li><li><strong>并行（Parallelism）</strong>：多个任务在物理上<strong>真正同时运行</strong>（需要多核 CPU 支持）。</li></ul>        <h4 id="2-最大并发线程池设计"   >          <a href="#2-最大并发线程池设计" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-最大并发线程池设计" class="headerlink" title="(2) 最大并发线程池设计"></a><strong>(2) 最大并发线程池设计</strong></h4>      <ul><li>关键点：<ol><li>使用任务队列管理任务。</li><li>通过信号量或条件变量限制线程并发数量。</li><li>动态创建、销毁线程降低资源消耗（即线程复用）。</li></ol></li></ul><hr>        <h3 id="6-网络"   >          <a href="#6-网络" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-网络" class="headerlink" title="6. 网络"></a><strong>6. 网络</strong></h3>              <h4 id="1-HTTPS-的通信过程"   >          <a href="#1-HTTPS-的通信过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-HTTPS-的通信过程" class="headerlink" title="(1) HTTPS 的通信过程"></a><strong>(1) HTTPS 的通信过程</strong></h4>      <ol><li><strong>客户端发送请求</strong>，包括支持的协议版本、加密套件等。</li><li><strong>服务器发送证书</strong>，客户端验证证书的合法性。</li><li><strong>TLS 握手</strong>，双方协商对称密钥（通过非对称加密交换密钥）。</li><li><strong>加密通信</strong>，之后的所有数据使用对称密钥加密。</li></ol><hr>        <h3 id="7-项目挑战"   >          <a href="#7-项目挑战" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-项目挑战" class="headerlink" title="7. 项目挑战"></a><strong>7. 项目挑战</strong></h3>              <h4 id="Buffer-的思想"   >          <a href="#Buffer-的思想" class="heading-link"><i class="fas fa-link"></i></a><a href="#Buffer-的思想" class="headerlink" title="Buffer 的思想"></a><strong>Buffer 的思想</strong></h4>      <ul><li><strong>临时缓存</strong>用于解决数据处理速度的差异（如网络接收速度慢于处理速度）。</li><li>**自动增长：**通过动态分配内存扩容实现，常用 <strong>指数增长（2 倍增长）</strong> 策略；也可以按照具体业务需要调整。</li></ul>]]></content>
    
    
      
      
    <summary type="html">
        &lt;h1 id=&quot;字节面试准备&quot;   &gt;
          &lt;a href=&quot;#字节面试准备&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;a href=&quot;#字节面试准备&quot; class=&quot;header</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>智能指针</title>
    <link href="http://example.com/2025/09/10/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <id>http://example.com/2025/09/10/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</id>
    <published>2025-09-10T00:24:18.000Z</published>
    <updated>2025-09-10T12:19:36.933Z</updated>
    
    <content type="html"><![CDATA[        <h2 id="智能指针"   >          <a href="#智能指针" class="heading-link"><i class="fas fa-link"></i></a><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2>              <h3 id="unique-ptr"   >          <a href="#unique-ptr" class="heading-link"><i class="fas fa-link"></i></a><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a><strong>unique_ptr</strong></h3>      <p>作用域指针，不能复制</p><p>栈分配指针，当死亡时，自动释放所管理的内存，无需显示调用delete</p><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; p1 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>); <span class="comment">// 管理动态分配的内存</span></span><br><span class="line"><span class="comment">// std::unique_ptr&lt;int&gt; p2 = p1; // 错误！unique_ptr不支持拷贝</span></span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; p2 = std::<span class="built_in">move</span>(p1); <span class="comment">// 通过 std::move 转移所有权</span></span><br></pre></td></tr></table></div></figure><p>只能显示调用构造函数，因为其构造函数有<code>explicit</code>关键字，没有了构造函数的隐式转换</p><p>最好的调用还是使用<code>make_unique</code>会捕获异常，不会产生悬空指针问题</p>        <h3 id="shared-ptr"   >          <a href="#shared-ptr" class="heading-link"><i class="fas fa-link"></i></a><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a><strong>shared_ptr</strong></h3>      <p>追踪引用计数，如果引用为0，则释放内存</p><p>需要分配内存用于计数</p><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;Entity&gt; p = <span class="built_in">make_shared</span>&lt;Entity&gt;();</span><br></pre></td></tr></table></div></figure><p>作用主要包括：</p><ol><li>自动管理动态分配的对象，避免手动调用 <code>delete</code>。</li><li>支持共享所有权，让多个 <code>shared_ptr</code> 可以安全地访问同一对象。</li><li>借助引用计数机制，实现对象的生命周期控制，当最后一个 <code>shared_ptr</code> 销毁后，自行释放资源。</li></ol><p><strong><code>unique_ptr</code></strong>：独占所有权，不支持多个指针管理同一个对象；更轻量且不存在循环引用问题。</p><p><strong><code>weak_ptr</code></strong>：用于观察 <code>shared_ptr</code> 管理的对象，不增加引用计数；主要用于辅助 <code>shared_ptr</code>，避免循环引用的问题。</p>        <h3 id="std-weak-ptr"   >          <a href="#std-weak-ptr" class="heading-link"><i class="fas fa-link"></i></a><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a>std::weak_ptr</h3>      <p><code>std::weak_ptr</code> 是 C++11 引入的一种智能指针，和 <code>std::shared_ptr</code> 一起使用，用于避免 <strong>循环引用</strong> 问题，同时提供了一种对 <code>std::shared_ptr</code> 所管理对象的弱引用（non-owning reference）。它不改变所管理对象的引用计数。</p><ul><li><strong>循环引用问题</strong>：<br>在使用 <code>std::shared_ptr</code> 时，如果两个对象互相以 <code>shared_ptr</code> 引用彼此，会导致<strong>内存泄漏</strong>，因为它们的引用计数无法递减到 0。<ul><li><code>shared_ptr</code> 通过引用计数管理对象的生命周期，当引用计数为 0 时，自动释放对象。</li><li>如果存在循环引用，两个对象会始终持有对方，这样它们的引用计数永远不会减为 0，因此无法释放内存。</li></ul></li><li><strong>非拥有性的弱引用</strong>：<br>有时候，一个对象只需要 “观察” 对另一个对象的引用，而无需控制它的生命周期。这时使用 <code>std::weak_ptr</code> 是更合理的选择。</li></ul><p><code>std::weak_ptr</code> 提供了一种临时、不影响生命周期的引用，从而解决了上述问题。</p><p><strong>总结</strong></p><p><code>std::weak_ptr</code> 的主要使用场景包括：</p><ol><li><strong>解决 <code>std::shared_ptr</code> 的循环引用问题</strong>。</li><li><strong>跨组件之间的非拥有性引用</strong>，例如缓存对象的管理。</li><li><strong>事件监听器或回调函数，避免悬垂指针的产生</strong>。</li><li>在弱引用需求场景下提供更加灵活的资源管理，而不是一味增加强引用计数。</li></ol><p><strong><code>std::weak_ptr</code> 的特点</strong></p><ol><li><strong>不控制对象的生命周期</strong>：</li><li><strong>检测对象是否已销毁</strong>：<ul><li>可以通过调用 <code>weak_ptr</code> 的 <code>expired()</code> 方法来检查被引用的对象是否已经销毁。</li></ul></li><li><strong>使用 <code>lock()</code> 转换为 <code>shared_ptr</code></strong>：<ul><li>如果需要安全地访问被引用的对象，可以调用 <code>weak_ptr</code> 的 <code>lock()</code> 方法，返回一个临时的 <code>shared_ptr</code>。如果对象已销毁，<code>lock()</code> 会返回一个空指针。</li></ul></li></ol><p>假设我们有两个类 <code>A</code> 和 <code>B</code>，它们通过 <code>std::shared_ptr</code> 互相引用。如果没有使用 <code>weak_ptr</code>，将会发生循环引用，导致内存泄漏。</p><p><strong>示例代码（循环引用问题）</strong>：</p><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>; <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;B&gt; ptrB; <span class="comment">// A 持有共享指针引用 B</span></span><br><span class="line">    ~<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A destroyed&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;A&gt; ptrA; <span class="comment">// B 持有共享指针引用 A</span></span><br><span class="line">    ~<span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;B destroyed&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建循环引用</span></span><br><span class="line">    <span class="keyword">auto</span> a = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">    <span class="keyword">auto</span> b = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line">    a-&gt;ptrB = b; <span class="comment">// A 持有 B</span></span><br><span class="line">    b-&gt;ptrA = a; <span class="comment">// B 持有 A</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 离开 main() 作用域时，A 和 B 的引用计数不会减到 0，导致内存泄漏</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>运行结果：</p><figure class="highlight text"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 没有输出，因为 `A` 和 `B` 无法正常析构，发生内存泄漏。</span><br></pre></td></tr></table></div></figure><p><strong>解决循环引用的正确做法</strong>：<br>将其中一个引用改为 <code>std::weak_ptr</code>，避免两个对象互相增加引用计数。</p><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>; <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::weak_ptr&lt;B&gt; ptrB; <span class="comment">// 弱引用 B</span></span><br><span class="line">    ~<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A destroyed&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;A&gt; ptrA; <span class="comment">// 共享指针持有 A</span></span><br><span class="line">    ~<span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;B destroyed&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">    <span class="keyword">auto</span> b = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line">    a-&gt;ptrB = b; <span class="comment">// A 弱引用 B</span></span><br><span class="line">    b-&gt;ptrA = a; <span class="comment">// B 持有 A</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 离开作用域时，A 和 B 都将正确析构</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>运行结果：</p><figure class="highlight text"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B destroyed</span><br><span class="line">A destroyed</span><br></pre></td></tr></table></div></figure><p>通过将某一侧的引用改为 <code>std::weak_ptr</code>，打破了循环引用。</p><hr><p><strong>跨组件间的弱引用</strong></p><p>如果某些对象之间并无强依赖关系，但仍需临时引用，则可以使用 <code>std::weak_ptr</code>。</p><p><strong>示例 1：缓存管理</strong><br>在缓存系统中，如果一个对象的存在依赖于被缓存的内容，则可以使用 <code>std::weak_ptr</code>：</p><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CachedObject</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CachedObject</span>(std::string name) : <span class="built_in">name</span>(name) &#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; created&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">CachedObject</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; destroyed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printName</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Object name: &quot;</span> &lt;&lt; name &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unordered_map&lt;std::string, std::weak_ptr&lt;CachedObject&gt;&gt; cache;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> obj1 = std::<span class="built_in">make_shared</span>&lt;CachedObject&gt;(<span class="string">&quot;Object1&quot;</span>);</span><br><span class="line">        cache[<span class="string">&quot;key1&quot;</span>] = obj1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> obj2 = std::<span class="built_in">make_shared</span>&lt;CachedObject&gt;(<span class="string">&quot;Object2&quot;</span>);</span><br><span class="line">        cache[<span class="string">&quot;key2&quot;</span>] = obj2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用缓存中的对象</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> obj = cache[<span class="string">&quot;key1&quot;</span>].<span class="built_in">lock</span>()) &#123;</span><br><span class="line">            obj-&gt;<span class="built_in">printName</span>(); <span class="comment">// 输出：Object name: Object1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// obj1 和 obj2 均超出作用域，被释放</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试访问释放的对象</span></span><br><span class="line">    <span class="keyword">if</span> (cache[<span class="string">&quot;key1&quot;</span>].<span class="built_in">expired</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Object1 no longer exists&quot;</span> &lt;&lt; std::endl; <span class="comment">// 输出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>运行结果：</p><figure class="highlight text"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object1 created</span><br><span class="line">Object2 created</span><br><span class="line">Object name: Object1</span><br><span class="line">Object2 destroyed</span><br><span class="line">Object1 destroyed</span><br><span class="line">Object1 no longer exists</span><br></pre></td></tr></table></div></figure><hr><p><strong>事件回调（防止悬垂引用）</strong></p><p>如果某类对象注册了一个事件监听器或回调函数，而监听器的生命周期可能比被观察的对象短，那么可以使用 <code>std::weak_ptr</code> 避免访问悬垂的指针。</p><p>例如：</p><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventSource</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Listener</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Listener</span>(std::shared_ptr&lt;EventSource&gt; source) : <span class="built_in">source</span>(source) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> src = source.<span class="built_in">lock</span>()) &#123; <span class="comment">// 检查 source 是否仍有效</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Event handled&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Source no longer exists&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::weak_ptr&lt;EventSource&gt; source;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventSource</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;EventSource&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fireEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (listener) <span class="built_in">listener</span>(); <span class="comment">// 调用回调</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setListener</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; callback)</span> </span>&#123;</span><br><span class="line">        listener = callback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; listener;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;EventSource&gt; source = std::<span class="built_in">make_shared</span>&lt;EventSource&gt;();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> listener = std::<span class="built_in">make_shared</span>&lt;Listener&gt;(source);</span><br><span class="line">        source-&gt;<span class="built_in">setListener</span>([listener]() &#123; listener-&gt;<span class="built_in">onEvent</span>(); &#125;);</span><br><span class="line"></span><br><span class="line">        source-&gt;<span class="built_in">fireEvent</span>(); <span class="comment">// 输出：Event handled</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Listener 已销毁，无悬垂引用</span></span><br><span class="line">    source-&gt;<span class="built_in">fireEvent</span>(); <span class="comment">// 不输出，Listener 已解除绑定</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>]]></content>
    
    
      
      
    <summary type="html">
        &lt;h2 id=&quot;智能指针&quot;   &gt;
          &lt;a href=&quot;#智能指针&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;a href=&quot;#智能指针&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>红黑树</title>
    <link href="http://example.com/2025/09/10/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>http://example.com/2025/09/10/%E7%BA%A2%E9%BB%91%E6%A0%91/</id>
    <published>2025-09-10T00:24:18.000Z</published>
    <updated>2025-09-10T12:19:36.933Z</updated>
    
    <content type="html"><![CDATA[        <h2 id="红黑树"   >          <a href="#红黑树" class="heading-link"><i class="fas fa-link"></i></a><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2>              <h3 id="基本规则："   >          <a href="#基本规则：" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本规则：" class="headerlink" title="基本规则："></a>基本规则：</h3>      <p><strong>隐藏的空节点是黑色</strong></p><p>满足Avl树</p><p>根节点和叶子节点都是黑色</p><p>不能有连续两个红色节点</p><p>从根节点到叶子节点的每个路径上黑色节点数量都一致</p>        <h3 id="插入："   >          <a href="#插入：" class="heading-link"><i class="fas fa-link"></i></a><a href="#插入：" class="headerlink" title="插入："></a>插入：</h3>      <p>插入节点是根节点；直接变黑</p><p>插入节点的叔叔是红色；叔父爷爷变色，爷爷变插入节点继续调整</p><p>插入节点的叔叔是黑 ；（LL，RL，LR，RL）旋转，然后变色</p><p><span class="exturl"><a class="exturl__link"   href="https://www.bilibili.com/video/BV1Xm421x7Lg/?spm_id_from=333.337.search-card.all.click&vd_source=07ce431f0897d40efe75d8ff3761e5f6" >红黑树 - 定义, 插入, 构建_哔哩哔哩_bilibili</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
    
    
      
      
    <summary type="html">
        &lt;h2 id=&quot;红黑树&quot;   &gt;
          &lt;a href=&quot;#红黑树&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;a href=&quot;#红黑树&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>腾讯面试准备</title>
    <link href="http://example.com/2025/09/10/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
    <id>http://example.com/2025/09/10/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/</id>
    <published>2025-09-10T00:24:18.000Z</published>
    <updated>2025-09-10T12:19:36.933Z</updated>
    
    <content type="html"><![CDATA[        <h2 id="算法和数据结构"   >          <a href="#算法和数据结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#算法和数据结构" class="headerlink" title="算法和数据结构"></a>算法和数据结构</h2>      <p>刷题</p>        <h2 id="C-的stl和新特性"   >          <a href="#C-的stl和新特性" class="heading-link"><i class="fas fa-link"></i></a><a href="#C-的stl和新特性" class="headerlink" title="C++的stl和新特性"></a>C++的stl和新特性</h2>              <h4 id="常量指针和指针常量"   >          <a href="#常量指针和指针常量" class="heading-link"><i class="fas fa-link"></i></a><a href="#常量指针和指针常量" class="headerlink" title="常量指针和指针常量"></a>常量指针和指针常量</h4>      <figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *p = &amp;a;<span class="comment">//常量指针，指针指向常量，指针指向的变量不能通过指针修改，但是指针指向的值可以改变</span></span><br></pre></td></tr></table></div></figure><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="type">const</span> p = &amp;a;<span class="comment">//指针常量，是一个常量，不能改变指向的对象（地址），但是可以改变地址的内容</span></span><br></pre></td></tr></table></div></figure>        <h4 id="野指针和悬浮指针"   >          <a href="#野指针和悬浮指针" class="heading-link"><i class="fas fa-link"></i></a><a href="#野指针和悬浮指针" class="headerlink" title="野指针和悬浮指针"></a>野指针和悬浮指针</h4>      <p>野指针是指向已经被释放或者⽆效的内存地址的指针</p><p>悬浮指针是指向已经被销毁的对象的引⽤</p><p>区别就是一个是指针一个是引用</p>        <h2 id="网络编程"   >          <a href="#网络编程" class="heading-link"><i class="fas fa-link"></i></a><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2>              <h4 id="网络编程的基本流程"   >          <a href="#网络编程的基本流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#网络编程的基本流程" class="headerlink" title="网络编程的基本流程"></a>网络编程的基本流程</h4>              <h4 id="1-服务端代码流程"   >          <a href="#1-服务端代码流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-服务端代码流程" class="headerlink" title="(1) 服务端代码流程"></a><strong>(1) 服务端代码流程</strong></h4>      <figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="built_in">socket</span>()             <span class="comment">// 创建一个套接字</span></span><br><span class="line"><span class="number">2.</span> <span class="built_in">bind</span>()               <span class="comment">// 将套接字与特定 IP 地址和端口绑定</span></span><br><span class="line"><span class="number">3.</span> <span class="built_in">listen</span>()             <span class="comment">// 开启监听，等待客户端连接</span></span><br><span class="line"><span class="number">4.</span> <span class="built_in">accept</span>()             <span class="comment">// 相应客户端的连接请求，接受新的连接</span></span><br><span class="line"><span class="number">5.</span> <span class="built_in">send</span>()/<span class="built_in">recv</span>()       <span class="comment">// 用于和客户端通信（读取请求或者写入响应</span></span><br><span class="line"><span class="number">6.</span> <span class="built_in">close</span>()              <span class="comment">// 关闭连接</span></span><br></pre></td></tr></table></div></figure>        <h4 id="2-客户端代码流程"   >          <a href="#2-客户端代码流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-客户端代码流程" class="headerlink" title="(2) 客户端代码流程"></a><strong>(2) 客户端代码流程</strong></h4>      <figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="built_in">socket</span>()             <span class="comment">// 创建一个套接字</span></span><br><span class="line"><span class="number">2.</span> <span class="built_in">connect</span>()            <span class="comment">// 连接到服务端指定的 IP 地址和端口</span></span><br><span class="line"><span class="number">3.</span> <span class="built_in">send</span>()/<span class="built_in">recv</span>()       <span class="comment">// 用于发送请求或读取服务端的响应</span></span><br><span class="line"><span class="number">4.</span> <span class="built_in">close</span>()              <span class="comment">// 关闭连接</span></span><br></pre></td></tr></table></div></figure>        <h2 id="调试命令，gdb-vscode"   >          <a href="#调试命令，gdb-vscode" class="heading-link"><i class="fas fa-link"></i></a><a href="#调试命令，gdb-vscode" class="headerlink" title="调试命令，gdb&#x2F;vscode"></a>调试命令，gdb&#x2F;vscode</h2>              <h2 id="额外：linux操作系统的内存管理，文件系统，进程和线程调度"   >          <a href="#额外：linux操作系统的内存管理，文件系统，进程和线程调度" class="heading-link"><i class="fas fa-link"></i></a><a href="#额外：linux操作系统的内存管理，文件系统，进程和线程调度" class="headerlink" title="额外：linux操作系统的内存管理，文件系统，进程和线程调度"></a>额外：linux操作系统的内存管理，文件系统，进程和线程调度</h2>      <p>进程间的通信机制：信号量，条件变量，生产者消费者</p><p>异步通信：回调函数，生产者消费者（promise-future和消息队列）</p><p>同步通信：阻塞式调用，文件或网络操作</p>        <h2 id="引用和指针的区别"   >          <a href="#引用和指针的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#引用和指针的区别" class="headerlink" title="引用和指针的区别"></a>引用和指针的区别</h2>              <h3 id="1-什么是引用和指针？"   >          <a href="#1-什么是引用和指针？" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-什么是引用和指针？" class="headerlink" title="1. 什么是引用和指针？"></a><strong>1. 什么是引用和指针？</strong></h3>      <ol><li><p><strong>引用（Reference）</strong>：</p><ul><li>引用是某个变量的别名，声明后与该变量绑定在一起，不能再绑定其他变量。</li><li>本质上是一个语法糖，用更简洁的方式访问变量。</li></ul><p>示例代码：</p><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = a;  <span class="comment">// 引用 `ref` 绑定到变量 `a`</span></span><br><span class="line">ref = <span class="number">20</span>;      <span class="comment">// 实际修改的是 `a`</span></span><br></pre></td></tr></table></div></figure></li><li><p><strong>指针（Pointer）</strong>：</p><ul><li>指针是存储变量地址的一种特殊变量，通过指针可以间接访问或操作存储在内存地址上的值。</li><li>指针可以指向不同的变量或内存单元。</li></ul><p>示例代码：</p><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* ptr = &amp;a;  <span class="comment">// 指针 ptr 存储变量 a 的地址</span></span><br><span class="line">*ptr = <span class="number">20</span>;      <span class="comment">// 实际修改的是 a</span></span><br></pre></td></tr></table></div></figure></li></ol><hr>        <h3 id="2-引用和指针的区别"   >          <a href="#2-引用和指针的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-引用和指针的区别" class="headerlink" title="2. 引用和指针的区别"></a><strong>2. 引用和指针的区别</strong></h3>      <div class="table-container"><table><thead><tr><th>特性</th><th>引用</th><th>指针</th></tr></thead><tbody><tr><td><strong>定义方式</strong></td><td>使用 <code>&amp;</code> 声明</td><td>使用 <code>*</code> 声明</td></tr><tr><td><strong>是否可以为空</strong></td><td>引用必须绑定到变量</td><td>指针可以是 <code>nullptr</code> 或空</td></tr><tr><td><strong>绑定后是否可以更改</strong></td><td>一旦绑定不能更改</td><td>指针可以重新指向其他变量</td></tr><tr><td><strong>语法</strong></td><td>直接使用，无需解引用符号</td><td>需要用 <code>*</code> 解引用</td></tr><tr><td><strong>内存布局</strong></td><td>编译器实现（可能是指针）</td><td>明确存储变量地址</td></tr><tr><td><strong>需要初始化</strong></td><td>声明时必须初始化</td><td>可以声明后再初始化</td></tr><tr><td><strong>别名关系</strong></td><td>是原变量的别名</td><td>独立的变量</td></tr><tr><td><strong>运算</strong></td><td>不支持运算</td><td>可以进行加减运算</td></tr><tr><td><strong>灵活性</strong></td><td>较低，限定性强</td><td>较高，可以动态分配内存</td></tr></tbody></table></div><hr>        <h3 id="3-区别详解"   >          <a href="#3-区别详解" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-区别详解" class="headerlink" title="3. 区别详解"></a><strong>3. 区别详解</strong></h3>              <h4 id="1-是否必须初始化"   >          <a href="#1-是否必须初始化" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-是否必须初始化" class="headerlink" title="(1) 是否必须初始化"></a><strong>(1) 是否必须初始化</strong></h4>      <ul><li><p><strong>引用：</strong></p><ul><li>引用在声明的时候必须初始化，否则无法通过编译。</li></ul><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref;  <span class="comment">// 编译错误，引用必须绑定变量</span></span><br></pre></td></tr></table></div></figure></li><li><p><strong>指针：</strong></p><ul><li>指针声明后可以不初始化，但最好将其初始化（例如初始化为 <code>nullptr</code>），否则容易产生未定义行为。</li></ul><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr;  <span class="comment">// 未初始化，非法操作可能导致未定义行为</span></span><br><span class="line"><span class="type">int</span>* ptr = <span class="literal">nullptr</span>;  <span class="comment">// 推荐初始化为 nullptr</span></span><br></pre></td></tr></table></div></figure></li></ul>        <h4 id="2-是否可以为空"   >          <a href="#2-是否可以为空" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-是否可以为空" class="headerlink" title="(2) 是否可以为空"></a><strong>(2) 是否可以为空</strong></h4>      <ul><li><p><strong>引用：</strong></p><ul><li>引用不能指向空（<code>nullptr</code>），它必须始终绑定到有效的变量。</li></ul></li><li><p><strong>指针：</strong></p><ul><li>指针可以指向空内存区域（<code>nullptr</code>），表示它当前没有指向任何变量。</li></ul><p> 示例：<br> <figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="literal">nullptr</span>;  <span class="comment">// 合法</span></span><br><span class="line"><span class="type">int</span>&amp; ref = <span class="literal">nullptr</span>;  <span class="comment">// 编译错误，引用必须绑定到变量</span></span><br></pre></td></tr></table></div></figure></p></li></ul>        <h4 id="3-绑定后是否可以更改"   >          <a href="#3-绑定后是否可以更改" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-绑定后是否可以更改" class="headerlink" title="(3) 绑定后是否可以更改"></a><strong>(3) 绑定后是否可以更改</strong></h4>      <ul><li><p><strong>引用：</strong></p><ul><li>引用一旦绑定到变量，就不能再绑定到其他变量，引用始终是它所绑定变量的别名。</li></ul><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = a;  <span class="comment">// ref 绑定到 a</span></span><br><span class="line">ref = b;       <span class="comment">// 修改的是 a 的值，而不是重新绑定到 b</span></span><br></pre></td></tr></table></div></figure></li><li><p><strong>指针：</strong></p><ul><li>指针可以随时更改指向，可以指向其他变量或内存单元。</li></ul><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span>* ptr = &amp;a;  <span class="comment">// ptr 指向 a</span></span><br><span class="line">ptr = &amp;b;       <span class="comment">// ptr 改为指向 b</span></span><br></pre></td></tr></table></div></figure></li></ul>        <h4 id="4-使用上的差异"   >          <a href="#4-使用上的差异" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-使用上的差异" class="headerlink" title="(4) 使用上的差异"></a><strong>(4) 使用上的差异</strong></h4>      <ul><li><p><strong>引用：</strong></p><ul><li>如果将一变量赋值给引用，引用直接操作变量本身。</li></ul><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = a;</span><br><span class="line">ref = <span class="number">20</span>;  <span class="comment">// 改变的是 a，a 的值变为 20</span></span><br></pre></td></tr></table></div></figure></li><li><p><strong>指针：</strong></p><ul><li>要改变指针指向变量的值，需要解引用（<code>*</code>）。</li></ul><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span>* ptr = &amp;a;  <span class="comment">// 指针指向 a</span></span><br><span class="line">*ptr = <span class="number">30</span>;      <span class="comment">// 修改 a 的值为 30</span></span><br><span class="line">ptr = &amp;b;       <span class="comment">// 改为指向 b</span></span><br></pre></td></tr></table></div></figure></li></ul>        <h4 id="5-运算能力"   >          <a href="#5-运算能力" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-运算能力" class="headerlink" title="(5) 运算能力"></a><strong>(5) 运算能力</strong></h4>      <ul><li><strong>引用：</strong><ul><li>引用不支持指针的算术运算，例如加减法。</li></ul></li><li><strong>指针：</strong><ul><li>指针可以进行算术运算，例如指针递增&#x2F;递减，用于访问数组元素。</li></ul><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span>* ptr = arr;   <span class="comment">// 指向数组的第一个元素</span></span><br><span class="line">ptr++;            <span class="comment">// 指向下一个元素</span></span><br></pre></td></tr></table></div></figure></li></ul>        <h4 id="6-内存特性"   >          <a href="#6-内存特性" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-内存特性" class="headerlink" title="(6) 内存特性"></a><strong>(6) 内存特性</strong></h4>      <ul><li>引用在编译器实现中，可能会转换为指针，但它对开发者是透明的。</li><li>指针本质上是一个变量，存储的是某个地址，并且占用内存。</li></ul><hr>        <h3 id="4-引用与指针的适用场景"   >          <a href="#4-引用与指针的适用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-引用与指针的适用场景" class="headerlink" title="4. 引用与指针的适用场景"></a><strong>4. 引用与指针的适用场景</strong></h3>              <h4 id="1-适用引用"   >          <a href="#1-适用引用" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-适用引用" class="headerlink" title="(1) 适用引用"></a><strong>(1) 适用引用</strong></h4>      <ol><li><p><strong>函数参数传递</strong>：</p><ul><li>使用引用避免拷贝实参，提高性能。</li><li>常用于不需要修改参数的地方（<code>const</code> 引用）。</li></ul><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li><li><p><strong>返回值</strong>：</p><ul><li>返回引用允许函数直接返回变量本身，而不是拷贝。</li></ul><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">getValue</span><span class="params">(<span class="type">int</span>&amp; a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li><li><p><strong>别名</strong>：</p><ul><li>为变量创建更简化的别名。</li></ul><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span>&amp; alias = a;  <span class="comment">// alias 是 a 的别名</span></span><br></pre></td></tr></table></div></figure></li></ol>        <h4 id="2-适用指针"   >          <a href="#2-适用指针" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-适用指针" class="headerlink" title="(2) 适用指针"></a><strong>(2) 适用指针</strong></h4>      <ol><li><p><strong>动态内存管理</strong>：</p><ul><li>使用指针分配和释放动态内存。</li></ul><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">delete</span> ptr;  <span class="comment">// 手动释放内存</span></span><br></pre></td></tr></table></div></figure></li><li><p><strong>数组与迭代</strong>：</p><ul><li>指针常用来访问数组元素。</li></ul><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>* ptr = arr; ptr &lt; arr + <span class="number">3</span>; ++ptr) &#123;</span><br><span class="line">    std::cout &lt;&lt; *ptr &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li><li><p><strong>数据结构</strong>：</p><ul><li>指针是数据结构（如链表、树）的核心基础。</li></ul><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure></li><li><p><strong>需要动态改变指向时</strong>：</p><ul><li>指针可以灵活地改变指向，适合需要频繁切换指向的场景。</li></ul></li></ol><hr>        <h3 id="5-总结对比"   >          <a href="#5-总结对比" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-总结对比" class="headerlink" title="5. 总结对比"></a><strong>5. 总结对比</strong></h3>      <div class="table-container"><table><thead><tr><th>特征</th><th>引用</th><th>指针</th></tr></thead><tbody><tr><td><strong>需要初始化</strong></td><td>必须初始化</td><td>可以先声明后初始化</td></tr><tr><td><strong>是否可以为空</strong></td><td>不可以为空</td><td>可以是空指针（<code>nullptr</code>）</td></tr><tr><td><strong>绑定是否可更改</strong></td><td>绑定后不可更改</td><td>可通过重新赋值更改指向</td></tr><tr><td><strong>语法复杂度</strong></td><td>更简单</td><td>更复杂，需要使用 <code>*</code> 号</td></tr><tr><td><strong>灵活性</strong></td><td>受限</td><td>更灵活</td></tr><tr><td><strong>常见场景</strong></td><td>函数传参、别名</td><td>动态内存、复杂结构</td></tr></tbody></table></div><p>引用更简单、更安全，适合大多数普通变量操作；指针更灵活，适合动态内存和复杂结构的场景。在实际开发中，应根据场景和需求选择适合的工具。</p>]]></content>
    
    
      
      
    <summary type="html">
        &lt;h2 id=&quot;算法和数据结构&quot;   &gt;
          &lt;a href=&quot;#算法和数据结构&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;a href=&quot;#算法和数据结构&quot; class=&quot;hea</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>金山C++研发实习生面试准备</title>
    <link href="http://example.com/2025/09/10/%E9%87%91%E5%B1%B1C++%E7%A0%94%E5%8F%91%E5%AE%9E%E4%B9%A0%E7%94%9F%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
    <id>http://example.com/2025/09/10/%E9%87%91%E5%B1%B1C++%E7%A0%94%E5%8F%91%E5%AE%9E%E4%B9%A0%E7%94%9F%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/</id>
    <published>2025-09-10T00:24:18.000Z</published>
    <updated>2025-09-10T12:19:36.934Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="金山C-研发实习生面试准备"   >          <a href="#金山C-研发实习生面试准备" class="heading-link"><i class="fas fa-link"></i></a><a href="#金山C-研发实习生面试准备" class="headerlink" title="金山C++研发实习生面试准备"></a>金山C++研发实习生面试准备</h1>      <p>1.自我介绍<br>2.拷打项目</p><p>3.拷打八股：</p><p>4.多态的实现</p>        <h3 id="5-静态多态和动态多态"   >          <a href="#5-静态多态和动态多态" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-静态多态和动态多态" class="headerlink" title="5.静态多态和动态多态"></a>5.静态多态和动态多态</h3>      <p>静态多态是指在编译时多态，动态多态是指运行时多态</p><p>静态多态有函数重载（函数名相同，参数不同，返回值相同或不同），函数模板</p><p>动态多态（动态绑定）：即运行时的多态，在程序执行期间(非编译期)判断所引用对象的实际类型，根据其实际类型调用相应的方法。</p>        <h3 id="6-动态多态怎么实现的"   >          <a href="#6-动态多态怎么实现的" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-动态多态怎么实现的" class="headerlink" title="6.动态多态怎么实现的"></a>6.动态多态怎么实现的</h3>              <h3 id="动态多态"   >          <a href="#动态多态" class="heading-link"><i class="fas fa-link"></i></a><a href="#动态多态" class="headerlink" title="动态多态"></a>动态多态</h3>      <p>通过每个类的虚函数和动态绑定</p><p>派生类实现动态绑定</p><ul><li>先拷贝基类的虚函数表</li><li>如果派生类重写了基类的某个虚函数，就用派生类的虚函数替换虚表同位置的基类虚函数</li><li>跟上派生类自己的虚函数</li></ul><p>指向基类的指针或引用</p><p>动态多态需要通过指向基类的 <strong>指针或引用</strong> 操作派生类对象。如果直接操作派生对象，则是静态绑定，而非动态绑定。</p>        <h3 id="7-介绍一下虚函数表和虚指针"   >          <a href="#7-介绍一下虚函数表和虚指针" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-介绍一下虚函数表和虚指针" class="headerlink" title="7.介绍一下虚函数表和虚指针"></a>7.介绍一下虚函数表和虚指针</h3>      <p>虚函数表和虚指针是由<strong>编译器</strong>生成并使用的，它们是实现 <strong>动态绑定</strong> 和运行时多态的核心。</p><p>虚函数表是一种由编译器生成的 <strong>隐藏数据结构</strong>，它是一个函数指针数组，用来存储类中所有虚函数的地址。简单来说，虚函数表就是一个指针数组，每个元素指向一个虚函数的具体实现。</p><p>虚指针是一个 <strong>隐藏成员变量</strong>，存在于每个包含虚函数的类的对象中。虚指针用于指向当前对象所属类的虚函数表。</p>        <h3 id="8-说一下构造函数和析构函数在父类和子类的执行顺序"   >          <a href="#8-说一下构造函数和析构函数在父类和子类的执行顺序" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-说一下构造函数和析构函数在父类和子类的执行顺序" class="headerlink" title="8.说一下构造函数和析构函数在父类和子类的执行顺序"></a>8.说一下构造函数和析构函数在父类和子类的执行顺序</h3>      <ul><li><strong>构造函数顺序</strong>：<br><strong>父类构造函数</strong> → <strong>成员对象的构造函数</strong> → <strong>子类构造函数</strong></li><li><strong>析构函数顺序</strong>：<br><strong>子类析构函数</strong> → <strong>成员对象的析构函数</strong> → <strong>父类析构函数</strong></li></ul>        <h3 id="9-析构函数的作用"   >          <a href="#9-析构函数的作用" class="heading-link"><i class="fas fa-link"></i></a><a href="#9-析构函数的作用" class="headerlink" title="9.析构函数的作用"></a>9.析构函数的作用</h3>      <p>析构函数用于释放对象占用的资源（如内存、文件句柄等），在对象生命周期结束时自动调用，确保资源不会泄漏。</p>        <h3 id="10-为什么析构函数通常定义为虚函数；不调用析构函数会怎样"   >          <a href="#10-为什么析构函数通常定义为虚函数；不调用析构函数会怎样" class="heading-link"><i class="fas fa-link"></i></a><a href="#10-为什么析构函数通常定义为虚函数；不调用析构函数会怎样" class="headerlink" title="10.为什么析构函数通常定义为虚函数；不调用析构函数会怎样"></a>10.为什么析构函数通常定义为虚函数；不调用析构函数会怎样</h3>      <ul><li><strong>原因</strong>：<br>若父类指针指向子类对象，且父类析构函数非虚，则通过父类指针删除对象时，只会调用父类析构函数，导致子类资源泄漏。</li><li><strong>后果</strong>：<br>不调用析构函数会导致资源泄漏（如内存、文件句柄未释放）。</li></ul>        <h3 id="11-结构体为何通常要进行内存对齐；一般是几字节对齐"   >          <a href="#11-结构体为何通常要进行内存对齐；一般是几字节对齐" class="heading-link"><i class="fas fa-link"></i></a><a href="#11-结构体为何通常要进行内存对齐；一般是几字节对齐" class="headerlink" title="11.结构体为何通常要进行内存对齐；一般是几字节对齐"></a>11.结构体为何通常要进行内存对齐；一般是几字节对齐</h3>      <p>为了提高访问效率，为了时内存命中访问效率更高</p><p><strong>对齐原则</strong></p><p>结构体的内存对齐通常遵循以下原则：</p><ol><li>每个成员变量的起始地址必须是其自身大小的整数倍</li><li>结构体本身的大小必须是其最大对齐系数（对齐要求）的整数倍</li></ol>        <h3 id="12-new-delete和malloc-free的区别"   >          <a href="#12-new-delete和malloc-free的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#12-new-delete和malloc-free的区别" class="headerlink" title="12.new&#x2F;delete和malloc&#x2F;free的区别"></a>12.new&#x2F;delete和malloc&#x2F;free的区别</h3>      <div class="table-container"><table><thead><tr><th>特性</th><th><code>new/delete</code></th><th><code>malloc/free</code></th></tr></thead><tbody><tr><td><strong>语言特性支持</strong></td><td>C++ 专有</td><td>C 风格（C 和 C++ 均支持）</td></tr><tr><td><strong>类型安全</strong></td><td>是</td><td>否（需要手动类型转换）</td></tr><tr><td><strong>初始化支持</strong></td><td>自动调用构造函数和析构函数</td><td>不调用，需要手动处理</td></tr><tr><td><strong>异常处理</strong></td><td>内存分配失败抛出 <code>std::bad_alloc</code></td><td>内存分配失败返回 <code>NULL</code></td></tr><tr><td><strong>灵活性</strong></td><td>适合对象管理和复杂场景</td><td>适合简单的POD或跨语言</td></tr><tr><td><strong>效率</strong></td><td>稍有额外开销（构造&#x2F;析构函数调用）</td><td>相对高效</td></tr></tbody></table></div><p><strong>什么时候选择哪一个？</strong></p><p><strong>使用 <code>new/delete</code>：</strong></p><ul><li>在C++程序中，需要创建具有构造函数和析构函数的复杂对象。</li><li>希望利用类型安全和异常处理机制，提高代码的健壮性。</li><li>更偏向于面向对象的编程风格。</li></ul><p><strong>使用 <code>malloc/free</code>：</strong></p><ul><li>在C语言程序中，或者需要与 C 的库&#x2F;代码接口。</li><li>需要跨语言兼容时（如 C 和 C++ 混合开发）。</li><li>只操作简单的内存（非对象）时，比如使用裸内存块或数组。</li></ul><p><strong>总结</strong></p><ol><li><code>new</code> 和 <code>delete</code> 是C++中的语法糖，功能更强大，更贴合现代编程需求。</li><li><code>malloc</code> 和 <code>free</code> 是底层内存管理工具，适合裸内存分配。</li><li>在C++开发中，通常推荐优先使用 <code>new</code> 和 <code>delete</code>，除非有特殊需要才选择 <code>malloc</code> 和 <code>free</code>。</li></ol>        <h3 id="13-什么情况用mmap"   >          <a href="#13-什么情况用mmap" class="heading-link"><i class="fas fa-link"></i></a><a href="#13-什么情况用mmap" class="headerlink" title="13.什么情况用mmap()"></a>13.什么情况用mmap()</h3>      <p><code>mmap()</code> 是一个 POSIX 标准的内存映射函数，通常用于将文件或设备映射到进程虚拟内存空间中，使得我们可以通过内存访问文件内容，大大提高了 I&#x2F;O 的效率。它的使用场景主要集中在对文件的高效访问、大文件处理、共享内存以及特殊的内存管理需求等。以下是 <code>mmap()</code> 的典型使用情况、优缺点以及示例解释。</p><p>1.高效文件访问，减少内核态和用户态之间的拷贝开销</p><p>2.处理大文件，将文件内容按需映射到虚拟内存中</p><p>3.共享内存（进程间通信）</p><ul><li><code>mmap()</code> 支持使用 <code>MAP_SHARED</code> 标志创建共享内存，多个进程可以操作同一内存区域进行通信。</li><li>使用共享内存比使用消息队列、管道等传统 IPC 机制有更高的效率。</li></ul><p>4.文件修改或写入（内存作为缓冲区）适用于需要高效更新大文件的场景</p><p>5.实现内存映射I&#x2F;O</p><p>6.异步I&#x2F;O和并行处理</p><p>使用 <code>mmap()</code> 的场景主要是权衡性能与开销，以下是具体选择标准：</p><ol><li><strong>适合用 <code>mmap()</code> 的场景</strong>：<ul><li>需要频繁随机访问大文件。</li><li>文件的内容按需加载，不需要一次性加载到内存。</li><li>多进程需要共享文件或内存。</li><li>操作设备文件或硬件寄存器。</li><li>文件访问频繁，且希望减少用户态与内核态之间频繁的数据拷贝。</li></ul></li><li><strong>不太适合用 <code>mmap()</code> 的场景</strong>：<ul><li>操作小文件，或者一次性读取整个文件，不需要复杂的随机访问。</li><li>文件处理逻辑非常简单，而 <code>mmap()</code> 的复用性和管理开销反而适得其反。</li><li>跨平台兼容需求非常高的场景。</li></ul></li></ol>        <h3 id="14-动态链接库用的brk-还是mmap"   >          <a href="#14-动态链接库用的brk-还是mmap" class="heading-link"><i class="fas fa-link"></i></a><a href="#14-动态链接库用的brk-还是mmap" class="headerlink" title="14.动态链接库用的brk()还是mmap()"></a>14.动态链接库用的brk()还是mmap()</h3>      <div class="table-container"><table><thead><tr><th>特性</th><th><code>brk()</code></th><th><code>mmap()</code></th></tr></thead><tbody><tr><td><strong>内存范围</strong></td><td>紧跟数据段末尾</td><td>任意空闲的虚拟地址空间</td></tr><tr><td><strong>按需加载</strong></td><td>不支持</td><td>支持</td></tr><tr><td><strong>分页分配</strong></td><td>不支持</td><td>支持，以页为单位分配和管理</td></tr><tr><td><strong>碎片问题</strong></td><td>容易引发堆碎片</td><td>避免堆碎片，内存管理灵活</td></tr><tr><td><strong>共享内存</strong></td><td>不支持</td><td>支持共享内存（<code>MAP_SHARED</code> 标志）</td></tr><tr><td><strong>动态链接库加载</strong></td><td>不适用</td><td>是动态链接库的默认选择</td></tr></tbody></table></div><p>因此，动态链接库的加载和运行使用 <code>mmap()</code> 是最佳选择，它为动态链接库的按需加载、多进程共享、独立管理以及性能优化提供了完美支持。同时，<code>brk()</code> 由于其限制，已不适用于动态库加载。</p>        <h3 id="15-动态链接和静态链接的区别"   >          <a href="#15-动态链接和静态链接的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#15-动态链接和静态链接的区别" class="headerlink" title="15.动态链接和静态链接的区别"></a>15.动态链接和静态链接的区别</h3>      <div class="table-container"><table><thead><tr><th>特性</th><th>静态链接</th><th>动态链接</th></tr></thead><tbody><tr><td><strong>生成的可执行文件体积</strong></td><td>较大，库代码直接嵌入</td><td>较小，仅包含对动态库的引用</td></tr><tr><td><strong>运行时依赖</strong></td><td>不依赖外部库，所有代码都在一个文件中</td><td>依赖外部库，运行时需要动态加载</td></tr><tr><td><strong>运行时性能</strong></td><td>加载速度快，无需加载外部库</td><td>加载速度稍慢，需要动态加载符号解析</td></tr><tr><td><strong>内存使用</strong></td><td>每个程序独立占用一份库的内存</td><td>多个程序共享同一个库，节省内存</td></tr><tr><td><strong>更新方式</strong></td><td>更新程序需要重新编译并链接静态库</td><td>可以通过更新库文件，无需重新编译程序</td></tr><tr><td><strong>跨平台兼容性</strong></td><td>静态库只与编译平台相关，适合封装依赖</td><td>动态库可能与运行时环境、平台设置相关</td></tr><tr><td><strong>调试难度</strong></td><td>相对简单，因为库已集成进可执行文件</td><td>调试更复杂，可能需要检查多个动态库</td></tr><tr><td><strong>符号冲突问题</strong></td><td>不会出现符号冲突，代码已固定</td><td>有可能发生符号冲突，需要小心处理</td></tr><tr><td><strong>磁盘存储</strong></td><td>每个可执行文件都包含完整的库代码</td><td>动态库存储独立，节省磁盘空间</td></tr><tr><td><strong>维护与分发</strong></td><td>更新程序和库需要重新分发完整的可执行文件</td><td>库文件可以单独更新，减少分发工作量</td></tr></tbody></table></div>        <h3 id="16-红黑树特性；有哪些应用"   >          <a href="#16-红黑树特性；有哪些应用" class="heading-link"><i class="fas fa-link"></i></a><a href="#16-红黑树特性；有哪些应用" class="headerlink" title="16.红黑树特性；有哪些应用"></a>16.红黑树特性；有哪些应用</h3>      <ul><li><strong>特性</strong>：<ol><li>每个节点是红或黑。</li><li>根节点和叶子节点（NIL）是黑。</li><li>红节点的子节点必为黑。</li><li>从任一节点到其叶子节点的路径包含相同数量的黑节点。</li></ol></li><li><strong>应用</strong>：<br>C++ STL <code>map</code>&#x2F;<code>set</code>、Java <code>TreeMap</code>、Linux 内核调度器等。</li></ul>        <h3 id="17-死锁的必要条件有哪些"   >          <a href="#17-死锁的必要条件有哪些" class="heading-link"><i class="fas fa-link"></i></a><a href="#17-死锁的必要条件有哪些" class="headerlink" title="17.死锁的必要条件有哪些"></a>17.死锁的必要条件有哪些</h3>      <ol><li><strong>互斥</strong>：资源只能被一个进程占用。</li><li><strong>持有并等待</strong>：进程持有资源并等待其他资源。</li><li><strong>不可抢占</strong>：资源只能由持有者主动释放。</li><li><strong>循环等待</strong>：存在进程资源的环形等待链。</li></ol>        <h3 id="18-线程安全实现方式"   >          <a href="#18-线程安全实现方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#18-线程安全实现方式" class="headerlink" title="18.线程安全实现方式"></a>18.线程安全实现方式</h3>      <ol><li><strong>互斥锁（Mutex）</strong>：保证临界区代码原子性。</li><li><strong>原子操作（Atomic）</strong>：通过硬件支持的原子指令（如 CAS）。</li><li><strong>无锁编程</strong>：如使用无锁数据结构。</li><li><strong>线程局部存储（TLS）</strong>：避免共享数据。</li><li><strong>读写锁（Read-Write Lock）</strong>：区分读&#x2F;写操作。</li><li><strong>条件变量（Condition Variable）</strong>：线程间同步。</li></ol>]]></content>
    
    
      
      
    <summary type="html">
        &lt;h1 id=&quot;金山C-研发实习生面试准备&quot;   &gt;
          &lt;a href=&quot;#金山C-研发实习生面试准备&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;a href=&quot;#金山C-研发实</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Docker Desktop 修改安装位置-CSDN博客</title>
    <link href="http://example.com/2025/09/10/Docker%20Desktop%20%E4%BF%AE%E6%94%B9%E5%AE%89%E8%A3%85%E4%BD%8D%E7%BD%AE-CSDN%E5%8D%9A%E5%AE%A2/"/>
    <id>http://example.com/2025/09/10/Docker%20Desktop%20%E4%BF%AE%E6%94%B9%E5%AE%89%E8%A3%85%E4%BD%8D%E7%BD%AE-CSDN%E5%8D%9A%E5%AE%A2/</id>
    <published>2025-09-10T00:23:56.000Z</published>
    <updated>2025-09-10T12:19:36.933Z</updated>
    
    <content type="html"><![CDATA[<p><span class="exturl"><a class="exturl__link"   href="https://blog.csdn.net/cn_ljr/article/details/132047516" >Win11 安装 Docker Desktop 和 WSL2 并进行安装位置迁移_windows 11 wsl 修改安装位置-CSDN博客</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>迁移docker</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;span class=&quot;exturl&quot;&gt;&lt;a class=&quot;exturl__link&quot;   href=&quot;https://blog.csdn.net/cn_ljr/article/details/132047516&quot; &gt;Win11 安装 Docker Desktop 和 W</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>WSl从本机复制文件到wsl</title>
    <link href="http://example.com/2025/09/10/WSl%E4%BB%8E%E6%9C%AC%E6%9C%BA%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E5%88%B0wsl/"/>
    <id>http://example.com/2025/09/10/WSl%E4%BB%8E%E6%9C%AC%E6%9C%BA%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E5%88%B0wsl/</id>
    <published>2025-09-10T00:23:56.000Z</published>
    <updated>2025-09-10T12:19:36.933Z</updated>
    
    <content type="html"><![CDATA[        <h2 id="WSl从本机复制文件到wsl"   >          <a href="#WSl从本机复制文件到wsl" class="heading-link"><i class="fas fa-link"></i></a><a href="#WSl从本机复制文件到wsl" class="headerlink" title="WSl从本机复制文件到wsl"></a>WSl从本机复制文件到wsl</h2>      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">ls</span> /mnt/*</span><br></pre></td></tr></table></div></figure>]]></content>
    
    
      
      
    <summary type="html">
        &lt;h2 id=&quot;WSl从本机复制文件到wsl&quot;   &gt;
          &lt;a href=&quot;#WSl从本机复制文件到wsl&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;a href=&quot;#WSl从本</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>docker上传文件至容器</title>
    <link href="http://example.com/2025/09/10/docker%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E8%87%B3%E5%AE%B9%E5%99%A8/"/>
    <id>http://example.com/2025/09/10/docker%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E8%87%B3%E5%AE%B9%E5%99%A8/</id>
    <published>2025-09-10T00:23:56.000Z</published>
    <updated>2025-09-10T12:19:36.933Z</updated>
    
    <content type="html"><![CDATA[<p>docker上传文件至容器</p>        <h4 id="拿到容器ID"   >          <a href="#拿到容器ID" class="heading-link"><i class="fas fa-link"></i></a><a href="#拿到容器ID" class="headerlink" title="拿到容器ID"></a>拿到容器ID</h4>      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></div></figure>        <h4 id="将本地文件上传到容器的指定目录中"   >          <a href="#将本地文件上传到容器的指定目录中" class="heading-link"><i class="fas fa-link"></i></a><a href="#将本地文件上传到容器的指定目录中" class="headerlink" title="将本地文件上传到容器的指定目录中"></a>将本地文件上传到容器的指定目录中</h4>      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> 本地文件路径 ID全称:容器路径</span><br></pre></td></tr></table></div></figure><figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> /home/stydent/EdgeGPT /usr/local/lib/python3.11/site-packages</span><br></pre></td></tr></table></div></figure><figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker <span class="built_in">cp</span> fbf56805d23a:/usr/local/lib/python3.11/site-packages ./site-packages</span><br></pre></td></tr></table></div></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;docker上传文件至容器&lt;/p&gt;

        &lt;h4 id=&quot;拿到容器ID&quot;   &gt;
          &lt;a href=&quot;#拿到容器ID&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>docker遇到的问题</title>
    <link href="http://example.com/2025/09/10/docker%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2025/09/10/docker%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2025-09-10T00:23:56.000Z</published>
    <updated>2025-09-10T12:19:36.933Z</updated>
    
    <content type="html"><![CDATA[<p>拉取镜像失败是网络问题，先看网络</p><p>docker命令报错error during connect: Get <span class="exturl"><a class="exturl__link"   href="http://2f2f.2fpipe2fdocker_engine/v1.36/containers/json" >http://2F2F.2Fpipe2Fdocker_engine/v1.36/containers/json</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>: open&#x2F;&#x2F;.</p><p>在清理docker时遇到</p><figure class="highlight powershell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker system prune</span><br></pre></td></tr></table></div></figure><p>原因是docker无法挂载到wsl上</p><p>因为刚刚执行压缩命令占用了vhdx文件，不能把docker文件关联上</p><p>关机重启就好</p><figure class="highlight powershell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> docker system prune</span><br><span class="line">WARNING! This will remove:</span><br><span class="line">  - all stopped containers</span><br><span class="line">  - all networks not used by at least one container</span><br><span class="line">  - all dangling images</span><br><span class="line">  - unused build cache</span><br><span class="line"></span><br><span class="line">Are you sure you want to <span class="keyword">continue</span>? [<span class="type">y</span>/<span class="type">N</span>] y</span><br><span class="line">Total reclaimed space: <span class="number">0</span>B</span><br></pre></td></tr></table></div></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;拉取镜像失败是网络问题，先看网络&lt;/p&gt;
&lt;p&gt;docker命令报错error during connect: Get &lt;span class=&quot;exturl&quot;&gt;&lt;a class=&quot;exturl__link&quot;   href=&quot;http://2f2f.2fpipe2fdock</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ngnix实现共享文件</title>
    <link href="http://example.com/2025/09/10/ngnix%E5%AE%9E%E7%8E%B0%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6/"/>
    <id>http://example.com/2025/09/10/ngnix%E5%AE%9E%E7%8E%B0%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6/</id>
    <published>2025-09-10T00:23:56.000Z</published>
    <updated>2025-09-10T12:19:36.933Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="ngnix实现共享文件"   >          <a href="#ngnix实现共享文件" class="heading-link"><i class="fas fa-link"></i></a><a href="#ngnix实现共享文件" class="headerlink" title="ngnix实现共享文件"></a>ngnix实现共享文件</h1>      <p>乱码解决</p><figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server和loaction层都加上</span><br><span class="line">charset utf-8</span><br></pre></td></tr></table></div></figure>        <h3 id="配置-Nginx"   >          <a href="#配置-Nginx" class="heading-link"><i class="fas fa-link"></i></a><a href="#配置-Nginx" class="headerlink" title="配置 Nginx"></a>配置 Nginx</h3>      <figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/nginx/sites-enabled/default</span><br></pre></td></tr></table></div></figure>        <h3 id="验证配置"   >          <a href="#验证配置" class="heading-link"><i class="fas fa-link"></i></a><a href="#验证配置" class="headerlink" title="验证配置"></a>验证配置</h3>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx -t</span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf test is successful</span><br></pre></td></tr></table></div></figure><p>这样测试说明 nginx 配置是正确的。</p>        <h3 id="重启启动-nginx-服务"   >          <a href="#重启启动-nginx-服务" class="heading-link"><i class="fas fa-link"></i></a><a href="#重启启动-nginx-服务" class="headerlink" title="重启启动 nginx 服务"></a>重启启动 nginx 服务</h3>      <figure class="highlight crystal"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service nginx restart</span><br></pre></td></tr></table></div></figure><p>权限问题</p><p>要求权限是755才能正常访问</p><figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R 755 xmal/</span><br></pre></td></tr></table></div></figure>]]></content>
    
    
      
      
    <summary type="html">
        &lt;h1 id=&quot;ngnix实现共享文件&quot;   &gt;
          &lt;a href=&quot;#ngnix实现共享文件&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;a href=&quot;#ngnix实现共享文件</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>openvpn</title>
    <link href="http://example.com/2025/09/10/openvpn/"/>
    <id>http://example.com/2025/09/10/openvpn/</id>
    <published>2025-09-10T00:23:56.000Z</published>
    <updated>2025-09-10T12:19:36.933Z</updated>
    
    <content type="html"><![CDATA[<p>openvpn</p><p>下载</p><figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O openvpn.sh https://get.vpnsetup.net/ovpn</span><br></pre></td></tr></table></div></figure><p>安装</p><figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> bash openvpn.sh --auto</span><br></pre></td></tr></table></div></figure><p>启动</p><figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> bash openvpn.sh</span><br></pre></td></tr></table></div></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;openvpn&lt;/p&gt;
&lt;p&gt;下载&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;div class=&quot;table-container&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>system初始化问题</title>
    <link href="http://example.com/2025/09/10/system%E5%88%9D%E5%A7%8B%E5%8C%96%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2025/09/10/system%E5%88%9D%E5%A7%8B%E5%8C%96%E9%97%AE%E9%A2%98/</id>
    <published>2025-09-10T00:23:56.000Z</published>
    <updated>2025-09-10T12:19:36.933Z</updated>
    
    <content type="html"><![CDATA[<p>System has not been booted with systemd as init system (PID 1). Can’t operate.<br>Failed to connect to bus: Host is down</p><p>翻译过来就是：“<span class="exturl"><a class="exturl__link"   href="https://so.csdn.net/so/search?q=%E7%B3%BB%E7%BB%9F&spm=1001.2101.3001.7020" >系统</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>尚未以systemd作为初始系统启动”。</p>        <h3 id="问题分析："   >          <a href="#问题分析：" class="heading-link"><i class="fas fa-link"></i></a><a href="#问题分析：" class="headerlink" title="问题分析："></a>问题分析：</h3>      <p>1）当你尝试使用 systemd 命令来管理 Linux 系统上的服务的时候，之所以会报错，可能因为系统中根本就没有使用 systemd，而是使用的 SysV init (sysvinit)。</p><p>2）如果你是在 windows 中通过 <span class="exturl"><a class="exturl__link"   href="https://so.csdn.net/so/search?q=WSL&spm=1001.2101.3001.7020" >WSL</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 使用的 Ubuntu 或者 Dibian 系统，默认情况下系统使用的是 SysV 而不是 systemd。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;System has not been booted with systemd as init system (PID 1). Can’t operate.&lt;br&gt;Failed to connect to bus: Host is down&lt;/p&gt;
&lt;p&gt;翻译过来就是：“&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>windows安装python2环境</title>
    <link href="http://example.com/2025/09/10/windows%E5%AE%89%E8%A3%85python2%E7%8E%AF%E5%A2%83/"/>
    <id>http://example.com/2025/09/10/windows%E5%AE%89%E8%A3%85python2%E7%8E%AF%E5%A2%83/</id>
    <published>2025-09-10T00:23:56.000Z</published>
    <updated>2025-09-10T12:19:36.933Z</updated>
    
    <content type="html"><![CDATA[        <h4 id="windows安装python2环境"   >          <a href="#windows安装python2环境" class="heading-link"><i class="fas fa-link"></i></a><a href="#windows安装python2环境" class="headerlink" title="windows安装python2环境"></a>windows安装python2环境</h4>      <p><img src="C:/Users/86147/AppData/Roaming/Typora/typora-user-images/image-20240918205426825.png" alt="image-20240918205426825"></p><p>安装在D盘后，不用管最后这个，之后配置环境变量</p><p><img src="C:/Users/86147/AppData/Roaming/Typora/typora-user-images/image-20240918205806490.png" alt="image-20240918205806490"></p><p><img src="C:/Users/86147/AppData/Roaming/Typora/typora-user-images/image-20240918210154534.png" alt="image-20240918210154534"></p><p>把这两个目录添加到环境变量，之后再修改文件夹中python.exe为python2.exe</p>]]></content>
    
    
      
      
    <summary type="html">
        &lt;h4 id=&quot;windows安装python2环境&quot;   &gt;
          &lt;a href=&quot;#windows安装python2环境&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;a href</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>wsl的代理如何与主机共享</title>
    <link href="http://example.com/2025/09/10/wsl%E7%9A%84%E4%BB%A3%E7%90%86%E5%A6%82%E4%BD%95%E4%B8%8E%E4%B8%BB%E6%9C%BA%E5%85%B1%E4%BA%AB/"/>
    <id>http://example.com/2025/09/10/wsl%E7%9A%84%E4%BB%A3%E7%90%86%E5%A6%82%E4%BD%95%E4%B8%8E%E4%B8%BB%E6%9C%BA%E5%85%B1%E4%BA%AB/</id>
    <published>2025-09-10T00:23:56.000Z</published>
    <updated>2025-09-10T12:19:36.933Z</updated>
    
    <content type="html"><![CDATA[<p>wsl的代理如何与主机共享</p><p>需要拉取docker镜像，但是curl无效</p><p>设置配置文件.wslconfig后仍然ping不通</p><p>ping，ping的是ip，用的是icmp协议，在osi七层模型中用的是第三层（网络层）</p><p>其实是curl google.com</p><p>直接得到的就是</p><figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">HTML</span>&gt;</span><span class="tag">&lt;<span class="name">HEAD</span>&gt;</span><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;content-type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html;charset=utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TITLE</span>&gt;</span>301 Moved<span class="tag">&lt;/<span class="name">TITLE</span>&gt;</span><span class="tag">&lt;/<span class="name">HEAD</span>&gt;</span><span class="tag">&lt;<span class="name">BODY</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">H1</span>&gt;</span>301 Moved<span class="tag">&lt;/<span class="name">H1</span>&gt;</span></span><br><span class="line">The document has moved</span><br><span class="line"><span class="tag">&lt;<span class="name">A</span> <span class="attr">HREF</span>=<span class="string">&quot;http://www.google.com/&quot;</span>&gt;</span>here<span class="tag">&lt;/<span class="name">A</span>&gt;</span>.</span><br><span class="line"><span class="tag">&lt;/<span class="name">BODY</span>&gt;</span><span class="tag">&lt;/<span class="name">HTML</span>&gt;</span></span><br></pre></td></tr></table></div></figure><p>用浏览器访问一下就知道了</p><figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://www.google.com.hk/  </span><br></pre></td></tr></table></div></figure><p>这个才是正确的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;wsl的代理如何与主机共享&lt;/p&gt;
&lt;p&gt;需要拉取docker镜像，但是curl无效&lt;/p&gt;
&lt;p&gt;设置配置文件.wslconfig后仍然ping不通&lt;/p&gt;
&lt;p&gt;ping，ping的是ip，用的是icmp协议，在osi七层模型中用的是第三层（网络层）&lt;/p&gt;
&lt;p&gt;其实</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>wsl2安装启动mysql</title>
    <link href="http://example.com/2025/09/10/wsl2%E5%AE%89%E8%A3%85%E5%90%AF%E5%8A%A8mysql/"/>
    <id>http://example.com/2025/09/10/wsl2%E5%AE%89%E8%A3%85%E5%90%AF%E5%8A%A8mysql/</id>
    <published>2025-09-10T00:23:56.000Z</published>
    <updated>2025-09-10T12:19:36.933Z</updated>
    
    <content type="html"><![CDATA[<p><strong>wsl2安装启动mysql</strong></p><p>启动</p><figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> /etc/init.d/mysql start</span><br></pre></td></tr></table></div></figure><p>配置文件</p><figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">cat</span> /etc/mysql/debian.cnf</span><br></pre></td></tr></table></div></figure><p>用户名密码就在这</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">host     = localhost</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>复制到用户名文件夹可以免输入用户名密码</p><figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> /etc/mysql/debian.cnf .my.cnf</span><br></pre></td></tr></table></div></figure><p>要改变文件的所有者为用户</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown cgz .my.cnf</span><br></pre></td></tr></table></div></figure><p>遇到报错</p><figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR 2002 (HY000): Can<span class="string">&#x27;t connect to local MySQL server through socket &#x27;</span>/var/run/mysqld/mysqld.sock<span class="string">&#x27; (2)</span></span><br></pre></td></tr></table></div></figure><p>问题就是没启动</p><p>运行上面的启动命令就行</p><figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root 的密码: 123456</span><br></pre></td></tr></table></div></figure><figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED BY <span class="string">&#x27;123456&#x27;</span>;</span><br></pre></td></tr></table></div></figure><figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER <span class="string">&#x27;mufeng&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;123456&#x27;</span>;</span><br></pre></td></tr></table></div></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;wsl2安装启动mysql&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;启动&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;div class=&quot;table-container&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;p</summary>
      
    
    
    
    
  </entry>
  
</feed>
