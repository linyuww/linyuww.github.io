[{"title":"linux文件系统","url":"/2025/09/10/linux文件系统/","content":"\n## Mysql问题\n\n 说一说事物隔离级别 \n\nSQL标准的事务隔离级别包括：\n\n读未提交，读提交，可重复读，串行化\n\n\n\n 事务的四大特性有哪些？ \n\n原子性，一致性，隔离性，持久性\n\n## Linux系统目录\n\n![目录2](/images/linux_folder.jpeg)"},{"title":"C++11新特性总结","url":"/2025/09/10/C++11新特性总结/","content":"\n# C++11新特性总结\n\n### final关键字\n\n使派生类不可覆盖它所修饰的虚函数\n\n### override描述符\n\n如果派生类在虚函数声明时使用了override描述符，那么该函数必须重载其基类中的同名函数\n\n### 关于左值，右值\n\n`C++`中所有的值都必然属于左值、右值二者之一。左值是指表达式结束后依然存在的*持久化对象*，右值是指表达式结束时就不再存在的*临时对象*。所有的具名变量或者对象都是左值，而右值不具名。很难得到左值和右值的真正定义，但是有一个可以区分左值和右值的便捷方法：**看能不能对表达式取地址，如果能，则为左值，否则为右值**。\n\n### 右值引用\n\n左值是指可以出现在=左侧者，\n\n右值是指只能出现在=右侧者\n\n临时对象是个右值\n\n##### 右值引用与move语义的关系\n\n- 关联性: 右值引用是实现move语义的基础\n- 作用: 允许\"偷取\"临时对象的资源而非复制\n- 应用场景: 容器操作中大量临时对象的处理\n\n### 移动语义\n\n右值则临时对象\n\n```cpp\nc.insert(ite,Vtype(buf));\n```\n\n左值则使用move关键字\n\n```cpp\nM c1(c);\nM c2(std::move(c1));\n```\n\n- 核心机制\n  - 当赋值右侧是右值时，左侧对象可直接\"偷取\"资源\n  - 避免不必要的资源分配和拷贝\n- 实现要点\n  - 类需要同时实现拷贝和移动语义版本\n  - 移动操作后原对象应处于有效但未定义状态\n  - 容器需要支持右值版本的插入操作\n- 注意事项\n  - 被移动后的对象不应再使用\n  - 移动构造函数应标记为noexcept\n  - 临时对象自动被视为右值\n- 典型应用\n  - 容器扩容时的元素迁移\n  - 返回临时对象的优化\n  - 明确不再使用的左值资源转移\n\n应用\n\n1. **函数返回值优化**。\n2. **STL 容器的高效插入与操作**。\n3. **动态资源管理（如智能指针）**。\n\n### 完美转发"},{"title":"STL的对比","url":"/2025/09/10/STL的对比/","content":"\n| 容器类型                 | 底层数据结构                          | 元素存储特点               | 访问方式                | 是否支持随机访问 | 动态大小调整 | 典型应用场景                                                 |\n| ------------------------ | ------------------------------------- | -------------------------- | ----------------------- | ---------------- | ------------ | ------------------------------------------------------------ |\n| **`vector`**             | 动态数组 (连续内存)                   | 按加入顺序连续存储         | 下标访问 (`[]`)         | 是               | 是           | 动态数组的替代，快速随机访问，大量数据按顺序存取。           |\n| **`deque`**              | 分段连续内存                          | 按加入顺序存储（分段实现） | 双向访问（头尾操作快）  | 是               | 是           | 需要快速在首尾插入与删除，而仍然支持随机访问的场景。         |\n| **`list`**               | 双向链表                              | 不连续，每个元素存储指针   | 双向遍历                | 否               | 是           | 频繁插入/删除操作的场景，尤其在需要中间修改的情况下。        |\n| **`forward_list`**       | 单向链表                              | 不连续，只有前向指针       | 单向遍历                | 否               | 是           | 内存占用较小的场景，在对链表操作需求简单时用作优化。         |\n| **`array`**              | 静态数组 (固定大小)                   | 按加入顺序连续存储         | 下标访问 (`[]`)         | 是               | 否           | 小容量、固定大小、性能关键的场景，避免动态分配。             |\n| **`set`**                | 平衡二叉搜索树（通常是 Red-Black 树） | 按键值自动排序             | 基于 key 查找和遍历     | 否               | 是           | 唯一值的集合，不允许重复值，支持快速有序的查找和插入。       |\n| **`multiset`**           | 平衡二叉搜索树                        | 按键值自动排序             | 基于 key 查找和遍历     | 否               | 是           | 允许重复值的集合，多次插入同一值场景（按顺序存储）。         |\n| **`map`**                | 平衡二叉搜索树                        | 按键值自动排序             | 基于 key 查找           | 否               | 是           | 有序的键值对储存，适合频繁按 key 查找具体值的场景。          |\n| **`multimap`**           | 平衡二叉搜索树                        | 按键值自动排序             | 基于 key 查找           | 否               | 是           | 允许同一键值存在多个映射值的场景。                           |\n| **`unordered_set`**      | 哈希表                                | 无序存储                   | 常数时间 key 查找       | 否               | 是           | 唯一值的集合，但无需排序，适合大量 key 快速判断是否存在的场景。 |\n| **`unordered_multiset`** | 哈希表                                | 无序存储                   | 常数时间 key 查找       | 否               | 是           | 允许重复值的集合，但无序存储，适合大数据去重分析场景。       |\n| **`unordered_map`**      | 哈希表                                | 无序存储                   | 常数时间 key-value 查找 | 否               | 是           | 可快速通过 key 查找 value 的场景（无需排序）。               |\n| **`unordered_multimap`** | 哈希表                                | 无序存储                   | 常数时间 key 查找       | 否               | 是           | 允许同一个 key 存储多个值（无需排序）的场景。                |\n| **`stack`**              | 基于 `deque` 实现                     | 后进先出 (LIFO)            | 只访问顶端 (`top`)      | 否               | 是           | 后进先出的场景，比如函数调用栈、括号匹配等。                 |\n| **`queue`**              | 基于 `deque` 实现                     | 先进先出 (FIFO)            | 只访问头部和尾部        | 否               | 是           | 先进先出的场景，比如任务排队、消息队列等。                   |\n| **`priority_queue`**     | 基于堆实现                            | 按优先级排序               | 访问最大（默认情况）值  | 否               | 是           | 按优先级任务调度、动态获取最大/最小值的场景。                |\n| **`bitset`**             | 定长的位数组                          | 每个位存储 true/false      | 位访问 (`[]`)           | 是               | 否           | 高效存储和操作布尔值，适合空间和位运算优化场景。             |\n\n\n\n#### **1. 底层数据结构**\n- **动态数组**：元素连续存放且可动态扩展的数组。\n- **链表**：使用指针将元素链接而成的结构，可分为单向链表与双向链表。\n- **平衡二叉树**：自平衡的二叉搜索树，常用的是红黑树（Red-Black Tree）。\n- **哈希表**：以哈希函数作为索引，通过哈希冲突解决机制（如拉链法）高效存储数据。\n- **堆**：通常是二叉堆，支持动态调整以保证堆顶始终是最大值或最小值。\n\n---\n\n#### **2. 元素存储特点**\n- **连续存储**：`vector` 和 `array` 采用连续存储，内存紧凑，随机访问快。\n- **分段连续存储**：`deque` 分段实现，以保证在头尾添加数据的高效性。\n- **不连续存储**：`list`、`forward_list`、`set` 等采用链表或树结构，插入/删除效率高，但随机访问速度较慢。\n\n---\n\n#### **3. 访问方式**\n- **下标访问 (`[]`)**：`vector`、`array` 支持随机访问，可迅速获取指定位置的元素。\n- **头尾访问**：`stack` 和 `queue` 限制为某些特定操作。\n- **优先访问**：`priority_queue` 只能访问堆顶元素（最大值/最小值）。\n- **基于 key 访问**：`map`、`unordered_map` 以键值对方式支持查找。\n\n---\n\n#### **4. 是否支持随机访问**\n- 支持随机访问的容器（如 `vector`、`array`、`deque` 等）提供 O(1) 复杂度的下标访问，操作简单。\n- 不支持随机访问的容器（如 `list`、`set` 等）需要遍历或依赖搜索结构，访问效率较低。\n\n---\n\n#### **5. 动态大小调整**\n- 动态容器（如 `vector`、`deque`、`list`）可以根据元素数目动态分配或收缩内存。\n- 静态容器（如 `array`）在定义时需指定固定大小。\n\n---\n\n#### **6. 应用场景**\n每种容器都有其典型应用场景，选择合适的容器取决于业务需求（如性能、顺序性、查找效率）。\n\n\n\n#### 根据需求选择不同容器：\n1. **需要快速随机访问**：使用 `vector`、`array`。\n2. **需要频繁插入和删除**：使用 `list`、`deque`（插入和删除表现良好）。\n3. **需要数据自动排序**：使用 `set`、`multiset`（有序集合）或 `map`、`multimap`（有序键值对）。\n4. **需要快速查找，不关心顺序**：优先选择哈希容器，比如 `unordered_set` 和 `unordered_map`。\n5. **使用栈或队列模型**：考虑 `stack`、`queue` 或 `priority_queue`。\n"},{"title":"其他问题","url":"/2025/09/10/其他问题/","content":"\n## Mysql问题\n\n 说一说事物隔离级别 \n\nSQL标准的事务隔离级别包括：\n\n读未提交，读提交，可重复读，串行化\n\n\n\n 事务的四大特性有哪些？ \n\n原子性，一致性，隔离性，持久性\n\n## Linux系统目录\n\n![目录2](/images/linux_folder.webp \"linux系统文件夹\")"},{"title":"关于项目","url":"/2025/09/10/关于项目/","content":"\n项目背景： 设计并实现了一个基于 Linux 平台的轻量级 HTTP 服务器，采用**多 Reactor 多线程**高并发模型，通过 **epoll 提供高效的 I/O 复用**。结合**自动增长缓冲区**、**定时器和异步日志**等技术，实现了高性能和稳定运行的目标。 \n\n主要工作  \n\n内存优化：设计了**内存池和 LFU 缓存**，减少内存碎片，提升内存使用效率。  \n\n高效事件处理：利用 **epoll 多路复用机制**，高效监听和处理客户端连接及数据传输事件。  \n\n高并发模型：基于 **Reactor 模型**，实现 **One Loop per Thread**，支持多客户端并发连接。  \n\n动态缓冲区：实现**自动增长缓冲区**，动态调整大小以适配不同请求，优化内存分配。  \n\n连接管理：使用**小根堆实现高效定时器**，管理连接超时时间，防止长期空闲连接浪费资源。  \n\n异步日志：设计**异步日志**模块，基于**单例模式和阻塞队列**，实现高效日志写入，避免同步写入的性能开销。 \n\n## 关于项目\n\n### 介绍一下\n\n本项目是一个高性能的WEB服务器，使用C++实现，项目底层采用了多线程多Reactor的网络模型，并且在这基础上增加了内存池，高效的双缓冲异步日志系统，以及LFU的缓存。\n\n服务器的网络模型是**主从reactor加线程池**的模式，IO处理使用了**非阻塞IO和IO多路复用技术**，具备**处理多个客户端**的http请求和ftp请求，以及对外**提供轻量级储存**的能力。\n\n项目中的工作可以分为两部分，\n\n一部分是服务器网络框架、日志系统、存储引擎等一些基本系统的搭建，\n\n另一部分 是为了提高服务器性能所做的一些优化，比如缓存机制、内存池等一些额外系统的搭建。\n\n最后还对系统中的部分功能进行了功能和压力测试。对于存储引擎的压力测试，\n\n在本地测试下，存储引擎读操作的QPS可以达到36万，写操作的QPS可以达到30万。对于网络框架的测试，使用webbench创建1000个进程对服务器进行60s并发请求，测试结果表明，对于短连接的QPS为1.8万，对于长连接的QPS为5.2万。\n\n### 项目难点\n\n根据工作分为两部分\n\n一部分是服务器网络框架，日志系统，存储引擎等一些基本系统的搭建，这部分的难点主要就是技术理解和选型，以及将一些开源的框架调整后应用到我的项目中去。\n\n另一部分就是性能优化方面，比如缓存机制，内存池等一些额外系统的搭建。这部分的难点在于找出服务器的性能瓶颈所在，然后结合自己的想法突破瓶颈，提高服务器性能。\n\n### 遇到的困难，怎么解决\n\n一方面是对技术理解不够深刻，难以选出合适的技术框架，这部分主要是阅读作者的技术文档，找相关的解析文章看\n\n另一部分是编程遇到的困难，由于工程能力不足出现bug，这部分主要是通过日志定位bug，推断bug出现的原因并尝试修复，如果以自己能力无法修复，先问问ai能提供什么思路，或者搜索相关的博客。\n\n\n\n## 内存优化\n\n设计了**内存池**和 **LFU 缓存**\n\n### 缓存机制\n\n### 为什么选择LFU\n\n因为最近加入的数据因为起始的频率很低，容易被淘汰，而早期的热点数据会一直占据缓存。\n\n\n\n\n\n## 高效事件处理：\n\n**epoll 多路复用机制**\n\n\n\n采用非阻塞I/O模型，执行系统调用就立即返回，不检查事件是否发生，没有立即发生返回-1，errno设置为在处理中。所以要采用I/O通知机制（I/O复用和SIGIO信号）来得知就绪事件。\n\n```tex\nI/O多路复用技术\nI/O 多路复用允许一个线程同时监视多个 I/O 文件描述符（如网络 socket），并在其中一个或多个文件描述符变为\"可操作\"时返回。应用程序可以据此进行相应的 I/O 操作（如读、写）。\n\n1.1 select\n简介\nselect 是一种最早的 I/O 多路复用接口，几乎所有主流平台都支持。\n\n它允许程序监视多个文件描述符，查询它们是否可读、可写或出现错误。\nselect 的接口会使用三个位图（readset、writeset 和 exceptset）指定文件描述符的状态。\n工作原理\n调用 select 时，程序将文件描述符集（一个位图）传递给内核。\n内核在超时时间内扫描这些文件描述符并返回那些状态发生变化的描述符（如变为可读或可写）。\n用户态程序可根据返回结果进行相应的 I/O 操作。\n缺点\n支持的文件描述符数量有限（通常受 FD_SETSIZE 限制，默认 1024）。\n每次调用时都需要将文件描述符的状态从用户态复制到内核态，这带来一定的性能开销。\n内核需要线性遍历所有文件描述符（效率低），尤其在大并发连接时性能较差。\n1.2 poll\n简介\npoll 是 select 的改进版本，克服了文件描述符数量限制的问题。\n\n它使用一个数组结构而不是位图来描述文件描述符及其事件。\n工作原理\n用户定义一个 pollfd 数组，该数组中每一个元素保存一个文件描述符及其相关事件。\n调用 poll 时，内核会遍历这个数组，检查哪些文件描述符有事件发生，并返回结果。\n优点\n支持任意数量的文件描述符，突破了 select 的 FD_SETSIZE 限制。\n缺点\n和 select 类似，每次调用都需要将监控的文件描述符数组从用户态复制到内核态，开销较大。\n和 select 一样，内核需要线性遍历文件描述符，在高并发场景下效率仍然较低。\n1.3 epoll\n简介\nepoll 是 Linux 平台下提供的高性能 I/O 多路复用接口，它是 select 和 poll 的替代品。\n\nepoll 被设计用于解决 select 和 poll 的性能问题，是一种效率更高的方式处理大量并发连接的技术。\n工作原理\nepoll 的核心思想是使用事件驱动机制（Event-Driven）替代轮询机制。\n\n创建一个 epoll 实例（epoll_create），用作事件管理器。\n使用 epoll_ctl 向内核注册需要监听的具体文件描述符及其事件类型（关注可读、可写或异常事件）。\n调用 epoll_wait，等待事件发生。\n发生事件的文件描述符被加入到一个内核维护的就绪列表，并从中直接返回。\n这避免了不必要的遍历额外文件描述符的开销。\n优点\n事件驱动模型：文件描述符有变化时通过回调机制加入就绪列表，只需处理活跃文件描述符。\n无大小限制：最大受限于系统的内存资源，而非固定限制。\n高性能：避免了线性遍历，即使监视十万连接，只需处理少量已就绪的描述符。\n缺点\n仅支持 Linux 系统，不跨平台。\nepoll 的两种触发模式\nLT（Level Trigger，水平触发）： 默认模式，文件描述符只要处于就绪状态，就会不断返回。\nET（Edge Trigger，边缘触发）： 更高效，只在文件描述符状态从未就绪到就绪时触发（适用于非阻塞 I/O）\n```\n\n### IO多路复用\n\n### LT与ET\n\nLT:水平触发模式，只要内核缓冲区有数据就一直通知，只要socket处于可读状态就一直返回sockfd；是默认的工作模式，支持阻塞IO和非阻塞IO\n\nET：边沿触发模式，只有状态发生变化才通知并且这个状态只会通知一次，只有当socket由不可写到可写或由不可读到可读，才会返回sockfd：只支持非阻塞IO\n\n### 为什么用epoll，其他多路复用方式以及区别\n\n\n\n\n\n## 高并发模型\n\n基于 **Reactor 模型**，实现 One Loop per Thread\n\n\n\nReactor模式通常用同步I/O模型实现\n\nProactor模式通常用异步I/O模型实现\n\n\n\n1. 主线程往epoll内核事件表注册socket读就绪事件\n2. 主线程调用epoll_wait等待socket上有数据可读\n3. 当socket上有数据可读时，epoll_wait通知主线程，主线程将socket可读事件放入请求队列\n4. 工作线程被唤醒，读数据处理请求，然后往epoll内核事件表注测socket写就绪事件\n5. 主线程调用epoll_wait等待socket可写\n6. 当socket可写，epoll_wait通知主线程，主线程将socket可写事件放入请求队列\n7. 睡眠在请求队列的工作线程被唤醒，往socket上写入服务器处理客户请求的结果\n\n\n\n\n\n## 动态缓冲区\n\n实现**自动增长缓冲区**\n\n**1. 核心数据结构**\n\n```cpp\nclass Buffer {\nprivate:\n    std::vector<char> buffer_;  // 主缓冲区（使用vector自动管理内存）\n    size_t readerIndex_;         // 读指针（数据起始位置）\n    size_t writerIndex_;         // 写指针（数据结束位置）\n};\n```\n\n采用vector作为底层容器，自动处理内存分配/释放\n\n读写指针分离设计，支持零拷贝操作\n\n`零拷贝是指计算机执行IO操作时，CPU不需要将数据从一个存储区域复制到另一个存储区域，从而可以减少上下文切换以及CPU的拷贝时间。它是一种I/O操作优化技术。`\n\n**2. 自动增长机制**\n\n**(1) 扩容触发条件**\n\n当`writableBytes() < 待写入数据量`时自动扩容\n\n通过vector的resize实现：\n\n```cpp\nvoid append(const char* data, size_t len) {\n    if (writableBytes() < len) {\n        makeSpace(len);  // 扩容操作\n    }\n    std::copy(data, data+len, beginWrite());\n    writerIndex_ += len;\n}\n```\n\n**(2) 智能扩容策略**\n\n```cpp\nvoid makeSpace(size_t len) {\n    if (writableBytes() + prependableBytes() < len) {\n        // 需要真正扩容：vector.resize(writerIndex_ + len)\n        buffer_.resize(writerIndex_ + len);\n    } else {\n        // 通过移动数据复用空间\n        size_t readable = readableBytes();\n        std::copy(begin()+readerIndex_, begin()+writerIndex_, begin());\n        readerIndex_ = 0;\n        writerIndex_ = readable;\n    }\n}\n```\n\n\n\n**3. 高性能IO优化**\n\n**(1) 双缓冲区读操作**\n\n```cpp\nssize_t readFd(int fd, int* saveErrno) {\n    char extrabuf[65536]; // 64KB栈缓冲区\n    iovec vec[2];\n    \n    vec[0].iov_base = begin() + writerIndex_;\n    vec[0].iov_len = writableBytes();\n    vec[1].iov_base = extrabuf;\n    vec[1].iov_len = sizeof(extrabuf);\n    \n    // 根据剩余空间决定使用1个还是2个缓冲区\n    const int iovcnt = (writableBytes() < sizeof(extrabuf)) ? 2 : 1;\n    ssize_t n = readv(fd, vec, iovcnt);\n    \n    // 处理读入的数据...\n}\n```\n\n使用`readv`系统调用实现分散读\n\n优先使用主缓冲区空间，不足时使用栈缓冲区过渡\n\n避免频繁扩容带来的性能损耗\n\n\n\n**(2) 写操作优化**\n\n```cpp\nssize_t writeFd(int fd, int* saveErrno) {\n    return ::write(fd, peek(), readableBytes());\n}\n```\n\n直接使用`write`系统调用\n\n`peek()`返回有效数据起始指针，避免内存拷贝\n\n\n\n**4. 关键特性总结**\n\n1. **智能扩容**：按需自动增长，兼顾内存使用效率\n\n2. **零拷贝设计**：读写指针分离，减少内存拷贝\n\n3. **双缓冲策略**：栈空间+主缓冲区组合优化IO性能\n\n4. **线程安全**：单次IO操作原子性保证\n\n5. **内存高效**：自动回收已读区域空间\n\n典型工作流程：\n\n1. 读取数据时优先使用主缓冲区空间\n\n2. 空间不足时暂存到栈缓冲区\n\n3. 触发自动扩容后合并数据\n\n4. 写入数据时直接操作有效数据区域\n\n\n\n\n\n## 连接管理\n\n使用**小根堆实现高效定时器**，管理连接超时时间\n\n```cpp\nusing Entry = std::pair<Timestamp, Timer*>; // 以时间戳作为键值获取定时器\nusing TimerList = std::set<Entry>;          // 底层使用红黑树管理，自动按照时间戳进行排序\n```\n\n```cpp\n    // 定时器管理红黑树插入此新定时器\n    timers_.insert(Entry(when, timer));\n```\n\n\n\n\n\n\n\n## 异步日志\n\n设计**异步日志**模块，基于**单例模式和阻塞队列**\n\n日志系统是多生产者，单消费者的任务场景\n\n多生产者负责把日志写入缓冲区，单消费者负责把缓冲区数据写入文件\n\n![img](https://cdn.nlark.com/yuque/0/2025/png/47188040/1737792284038-49feb6bc-6920-4e1c-9c4a-516ffee44982.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_26%2Ctext_5Luj56CB6ZqP5oOz5b2V55-l6K-G5pif55CD%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)\n\n前端往后端写，后端往硬盘写\n\n双缓冲技术 ，写满就交换，相当于将多条日志拼接成一个大buffer传送到后端然后写入文件，减少了线程开销\n\n"},{"title":"其他项目问题","url":"/2025/09/10/其他项目问题/","content":"\n### 为什么服务器要以root身份启动，不能以root身份运行\n\n为什么要以 root 启动？\n\n绑定低编号端口（如 80、443）。\n配置共享内存、设备文件、调整资源等需要的高权限操作。\n\n为什么不能以 root 运行？\n\n潜在漏洞可能导致系统被完全攻破。\n不符合最小权限原则。\n服务隔离无法实现，其他服务可能受到影响。\n意外操作可能导致灾难性的后果。\n如何解决这个问题？\n\n启动时以 root 完成特权操作，然后立刻降级为普通用户运行。\n使用 setuid() 和 setgid() 等 Linux 用户管理接口实现特权降级。"},{"title":"字节面试准备","url":"/2025/09/10/字节面试准备/","content":"\n# 字节面试准备\n\n### **1. C++ 基础**\n\n#### **(1) 面向对象的三个特性**\nC++ 是一种支持面向对象编程的语言，其面向对象编程的三个核心特性是：封装（Encapsulation）、继承（Inheritance）、多态（Polymorphism）。\n\n- **封装**\n  封装是将数据（成员变量）和操作这些数据的代码（成员函数）绑定在一起，形成一个整体（类）。\n  **优点：**\n  - 限制对内部成员的访问，保护数据隐私（通过 `public`、`protected`、`private` 访问权限控制关键字）。\n  - 提高代码的可维护性和复用性。\n\n- **继承**\n  继承是一种用于实现代码复用和建立层次化关系的机制。子类可以继承父类的属性和行为。\n  **优点：**\n  - 重用父类代码。\n  - 可以通过父类指针或引用操作多态对象。\n\n- **多态**\n  多态是允许通过基类引用或指针访问派生类对象，并调用派生类的重写方法。基于动态绑定（Run-time Polymorphism）的多态主要通过虚函数实现。\n  **优点：**\n  - 提高代码的扩展性和灵活性，可以使用统一的接口处理不同类型的对象。\n\n#### **(2) 多态和虚函数的底层实现**\n\n- **多态的实现**\n  - 多态的核心是通过 **虚函数表（Virtual Table）和虚函数表指针**实现的。\n  - 编译器会在类中生成一个指向虚函数表的指针，称为 **vptr**。\n  - 虚函数表是一个数组，存储了该类的所有虚函数的函数指针。\n  - 在运行时，通过 `vptr` 指向的虚函数表，根据实际的动态类型调用对应的方法。\n\n- **虚函数的底层实现**\n  - 类中有虚函数时，类会生成一个虚函数表（存储虚函数指针）。\n  - 每个对象的内存布局中会加入一个指向虚函数表的指针（vptr）。\n  - 通过 `vptr` 和虚函数表在运行时找到并调用具体的函数。\n\n示例：\n```cpp\nclass Base {\npublic:\n    virtual void display() { std::cout << \"Base\" << std::endl; }\n};\n\nclass Derived : public Base {\npublic:\n    void display() override { std::cout << \"Derived\" << std::endl; }\n};\n\nint main() {\n    Base* obj = new Derived();\n    obj->display(); // 执行 Derived::display()\n}\n```\n\n**区别场景：带虚函数与不带虚函数**\n- 如果类中没有虚函数，那么对象内存只存储成员变量。\n- 带虚函数的类，内存中会存储额外的虚函数表指针。\n- 因此，带虚函数的对象的内存占用会比没有虚函数的对象多。\n\n---\n\n#### **(3) 多继承的特殊情况（菱形继承问题）**\n\n场景：如何区分多继承中调用的同名成员和方法？\n\n```cpp\n#include <iostream>\nclass A {\npublic:\n    int x;\n    void func() { std::cout << \"A::func()\" << std::endl; }\n};\n\nclass B : public A {\npublic:\n    void func() { std::cout << \"B::func()\" << std::endl; }\n};\n\nclass C : public A {\npublic:\n    void func() { std::cout << \"C::func()\" << std::endl; }\n};\n\nclass D : public B, public C {};\n\nint main() {\n    D obj;\n    // 调用 B::func 或 C::func？\n    obj.B::func(); // 通过类名加作用域区分\n    obj.C::func();\n    return 0;\n}\n```\n\n**菱形继承问题的解决方式：**\n- 普通继承会导致 `A` 的成员在 `B` 和 `C` 中各有一份（两份副本）。\n- 使用 **虚继承** 可以解决该问题，确保 `A` 的成员在多继承的子类中只有一份。\n```cpp\nclass A { public: int x; };\nclass B : virtual public A {};\nclass C : virtual public A {};\nclass D : public B, public C {};\n```\n\n`D` 类中只有一份 `A::x`。\n\n---\n\n### **3. 内存**\n\n#### **(1) malloc 和 new 的区别**\n1. **`malloc`：**\n   - 只分配内存，不调用构造函数。\n   - 返回 `void*` 需要强制类型转换。\n   - 需要 `free` 手动释放。\n\n2. **`new`：**\n   - 分配内存并自动调用构造函数初始化对象。\n   - 返回目标类型的指针，无需强转。\n   - 使用 `delete` 释放内存并调用析构函数。\n\n#### **(2) 只分配内存或只调用构造函数**\n1. 只分配内存（不调用构造函数）：\n   - 可使用 `operator new`：\n     ```cpp\n     void* ptr = ::operator new(sizeof(MyClass)); // 只分配内存\n     ```\n\n2. 只调用构造函数（对象已分配内存）：\n   - 可通过 `placement new`：\n     ```cpp\n     MyClass* obj = new(ptr) MyClass(args); // 在已有内存 `ptr` 上构造对象\n     ```\n\n**operator new：用来分配原始内存，不涉及对象的构造。**\n**operator delete：用来释放原始内存，不涉及对象的析构。**\n普通的 new 调用等价于：\n\n```cpp\nMyClass* obj = static_cast<MyClass*>(::operator new(sizeof(MyClass))); // 分配内存\nnew (obj) MyClass(); // 构造对象\n```\n\n\n普通的 delete 调用等价于：\n\n```cpp\nobj->~MyClass();             // 调用析构函数\n::operator delete(obj);      // 释放内存\n```\n\n**注意：new不能重载，只有operator new才能重载**\n\n#### **(3) `sizeof` 结构体的对齐规则**\n\nC++ 中结构体内存对齐主要受到以下因素影响：\n1. 每个成员变量的对齐方式由编译器决定（通常与成员类型的大小相关）。\n2. **结构体的总大小必须是最大对齐成员的倍数。**\n\n示例：\n```cpp\nstruct S1 {\n    char A;  // 1 字节\n    char B;  // 1 字节\n    int C;   // 4 字节\n};\nstruct S2 {\n    char A;  // 1 字节\n    int C;   // 4 字节\n    char B;  // 1 字节\n};\n```\n- 对于 S1，内存布局为：`A + B + padding + C`（总大小 8）\n- 对于 S2，内存布局为：`A + padding + C + B + padding`（总大小 12）\n\n### **4. STL 和智能指针**\n\n#### **(1) 智能指针概览**\nC++ 标准库提供了三种智能指针：\n1. **`std::unique_ptr`**: 独占所有权，不可复制。\n2. **`std::shared_ptr`**: 共享所有权，使用引用计数。\n3. **`std::weak_ptr`**: 使用弱引用，依赖 `shared_ptr`，避免循环引用。\n\n#### **(2) `std::shared_ptr` 的实际应用**\n- 场景：共享资源的生命周期管理（如线程池中的任务对象）。\n- 示例：\n  ```cpp\n  std::shared_ptr<int> p = std::make_shared<int>(10);\n  {\n      std::shared_ptr<int> q = p; // 引用计数+1\n  } // q 离开作用域，引用计数-1\n  ```\n\n**使用智能指针（如 std::shared_ptr）的优点**：\n\n自动化的内存管理，避免内存泄漏和悬垂指针。简化代码逻辑，减少人工管理内存的复杂性。更容易与标准容器（如 std::vector）配合使用。不使用智能指针是可以的，\n\n但代价是：\n\n更容易引入 bug，例如内存泄漏、悬垂指针问题。\n增加代码维护难度，并且可能需要大量的单元测试来覆盖所有的边界情况。\n难以保证代码的健壮性，特别是在复杂的资源关系中。\n\n### RAII是什么\n\nRAII（Resource Acquisition Is Initialization，资源获取即初始化）是一种资源管理的编程惯用法，是 C++ 中处理资源管理的重要设计理念。它通过将资源的生命周期与对象的生命周期绑定来确保资源得到正确的分配和释放，从而避免资源泄漏。\n\n**核心思想**\n\n1. **资源绑定到对象的生命周期**：\n   - 当一个对象在栈上或通过堆分配时，与该对象相关联的资源（例如内存、文件句柄、锁、网络连接等）也随之初始化。\n   - 当该对象离开作用域（或者析构）时，资源会被自动释放。\n\n2. **依靠析构函数来释放资源**：\n   - C++ 中，当一个对象生命周期结束时，其析构函数会被自动调用。因此，可以利用析构函数自动释放资源，而无需手动释放。\n   - 通过 RAII，资源分配后不用担心异常、早退或其他复杂逻辑干扰正确释放。\n\n**RAII 的优点**\n\n1. **自动化资源管理**：用户不需要手动释放资源，不用担心遗漏或错误。\n2. **异常安全**：即使代码中间发生异常，析构函数仍然会自动释放资源。\n3. **代码简洁**：减少了显式的资源释放代码，避免了冗余或错误。\n\n**应用场景**\n\nRAII 在内存分配、文件操作、线程锁、数据库连接等场景广泛应用。例如：\n1. **智能指针**：\n   - `std::unique_ptr`：独占资源，适合动态内存管理。\n   - `std::shared_ptr`：共享资源，适合多个对象共享动态内存。\n2. **互斥锁**：\n   - `std::lock_guard<std::mutex>` 和 `std::unique_lock`。\n3. **文件与流对象**：\n   - C++ 的 IO 流类如 `std::ifstream` 和 `std::ofstream`。\n4. **其他自定义的资源管理类**：\n   - 如管理数据库连接、网络套接字、句柄等。\n\n**总结**\n\nRAII 的核心就是将资源的生命周期绑定到对象的生命周期，通过构造函数和析构函数确保资源的正确分配和释放。这种机制有效避免了手动管理资源时的各种问题（如资源泄漏、重复释放等），是 C++ 中非常重要的编程思想，尤其在异常安全和代码简洁性方面效果显著。\n\n面试中，如果被问到 RAII，你可以直接引用 C++ 智能指针、文件流或锁管理类作为例子展开解释。进一步可以说明 RAII 提升了程序的安全性及简洁性，使 C++ 的资源管理更加工程化和易用化。\n\n\n\n### **5. 操作系统**\n\n#### **(1) 并发与并行的区别**\n- **并发（Concurrency）**：多个任务在逻辑上**同时进行**，但实际上可能是按时间片交替执行。\n- **并行（Parallelism）**：多个任务在物理上**真正同时运行**（需要多核 CPU 支持）。\n\n#### **(2) 最大并发线程池设计**\n- 关键点：\n  1. 使用任务队列管理任务。\n  2. 通过信号量或条件变量限制线程并发数量。\n  3. 动态创建、销毁线程降低资源消耗（即线程复用）。\n\n---\n\n### **6. 网络**\n\n#### **(1) HTTPS 的通信过程**\n\n1. **客户端发送请求**，包括支持的协议版本、加密套件等。\n2. **服务器发送证书**，客户端验证证书的合法性。\n3. **TLS 握手**，双方协商对称密钥（通过非对称加密交换密钥）。\n4. **加密通信**，之后的所有数据使用对称密钥加密。\n\n---\n\n### **7. 项目挑战**\n\n#### **Buffer 的思想**\n- **临时缓存**用于解决数据处理速度的差异（如网络接收速度慢于处理速度）。\n- **自动增长：**通过动态分配内存扩容实现，常用 **指数增长（2 倍增长）** 策略；也可以按照具体业务需要调整。"},{"title":"智能指针","url":"/2025/09/10/智能指针/","content":"\n## 智能指针\n\n### **unique_ptr**\n\n作用域指针，不能复制\n\n栈分配指针，当死亡时，自动释放所管理的内存，无需显示调用delete\n\n```cpp\nstd::unique_ptr<int> p1 = std::make_unique<int>(10); // 管理动态分配的内存\n// std::unique_ptr<int> p2 = p1; // 错误！unique_ptr不支持拷贝\nstd::unique_ptr<int> p2 = std::move(p1); // 通过 std::move 转移所有权\n```\n\n只能显示调用构造函数，因为其构造函数有`explicit`关键字，没有了构造函数的隐式转换\n\n最好的调用还是使用`make_unique`会捕获异常，不会产生悬空指针问题\n\n### **shared_ptr**\n\n追踪引用计数，如果引用为0，则释放内存\n\n需要分配内存用于计数\n\n```cpp\nshared_ptr<Entity> p = make_shared<Entity>();\n```\n\n作用主要包括：\n\n1. 自动管理动态分配的对象，避免手动调用 `delete`。\n2. 支持共享所有权，让多个 `shared_ptr` 可以安全地访问同一对象。\n3. 借助引用计数机制，实现对象的生命周期控制，当最后一个 `shared_ptr` 销毁后，自行释放资源。\n\n**`unique_ptr`**：独占所有权，不支持多个指针管理同一个对象；更轻量且不存在循环引用问题。\n\n**`weak_ptr`**：用于观察 `shared_ptr` 管理的对象，不增加引用计数；主要用于辅助 `shared_ptr`，避免循环引用的问题。\n\n\n\n### std::weak_ptr\n\n`std::weak_ptr` 是 C++11 引入的一种智能指针，和 `std::shared_ptr` 一起使用，用于避免 **循环引用** 问题，同时提供了一种对 `std::shared_ptr` 所管理对象的弱引用（non-owning reference）。它不改变所管理对象的引用计数。\n\n- **循环引用问题**：\n  在使用 `std::shared_ptr` 时，如果两个对象互相以 `shared_ptr` 引用彼此，会导致**内存泄漏**，因为它们的引用计数无法递减到 0。\n  - `shared_ptr` 通过引用计数管理对象的生命周期，当引用计数为 0 时，自动释放对象。\n  - 如果存在循环引用，两个对象会始终持有对方，这样它们的引用计数永远不会减为 0，因此无法释放内存。\n- **非拥有性的弱引用**：\n  有时候，一个对象只需要 \"观察\" 对另一个对象的引用，而无需控制它的生命周期。这时使用 `std::weak_ptr` 是更合理的选择。\n\n`std::weak_ptr` 提供了一种临时、不影响生命周期的引用，从而解决了上述问题。\n\n**总结**\n\n`std::weak_ptr` 的主要使用场景包括：\n\n1. **解决 `std::shared_ptr` 的循环引用问题**。\n2. **跨组件之间的非拥有性引用**，例如缓存对象的管理。\n3. **事件监听器或回调函数，避免悬垂指针的产生**。\n4. 在弱引用需求场景下提供更加灵活的资源管理，而不是一味增加强引用计数。\n\n\n\n\n\n**`std::weak_ptr` 的特点**\n\n1. **不控制对象的生命周期**：\n2. **检测对象是否已销毁**：\n   - 可以通过调用 `weak_ptr` 的 `expired()` 方法来检查被引用的对象是否已经销毁。\n3. **使用 `lock()` 转换为 `shared_ptr`**：\n   - 如果需要安全地访问被引用的对象，可以调用 `weak_ptr` 的 `lock()` 方法，返回一个临时的 `shared_ptr`。如果对象已销毁，`lock()` 会返回一个空指针。\n\n假设我们有两个类 `A` 和 `B`，它们通过 `std::shared_ptr` 互相引用。如果没有使用 `weak_ptr`，将会发生循环引用，导致内存泄漏。\n\n**示例代码（循环引用问题）**：\n\n```cpp\n#include <iostream>\n#include <memory>\n\nclass B; // 前向声明\n\nclass A {\npublic:\n    std::shared_ptr<B> ptrB; // A 持有共享指针引用 B\n    ~A() { std::cout << \"A destroyed\" << std::endl; }\n};\n\nclass B {\npublic:\n    std::shared_ptr<A> ptrA; // B 持有共享指针引用 A\n    ~B() { std::cout << \"B destroyed\" << std::endl; }\n};\n\nint main() {\n    // 创建循环引用\n    auto a = std::make_shared<A>();\n    auto b = std::make_shared<B>();\n    a->ptrB = b; // A 持有 B\n    b->ptrA = a; // B 持有 A\n\n    // 离开 main() 作用域时，A 和 B 的引用计数不会减到 0，导致内存泄漏\n    return 0;\n}\n```\n\n运行结果：\n\n```text\n# 没有输出，因为 `A` 和 `B` 无法正常析构，发生内存泄漏。\n```\n\n**解决循环引用的正确做法**：\n将其中一个引用改为 `std::weak_ptr`，避免两个对象互相增加引用计数。\n\n```cpp\nclass B; // 前向声明\n\nclass A {\npublic:\n    std::weak_ptr<B> ptrB; // 弱引用 B\n    ~A() { std::cout << \"A destroyed\" << std::endl; }\n};\n\nclass B {\npublic:\n    std::shared_ptr<A> ptrA; // 共享指针持有 A\n    ~B() { std::cout << \"B destroyed\" << std::endl; }\n};\n\nint main() {\n    auto a = std::make_shared<A>();\n    auto b = std::make_shared<B>();\n    a->ptrB = b; // A 弱引用 B\n    b->ptrA = a; // B 持有 A\n\n    // 离开作用域时，A 和 B 都将正确析构\n    return 0;\n}\n```\n\n运行结果：\n\n```text\nB destroyed\nA destroyed\n```\n\n通过将某一侧的引用改为 `std::weak_ptr`，打破了循环引用。\n\n---\n\n**跨组件间的弱引用**\n\n如果某些对象之间并无强依赖关系，但仍需临时引用，则可以使用 `std::weak_ptr`。\n\n**示例 1：缓存管理**\n在缓存系统中，如果一个对象的存在依赖于被缓存的内容，则可以使用 `std::weak_ptr`：\n\n```cpp\n#include <iostream>\n#include <memory>\n#include <unordered_map>\n#include <string>\n\nclass CachedObject {\npublic:\n    CachedObject(std::string name) : name(name) {\n        std::cout << name << \" created\" << std::endl;\n    }\n    ~CachedObject() {\n        std::cout << name << \" destroyed\" << std::endl;\n    }\n    void printName() { std::cout << \"Object name: \" << name << std::endl; }\n\nprivate:\n    std::string name;\n};\n\nint main() {\n    std::unordered_map<std::string, std::weak_ptr<CachedObject>> cache;\n\n    {\n        auto obj1 = std::make_shared<CachedObject>(\"Object1\");\n        cache[\"key1\"] = obj1;\n\n        auto obj2 = std::make_shared<CachedObject>(\"Object2\");\n        cache[\"key2\"] = obj2;\n\n        // 使用缓存中的对象\n        if (auto obj = cache[\"key1\"].lock()) {\n            obj->printName(); // 输出：Object name: Object1\n        }\n    } // obj1 和 obj2 均超出作用域，被释放\n\n    // 尝试访问释放的对象\n    if (cache[\"key1\"].expired()) {\n        std::cout << \"Object1 no longer exists\" << std::endl; // 输出\n    }\n\n    return 0;\n}\n```\n\n运行结果：\n\n```text\nObject1 created\nObject2 created\nObject name: Object1\nObject2 destroyed\nObject1 destroyed\nObject1 no longer exists\n```\n\n---\n\n**事件回调（防止悬垂引用）**\n\n如果某类对象注册了一个事件监听器或回调函数，而监听器的生命周期可能比被观察的对象短，那么可以使用 `std::weak_ptr` 避免访问悬垂的指针。\n\n例如：\n\n```cpp\n#include <iostream>\n#include <memory>\n#include <functional>\n\nclass EventSource;\n\nclass Listener {\npublic:\n    Listener(std::shared_ptr<EventSource> source) : source(source) {}\n    void onEvent() {\n        if (auto src = source.lock()) { // 检查 source 是否仍有效\n            std::cout << \"Event handled\" << std::endl;\n        } else {\n            std::cout << \"Source no longer exists\" << std::endl;\n        }\n    }\n\nprivate:\n    std::weak_ptr<EventSource> source;\n};\n\nclass EventSource : public std::enable_shared_from_this<EventSource> {\npublic:\n    void fireEvent() {\n        if (listener) listener(); // 调用回调\n    }\n\n    void setListener(std::function<void()> callback) {\n        listener = callback;\n    }\n\nprivate:\n    std::function<void()> listener;\n};\n\nint main() {\n    std::shared_ptr<EventSource> source = std::make_shared<EventSource>();\n    {\n        auto listener = std::make_shared<Listener>(source);\n        source->setListener([listener]() { listener->onEvent(); });\n\n        source->fireEvent(); // 输出：Event handled\n    }\n\n    // Listener 已销毁，无悬垂引用\n    source->fireEvent(); // 不输出，Listener 已解除绑定\n\n    return 0;\n}\n```\n"},{"title":"腾讯面试准备","url":"/2025/09/10/腾讯面试准备/","content":"\n## 算法和数据结构\n\n刷题\n\n## C++的stl和新特性\n\n#### 常量指针和指针常量\n\n```cpp\nconst int *p = &a;//常量指针，指针指向常量，指针指向的变量不能通过指针修改，但是指针指向的值可以改变\n```\n\n```cpp\nint *const p = &a;//指针常量，是一个常量，不能改变指向的对象（地址），但是可以改变地址的内容\n```\n\n#### 野指针和悬浮指针\n\n野指针是指向已经被释放或者⽆效的内存地址的指针\n\n悬浮指针是指向已经被销毁的对象的引⽤\n\n区别就是一个是指针一个是引用\n\n## 网络编程\n\n#### 网络编程的基本流程\n\n#### **(1) 服务端代码流程**\n\n```cpp\n1. socket()             // 创建一个套接字\n2. bind()               // 将套接字与特定 IP 地址和端口绑定\n3. listen()             // 开启监听，等待客户端连接\n4. accept()             // 相应客户端的连接请求，接受新的连接\n5. send()/recv()       // 用于和客户端通信（读取请求或者写入响应\n6. close()              // 关闭连接\n```\n\n#### **(2) 客户端代码流程**\n\n```cpp\n1. socket()             // 创建一个套接字\n2. connect()            // 连接到服务端指定的 IP 地址和端口\n3. send()/recv()       // 用于发送请求或读取服务端的响应\n4. close()              // 关闭连接\n```\n\n\n\n\n\n\n\n## 调试命令，gdb/vscode\n\n\n\n## 额外：linux操作系统的内存管理，文件系统，进程和线程调度\n\n进程间的通信机制：信号量，条件变量，生产者消费者\n\n\n\n异步通信：回调函数，生产者消费者（promise-future和消息队列）\n\n同步通信：阻塞式调用，文件或网络操作\n\n\n\n\n\n\n\n## 引用和指针的区别\n\n### **1. 什么是引用和指针？**\n\n1. **引用（Reference）**：\n   \n   - 引用是某个变量的别名，声明后与该变量绑定在一起，不能再绑定其他变量。\n   - 本质上是一个语法糖，用更简洁的方式访问变量。\n   \n   示例代码：\n   ```cpp\n   int a = 10;\n   int& ref = a;  // 引用 `ref` 绑定到变量 `a`\n   ref = 20;      // 实际修改的是 `a`\n   ```\n   \n2. **指针（Pointer）**：\n   - 指针是存储变量地址的一种特殊变量，通过指针可以间接访问或操作存储在内存地址上的值。\n   - 指针可以指向不同的变量或内存单元。\n\n   示例代码：\n   ```cpp\n   int a = 10;\n   int* ptr = &a;  // 指针 ptr 存储变量 a 的地址\n   *ptr = 20;      // 实际修改的是 a\n   ```\n\n---\n\n### **2. 引用和指针的区别**\n\n| 特性                   | 引用                     | 指针                      |\n| ---------------------- | ------------------------ | ------------------------- |\n| **定义方式**           | 使用 `&` 声明            | 使用 `*` 声明             |\n| **是否可以为空**       | 引用必须绑定到变量       | 指针可以是 `nullptr` 或空 |\n| **绑定后是否可以更改** | 一旦绑定不能更改         | 指针可以重新指向其他变量  |\n| **语法**               | 直接使用，无需解引用符号 | 需要用 `*` 解引用         |\n| **内存布局**           | 编译器实现（可能是指针） | 明确存储变量地址          |\n| **需要初始化**         | 声明时必须初始化         | 可以声明后再初始化        |\n| **别名关系**           | 是原变量的别名           | 独立的变量                |\n| **运算**               | 不支持运算               | 可以进行加减运算          |\n| **灵活性**             | 较低，限定性强           | 较高，可以动态分配内存    |\n\n---\n\n### **3. 区别详解**\n\n#### **(1) 是否必须初始化**\n- **引用：**\n  - 引用在声明的时候必须初始化，否则无法通过编译。\n  ```cpp\n  int a = 10;\n  int& ref;  // 编译错误，引用必须绑定变量\n  ```\n\n- **指针：**\n  - 指针声明后可以不初始化，但最好将其初始化（例如初始化为 `nullptr`），否则容易产生未定义行为。\n  ```cpp\n  int* ptr;  // 未初始化，非法操作可能导致未定义行为\n  int* ptr = nullptr;  // 推荐初始化为 nullptr\n  ```\n\n#### **(2) 是否可以为空**\n- **引用：**\n  - 引用不能指向空（`nullptr`），它必须始终绑定到有效的变量。\n- **指针：**\n  - 指针可以指向空内存区域（`nullptr`），表示它当前没有指向任何变量。\n\n   示例：\n   ```cpp\n   int* ptr = nullptr;  // 合法\n   int& ref = nullptr;  // 编译错误，引用必须绑定到变量\n   ```\n\n#### **(3) 绑定后是否可以更改**\n- **引用：**\n  - 引用一旦绑定到变量，就不能再绑定到其他变量，引用始终是它所绑定变量的别名。\n  ```cpp\n  int a = 10, b = 20;\n  int& ref = a;  // ref 绑定到 a\n  ref = b;       // 修改的是 a 的值，而不是重新绑定到 b\n  ```\n\n- **指针：**\n  - 指针可以随时更改指向，可以指向其他变量或内存单元。\n  ```cpp\n  int a = 10, b = 20;\n  int* ptr = &a;  // ptr 指向 a\n  ptr = &b;       // ptr 改为指向 b\n  ```\n\n#### **(4) 使用上的差异**\n- **引用：**\n  - 如果将一变量赋值给引用，引用直接操作变量本身。\n  ```cpp\n  int a = 10;\n  int& ref = a;\n  ref = 20;  // 改变的是 a，a 的值变为 20\n  ```\n\n- **指针：**\n  - 要改变指针指向变量的值，需要解引用（`*`）。\n  ```cpp\n  int a = 10, b = 20;\n  int* ptr = &a;  // 指针指向 a\n  *ptr = 30;      // 修改 a 的值为 30\n  ptr = &b;       // 改为指向 b\n  ```\n\n#### **(5) 运算能力**\n- **引用：**\n  - 引用不支持指针的算术运算，例如加减法。\n- **指针：**\n  - 指针可以进行算术运算，例如指针递增/递减，用于访问数组元素。\n  ```cpp\n  int arr[3] = {1, 2, 3};\n  int* ptr = arr;   // 指向数组的第一个元素\n  ptr++;            // 指向下一个元素\n  ```\n\n#### **(6) 内存特性**\n- 引用在编译器实现中，可能会转换为指针，但它对开发者是透明的。\n- 指针本质上是一个变量，存储的是某个地址，并且占用内存。\n\n---\n\n### **4. 引用与指针的适用场景**\n\n#### **(1) 适用引用**\n1. **函数参数传递**：\n   - 使用引用避免拷贝实参，提高性能。\n   - 常用于不需要修改参数的地方（`const` 引用）。\n   ```cpp\n   void print(const int& x) {\n       std::cout << x << std::endl;\n   }\n   ```\n\n2. **返回值**：\n   - 返回引用允许函数直接返回变量本身，而不是拷贝。\n   ```cpp\n   int& getValue(int& a) {\n       return a;\n   }\n   ```\n\n3. **别名**：\n   - 为变量创建更简化的别名。\n   ```cpp\n   int a = 42;\n   int& alias = a;  // alias 是 a 的别名\n   ```\n\n#### **(2) 适用指针**\n1. **动态内存管理**：\n   - 使用指针分配和释放动态内存。\n   ```cpp\n   int* ptr = new int(10);\n   delete ptr;  // 手动释放内存\n   ```\n\n2. **数组与迭代**：\n   - 指针常用来访问数组元素。\n   ```cpp\n   int arr[3] = {1, 2, 3};\n   for (int* ptr = arr; ptr < arr + 3; ++ptr) {\n       std::cout << *ptr << \" \";\n   }\n   ```\n\n3. **数据结构**：\n   - 指针是数据结构（如链表、树）的核心基础。\n   ```cpp\n   struct Node {\n       int data;\n       Node* next;\n   };\n   ```\n\n4. **需要动态改变指向时**：\n   - 指针可以灵活地改变指向，适合需要频繁切换指向的场景。\n\n---\n\n### **5. 总结对比**\n\n| 特征               | 引用           | 指针                      |\n| ------------------ | -------------- | ------------------------- |\n| **需要初始化**     | 必须初始化     | 可以先声明后初始化        |\n| **是否可以为空**   | 不可以为空     | 可以是空指针（`nullptr`） |\n| **绑定是否可更改** | 绑定后不可更改 | 可通过重新赋值更改指向    |\n| **语法复杂度**     | 更简单         | 更复杂，需要使用 `*` 号   |\n| **灵活性**         | 受限           | 更灵活                    |\n| **常见场景**       | 函数传参、别名 | 动态内存、复杂结构        |\n\n引用更简单、更安全，适合大多数普通变量操作；指针更灵活，适合动态内存和复杂结构的场景。在实际开发中，应根据场景和需求选择适合的工具。"},{"title":"红黑树","url":"/2025/09/10/红黑树/","content":"\n## 红黑树\n\n### 基本规则：\n\n**隐藏的空节点是黑色**\n\n满足Avl树\n\n根节点和叶子节点都是黑色\n\n不能有连续两个红色节点\n\n从根节点到叶子节点的每个路径上黑色节点数量都一致\n\n### 插入：\n\n插入节点是根节点；直接变黑\n\n插入节点的叔叔是红色；叔父爷爷变色，爷爷变插入节点继续调整\n\n插入节点的叔叔是黑 ；（LL，RL，LR，RL）旋转，然后变色\n\n[红黑树 - 定义, 插入, 构建_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Xm421x7Lg/?spm_id_from=333.337.search-card.all.click&vd_source=07ce431f0897d40efe75d8ff3761e5f6)"},{"title":"金山C++研发实习生面试准备","url":"/2025/09/10/金山C++研发实习生面试准备/","content":"\n# 金山C++研发实习生面试准备\n\n1.自我介绍\n2.拷打项目\n\n3.拷打八股：\n\n4.多态的实现\n\n### 5.静态多态和动态多态\n\n静态多态是指在编译时多态，动态多态是指运行时多态\n\n静态多态有函数重载（函数名相同，参数不同，返回值相同或不同），函数模板\n\n动态多态（动态绑定）：即运行时的多态，在程序执行期间(非编译期)判断所引用对象的实际类型，根据其实际类型调用相应的方法。\n\n\n\n### 6.动态多态怎么实现的\n\n### 动态多态\n\n通过每个类的虚函数和动态绑定\n\n派生类实现动态绑定\n\n- 先拷贝基类的虚函数表\n- 如果派生类重写了基类的某个虚函数，就用派生类的虚函数替换虚表同位置的基类虚函数\n- 跟上派生类自己的虚函数\n\n\n\n指向基类的指针或引用\n\n动态多态需要通过指向基类的 **指针或引用** 操作派生类对象。如果直接操作派生对象，则是静态绑定，而非动态绑定。\n\n\n\n### 7.介绍一下虚函数表和虚指针\n\n虚函数表和虚指针是由**编译器**生成并使用的，它们是实现 **动态绑定** 和运行时多态的核心。\n\n虚函数表是一种由编译器生成的 **隐藏数据结构**，它是一个函数指针数组，用来存储类中所有虚函数的地址。简单来说，虚函数表就是一个指针数组，每个元素指向一个虚函数的具体实现。\n\n\n\n虚指针是一个 **隐藏成员变量**，存在于每个包含虚函数的类的对象中。虚指针用于指向当前对象所属类的虚函数表。\n\n### 8.说一下构造函数和析构函数在父类和子类的执行顺序\n\n- **构造函数顺序**：\n  **父类构造函数** → **成员对象的构造函数** → **子类构造函数**\n- **析构函数顺序**：\n  **子类析构函数** → **成员对象的析构函数** → **父类析构函数**\n\n### 9.析构函数的作用\n\n析构函数用于释放对象占用的资源（如内存、文件句柄等），在对象生命周期结束时自动调用，确保资源不会泄漏。\n\n### 10.为什么析构函数通常定义为虚函数；不调用析构函数会怎样\n\n- **原因**：\n  若父类指针指向子类对象，且父类析构函数非虚，则通过父类指针删除对象时，只会调用父类析构函数，导致子类资源泄漏。\n- **后果**：\n  不调用析构函数会导致资源泄漏（如内存、文件句柄未释放）。\n\n### 11.结构体为何通常要进行内存对齐；一般是几字节对齐\n\n为了提高访问效率，为了时内存命中访问效率更高\n\n**对齐原则**\n\n结构体的内存对齐通常遵循以下原则：\n\n1. 每个成员变量的起始地址必须是其自身大小的整数倍\n2. 结构体本身的大小必须是其最大对齐系数（对齐要求）的整数倍\n\n\n\n### 12.new/delete和malloc/free的区别\n\n| 特性             | `new/delete`                      | `malloc/free`             |\n| ---------------- | --------------------------------- | ------------------------- |\n| **语言特性支持** | C++ 专有                          | C 风格（C 和 C++ 均支持） |\n| **类型安全**     | 是                                | 否（需要手动类型转换）    |\n| **初始化支持**   | 自动调用构造函数和析构函数        | 不调用，需要手动处理      |\n| **异常处理**     | 内存分配失败抛出 `std::bad_alloc` | 内存分配失败返回 `NULL`   |\n| **灵活性**       | 适合对象管理和复杂场景            | 适合简单的POD或跨语言     |\n| **效率**         | 稍有额外开销（构造/析构函数调用） | 相对高效                  |\n\n**什么时候选择哪一个？**\n\n**使用 `new/delete`：**\n\n- 在C++程序中，需要创建具有构造函数和析构函数的复杂对象。\n- 希望利用类型安全和异常处理机制，提高代码的健壮性。\n- 更偏向于面向对象的编程风格。\n\n**使用 `malloc/free`：**\n\n- 在C语言程序中，或者需要与 C 的库/代码接口。\n- 需要跨语言兼容时（如 C 和 C++ 混合开发）。\n- 只操作简单的内存（非对象）时，比如使用裸内存块或数组。\n\n**总结**\n\n1. `new` 和 `delete` 是C++中的语法糖，功能更强大，更贴合现代编程需求。\n2. `malloc` 和 `free` 是底层内存管理工具，适合裸内存分配。\n3. 在C++开发中，通常推荐优先使用 `new` 和 `delete`，除非有特殊需要才选择 `malloc` 和 `free`。\n\n\n\n### 13.什么情况用mmap()\n\n`mmap()` 是一个 POSIX 标准的内存映射函数，通常用于将文件或设备映射到进程虚拟内存空间中，使得我们可以通过内存访问文件内容，大大提高了 I/O 的效率。它的使用场景主要集中在对文件的高效访问、大文件处理、共享内存以及特殊的内存管理需求等。以下是 `mmap()` 的典型使用情况、优缺点以及示例解释。\n\n\n\n1.高效文件访问，减少内核态和用户态之间的拷贝开销\n\n2.处理大文件，将文件内容按需映射到虚拟内存中\n\n3.共享内存（进程间通信）\n\n- `mmap()` 支持使用 `MAP_SHARED` 标志创建共享内存，多个进程可以操作同一内存区域进行通信。\n- 使用共享内存比使用消息队列、管道等传统 IPC 机制有更高的效率。\n\n4.文件修改或写入（内存作为缓冲区）适用于需要高效更新大文件的场景\n\n5.实现内存映射I/O\n\n6.异步I/O和并行处理\n\n\n\n\n\n使用 `mmap()` 的场景主要是权衡性能与开销，以下是具体选择标准：\n\n1. **适合用 `mmap()` 的场景**：\n   - 需要频繁随机访问大文件。\n   - 文件的内容按需加载，不需要一次性加载到内存。\n   - 多进程需要共享文件或内存。\n   - 操作设备文件或硬件寄存器。\n   - 文件访问频繁，且希望减少用户态与内核态之间频繁的数据拷贝。\n2. **不太适合用 `mmap()` 的场景**：\n   - 操作小文件，或者一次性读取整个文件，不需要复杂的随机访问。\n   - 文件处理逻辑非常简单，而 `mmap()` 的复用性和管理开销反而适得其反。\n   - 跨平台兼容需求非常高的场景。\n\n\n\n### 14.动态链接库用的brk()还是mmap()\n\n| 特性               | `brk()`        | `mmap()`                          |\n| ------------------ | -------------- | --------------------------------- |\n| **内存范围**       | 紧跟数据段末尾 | 任意空闲的虚拟地址空间            |\n| **按需加载**       | 不支持         | 支持                              |\n| **分页分配**       | 不支持         | 支持，以页为单位分配和管理        |\n| **碎片问题**       | 容易引发堆碎片 | 避免堆碎片，内存管理灵活          |\n| **共享内存**       | 不支持         | 支持共享内存（`MAP_SHARED` 标志） |\n| **动态链接库加载** | 不适用         | 是动态链接库的默认选择            |\n\n因此，动态链接库的加载和运行使用 `mmap()` 是最佳选择，它为动态链接库的按需加载、多进程共享、独立管理以及性能优化提供了完美支持。同时，`brk()` 由于其限制，已不适用于动态库加载。\n\n\n\n### 15.动态链接和静态链接的区别\n\n\n\n| 特性                     | 静态链接                                 | 动态链接                             |\n| ------------------------ | ---------------------------------------- | ------------------------------------ |\n| **生成的可执行文件体积** | 较大，库代码直接嵌入                     | 较小，仅包含对动态库的引用           |\n| **运行时依赖**           | 不依赖外部库，所有代码都在一个文件中     | 依赖外部库，运行时需要动态加载       |\n| **运行时性能**           | 加载速度快，无需加载外部库               | 加载速度稍慢，需要动态加载符号解析   |\n| **内存使用**             | 每个程序独立占用一份库的内存             | 多个程序共享同一个库，节省内存       |\n| **更新方式**             | 更新程序需要重新编译并链接静态库         | 可以通过更新库文件，无需重新编译程序 |\n| **跨平台兼容性**         | 静态库只与编译平台相关，适合封装依赖     | 动态库可能与运行时环境、平台设置相关 |\n| **调试难度**             | 相对简单，因为库已集成进可执行文件       | 调试更复杂，可能需要检查多个动态库   |\n| **符号冲突问题**         | 不会出现符号冲突，代码已固定             | 有可能发生符号冲突，需要小心处理     |\n| **磁盘存储**             | 每个可执行文件都包含完整的库代码         | 动态库存储独立，节省磁盘空间         |\n| **维护与分发**           | 更新程序和库需要重新分发完整的可执行文件 | 库文件可以单独更新，减少分发工作量   |\n\n### 16.红黑树特性；有哪些应用\n\n- **特性**：\n  1. 每个节点是红或黑。\n  2. 根节点和叶子节点（NIL）是黑。\n  3. 红节点的子节点必为黑。\n  4. 从任一节点到其叶子节点的路径包含相同数量的黑节点。\n- **应用**：\n  C++ STL `map`/`set`、Java `TreeMap`、Linux 内核调度器等。\n\n### 17.死锁的必要条件有哪些\n\n1. **互斥**：资源只能被一个进程占用。\n2. **持有并等待**：进程持有资源并等待其他资源。\n3. **不可抢占**：资源只能由持有者主动释放。\n4. **循环等待**：存在进程资源的环形等待链。\n\n### 18.线程安全实现方式\n\n1. **互斥锁（Mutex）**：保证临界区代码原子性。\n2. **原子操作（Atomic）**：通过硬件支持的原子指令（如 CAS）。\n3. **无锁编程**：如使用无锁数据结构。\n4. **线程局部存储（TLS）**：避免共享数据。\n5. **读写锁（Read-Write Lock）**：区分读/写操作。\n6. **条件变量（Condition Variable）**：线程间同步。\n\n"},{"title":"Docker Desktop 修改安装位置-CSDN博客","url":"/2025/09/10/Docker Desktop 修改安装位置-CSDN博客/","content":"\n[Win11 安装 Docker Desktop 和 WSL2 并进行安装位置迁移_windows 11 wsl 修改安装位置-CSDN博客](https://blog.csdn.net/cn_ljr/article/details/132047516)\n\n迁移docker"},{"title":"WSl从本机复制文件到wsl","url":"/2025/09/10/WSl从本机复制文件到wsl/","content":"\n\n\n## WSl从本机复制文件到wsl\n\n\n\n```bash\nsudo ls /mnt/*\n```\n\n"},{"title":"docker上传文件至容器","url":"/2025/09/10/docker上传文件至容器/","content":"\ndocker上传文件至容器\n\n#### 拿到容器ID\n\n```bash\ndocker ps -a\n```\n\n#### 将本地文件上传到容器的指定目录中\n\n```bash\ndocker cp 本地文件路径 ID全称:容器路径\n```\n\n```bash\ndocker cp /home/stydent/EdgeGPT /usr/local/lib/python3.11/site-packages\n```\n\n```bash\nsudo docker cp fbf56805d23a:/usr/local/lib/python3.11/site-packages ./site-packages\n```\n\n"},{"title":"docker遇到的问题","url":"/2025/09/10/docker遇到的问题/","content":"\n拉取镜像失败是网络问题，先看网络\n\n\n\n\n\ndocker命令报错error during connect: Get http://2F2F.2Fpipe2Fdocker_engine/v1.36/containers/json: open//.\n\n在清理docker时遇到\n\n```powershell\n docker system prune\n```\n\n原因是docker无法挂载到wsl上\n\n因为刚刚执行压缩命令占用了vhdx文件，不能把docker文件关联上\n\n关机重启就好\n\n```powershell\n docker system prune\nWARNING! This will remove:\n  - all stopped containers\n  - all networks not used by at least one container\n  - all dangling images\n  - unused build cache\n\nAre you sure you want to continue? [y/N] y\nTotal reclaimed space: 0B\n```\n\n"},{"title":"ngnix实现共享文件","url":"/2025/09/10/ngnix实现共享文件/","content":"\n# ngnix实现共享文件\n\n乱码解决\n\n```shell\nserver和loaction层都加上\ncharset utf-8\n```\n\n### 配置 Nginx\n\n```shell\nsudo vi /etc/nginx/sites-enabled/default\n```\n\n### 验证配置\n\n```cobol\nsudo nginx -t\nnginx: the configuration file /etc/nginx/nginx.conf syntax is ok\nnginx: configuration file /etc/nginx/nginx.conf test is successful\n```\n\n这样测试说明 nginx 配置是正确的。\n\n### 重启启动 nginx 服务\n\n```crystal\nsudo service nginx restart\n```\n\n权限问题\n\n要求权限是755才能正常访问\n\n```shell\nchmod -R 755 xmal/\n```\n\n"},{"title":"openvpn","url":"/2025/09/10/openvpn/","content":"\nopenvpn\n\n下载\n\n```bash\nwget -O openvpn.sh https://get.vpnsetup.net/ovpn\n```\n\n安装\n\n```bash\nsudo bash openvpn.sh --auto\n```\n\n启动\n\n```bash\nsudo bash openvpn.sh\n```\n\n"},{"title":"system初始化问题","url":"/2025/09/10/system初始化问题/","content":"\nSystem has not been booted with systemd as init system (PID 1). Can't operate.\nFailed to connect to bus: Host is down\n\n\n\n翻译过来就是：“[系统](https://so.csdn.net/so/search?q=系统&spm=1001.2101.3001.7020)尚未以systemd作为初始系统启动”。\n\n### 问题分析：\n\n1）当你尝试使用 systemd 命令来管理 Linux 系统上的服务的时候，之所以会报错，可能因为系统中根本就没有使用 systemd，而是使用的 SysV init (sysvinit)。\n\n2）如果你是在 windows 中通过 [WSL](https://so.csdn.net/so/search?q=WSL&spm=1001.2101.3001.7020) 使用的 Ubuntu 或者 Dibian 系统，默认情况下系统使用的是 SysV 而不是 systemd。"},{"title":"windows安装python2环境","url":"/2025/09/10/windows安装python2环境/","content":"\n#### windows安装python2环境\n\n![image-20240918205426825](C:/Users/86147/AppData/Roaming/Typora/typora-user-images/image-20240918205426825.png)\n\n安装在D盘后，不用管最后这个，之后配置环境变量\n\n![image-20240918205806490](C:/Users/86147/AppData/Roaming/Typora/typora-user-images/image-20240918205806490.png)\n\n![image-20240918210154534](C:/Users/86147/AppData/Roaming/Typora/typora-user-images/image-20240918210154534.png)\n\n把这两个目录添加到环境变量，之后再修改文件夹中python.exe为python2.exe"},{"title":"wsl2安装启动mysql","url":"/2025/09/10/wsl2安装启动mysql/","content":"\n**wsl2安装启动mysql**\n\n启动\n\n```bash\n sudo /etc/init.d/mysql start\n```\n\n配置文件\n\n```bash\nsudo cat /etc/mysql/debian.cnf\n```\n\n用户名密码就在这\n\n```mysql\n[client]\nhost     = localhost\n\n```\n\n复制到用户名文件夹可以免输入用户名密码\n\n```bash\nsudo cp /etc/mysql/debian.cnf .my.cnf\n```\n\n要改变文件的所有者为用户\n\n```ba\nsudo chown cgz .my.cnf\n```\n\n\n\n\n\n遇到报错\n\n```bash\nERROR 2002 (HY000): Can't connect to local MySQL server through socket '/var/run/mysqld/mysqld.sock' (2)\n```\n\n问题就是没启动\n\n运行上面的启动命令就行\n\n```bash\nroot 的密码: 123456\n```\n\n```bash\nALTER USER 'root'@'localhost' IDENTIFIED BY '123456';\n```\n\n```bash\nCREATE USER 'mufeng'@'%' IDENTIFIED BY '123456';\n```\n\n"},{"title":"wsl的代理如何与主机共享","url":"/2025/09/10/wsl的代理如何与主机共享/","content":"\nwsl的代理如何与主机共享\n\n需要拉取docker镜像，但是curl无效\n\n设置配置文件.wslconfig后仍然ping不通\n\nping，ping的是ip，用的是icmp协议，在osi七层模型中用的是第三层（网络层）\n\n\n\n其实是curl google.com\n\n直接得到的就是\n\n```xml\n<HTML><HEAD><meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\">\n<TITLE>301 Moved</TITLE></HEAD><BODY>\n<H1>301 Moved</H1>\nThe document has moved\n<A HREF=\"http://www.google.com/\">here</A>.\n</BODY></HTML>\n```\n\n用浏览器访问一下就知道了\n\n```bash\n curl https://www.google.com.hk/  \n```\n\n这个才是正确的\n\n"},{"title":"在VSCode中打开WSL2项目时，Copilot扩展没有响应","url":"/2025/09/10/在VSCode中打开WSL2项目时，Copilot扩展没有响应/","content":"\n在VSCode中打开WSL2项目时，Copilot扩展没有响应\n\n\n\n添加`setting.json`\n\n```json\n \"remote.extensionKind\": {\n        \"GitHub.copilot\": [\"ui\"],\n        \"GitHub.copilot-chat\": [\"ui\"]\n }\n```\n\n\n\n[VSCode で WSL2 プロジェクトを開くと Copilot 拡張機能が応答しない #copilot - Qiita](https://qiita.com/1000k/items/8446c344f3823b04db47)\n\n[github - Copilot is not working is WSL remote connection? - Stack Overflow](https://stackoverflow.com/questions/78719710/copilot-is-not-working-is-wsl-remote-connection)"},{"title":"在使用wsl时，突然不能用code打开vscode","url":"/2025/09/10/在使用wsl时，突然不能用code打开vscode/","content":"\n## 在使用wsl时，突然不能用`code`打开`vscode`\n\n加一行配置环境变量可以解决\n\n```bash\nexport PATH=\"$PATH:/mnt/c/Users/86147/AppData/Local/Programs/Microsoft VS Code/bin\"\n```\n\n但是不够优雅\n\n在 `/etc/wsl.conf` 中明确追加 PATH 配置\n\n```\n[interop]\nappendWindowsPath = true\n```\n\n设置完以上方法后，发现还是一样因为本来就默认共享环境变量\n\n\n\n发现vscode文件路径名称**有空格**\n\nwsl执行\n\n```bash\necho $PATH\n```\n\n出现\n\n```bash\n/mnt/c/Users/86147/AppData/Local/Programs/Microsoft:VS:Code/bin\n```\n\n空格被识别成分割\n\n所以可能是更新后路径名出现了这个bug导致无法正常识别环境变量\n\n### 解决方案是用短路径\n\nWindows 文件系统有短路径名（8.3 格式）支持，通常无空格，可以兼容在 WSL 和 Windows 下使用。你可以先找到短路径名，然后将其添加到环境变量中。\n\n1. **获取短路径名**： 打开 Windows 命令提示符（cmd），输入以下命令以获取 `Microsoft VS Code` 文件夹的短路径名：\n\n   ```bash\n   cmd\n   \n   dir \"C:\\Users\\86147\\AppData\\Local\\Programs\\\" /x\n   ```\n\n   你可能会看到一行输出类似：\n\n   ```bash\n   03/12/2024  09:00 AM    <DIR>          MICRO~1    Microsoft VS Code\n   ```\n\n   `MICRO~1` 就是此文件夹的短路径名。用这个名字可以避免空格问题。\n\n2. **将短路径名添加到 PATH**： 在 Windows 的环境变量设置中，将 VS Code 的路径设置为短路径格式。例如，将路径设置为：\n\n   ```bash\n   C:\\Users\\86147\\AppData\\Local\\Programs\\MICRO~1\\bin\n   ```\n\n   在 WSL 中，这个路径会自动被映射到 `/mnt/c/Users/86147/AppData/Local/Programs/MICRO~1/bin`，WSL 能正确解析。"},{"title":"安装虚拟python环境，采用轻量化的方案","url":"/2025/09/10/安装虚拟python环境，采用轻量化的方案/","content":"\n## 安装虚拟python环境，采用轻量化的方案\n\n创建一个轻量化的 Python 虚拟环境可以通过 `venv` 或 `virtualenv` 实现。这里我将介绍使用 `venv` 的方法，因为它是 Python 自带的模块，并且通常更简单。以下步骤适用于基于 Debian 的 Linux 发行版（例如 Ubuntu 和 WSL 的 Ubuntu 版本）。\n\n### 1. 安装 Python 和 venv\n\n确保你安装了 Python 和 `venv` 模块。在大多数情况下，Python 会默认包含 `venv` 模块，但你可以通过以下命令确认：\n\n```bash\nsudo apt update\nsudo apt install python3 python3-venv\n```\n\n### 2. 创建虚拟环境\n\n选择一个目录来存放你的虚拟环境，例如在你的项目文件夹中。\n\n```bash\ncd /path/to/your/project\npython3 -m venv myenv\n```\n\n将 `myenv` 替换为你希望给虚拟环境起的名字。\n\n### 3. 激活虚拟环境\n\n激活虚拟环境，以便你在这个环境中安装的任何 Python 包都不会影响系统的全局 Python 设置。\n\n```bash\nsource myenv/bin/activate\n```\n\n当虚拟环境激活后，你的命令行提示符通常会显示环境名称，例如 `(myenv)`。\n\n### 4. 安装所需的包\n\n在激活的虚拟环境中，你可以使用 `pip` 安装任何你需要的 Python 包。例如，安装 `requests` 库：\n\n```bash\npip install requests\n```\n\n### 5. 清理不必要的包\n\n如果你希望保持环境轻量化，可以在使用完后移除不再需要的包。可以使用以下命令检查已安装的包：\n\n```bash\npip list\n```\n\n并使用以下命令卸载不需要的包：\n\n```bash\npip uninstall package_name\n```\n\n### 6. 退出虚拟环境\n\n完成工作后，可以通过以下命令退出虚拟环境：\n\n```bash\ndeactivate\n```\n\n### 总结\n\n通过以上步骤，你可以创建一个轻量化的 Python 虚拟环境，并在其中安装所需的包。`venv` 提供了一个相对简单的方式来管理项目所需的依赖，同时保持系统 Python 环境的干净。在项目开发和测试中使用虚拟环境是良好的实践。"},{"title":"清理wsl磁盘空间","url":"/2025/09/10/清理wsl磁盘空间/","content":"\n# 清理wsl磁盘空间\n\n### 先以管理员身份运行powershell\n\n```cmd\ndiskpart\n```\n\n### 查看wsl发行版本\n\n```powershell\n wsl -l  -v\n```\n\n ```bash\n  NAME              STATE           VERSION\n \n * Ubuntu-22.04      Stopped         2\n   docker-desktop    Stopped         2\n ```\n\n### 查找 Linux 发行版的 *.vhdx* 文件和目录路径，\n\n请打开 PowerShell 并使用以下脚本，将 `<distribution-name>` 替换为实际的发行版名称：\n\n```powershell\n(Get-ChildItem -Path HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Lxss | Where-Object { $_.GetValue(\"DistributionName\") -eq '<Ubuntu-22.04>' }).GetValue(\"BasePath\") + \"\\ext4.vhdx\"\n```\n\n结果将显示类似于 `%LOCALAPPDATA%\\Packages\\<PackageFamilyName>\\LocalState\\<disk>.vhdx` 的路径。 例如：\n\n```powershell\nC:\\Users\\86147\\AppData\\Local\\Packages\\CanonicalGroupLimited.Ubuntu22.04LTS_79rhkp1fndgsc\\LocalState\\ext4.vhdx\n```\n\n这是与你列出的 Linux 发行版关联的 `ext4.vhdx` 文件的路径。\n\n\n\n先关掉\n\n```powershell\nwsl --shutdown\n```\n\n### 压缩磁盘文件\n\n```powershell\n//4-3 依次输入下列命令\n//选择目标磁盘文件\ndiskpart\n\nselect vdisk file=\"C:\\Users\\86147\\AppData\\Local\\Packages\\CanonicalGroupLimited.Ubuntu22.04LTS_79rhkp1fndgsc\\LocalState\\ext4.vhdx\"\n//以只读模式连接虚拟磁盘文件\nattach vdisk readonly\n\n//开始压缩虚拟磁盘文件\ncompact vdisk\n\n//分离虚拟磁盘文件\ndetach vdisk\n\n//退出diskpart工具\nexit\n```\n\n\n\n\n\n显示与此虚拟磁盘关联的详细信息，包括**虚拟大小**，表示当前分配给 VHD 的大小上限\n\n```cmd\ndetail vdisk\n```\n\n\n\n扩展空间\n\n[如何管理 WSL 磁盘空间 | Microsoft Learn](https://learn.microsoft.com/zh-cn/windows/wsl/disk-space#how-to-locate-the-vhdx-file-and-disk-path-for-your-linux-distribution)\n\n# 清理docker\n\n[Windows WSL2 占用磁盘空间清理释放_wsl占用空间太大-CSDN博客](https://blog.csdn.net/arvinrong/article/details/135723290)\n\n```powershell\ndocker system prune\nWARNING! This will remove:\n  - all stopped containers\n  - all networks not used by at least one container\n  - all dangling images\n  - unused build cache\n\nAre you sure you want to continue? [y/N] y\nTotal reclaimed space: 0B\n```\n\n"},{"title":"连接问题","url":"/2025/09/10/连接问题/","content":"\n```BASH\nSocket error Event: 32 Error: 10053.\nConnection closing...Socket close.\n\nConnection closed by foreign host.\n```\n\n用手机连热点遇到的问题\n\n推测不是负载过高导致的\n\n\n\n端口：22，用手机和电脑上xshell连接有问题\n\n刚进的时候可以，但是输入两到三行命令后会突然退出显示以上报错\n\n\n\n排除xshell问题，因为手机端也不能正常连接\n\n猜想排除网络问题，因为用4g网络，5g网络，wifi，都会出现以上情况\n\n不是ip冲突导致的\n\n\n\n输入last命令后\n\n```bash\nLast login: Wed Jun 26 00:23:36 2024 from 223.104.40.248\nstydent@nihao:~$ last\nstydent  pts/0        223.104.40.248   Wed Jun 26 00:30   still logged in\nstydent  pts/0        223.104.40.248   Wed Jun 26 00:23 - 00:24  (00:00)\nstydent  pts/0        223.104.40.248   Wed Jun 26 00:16 - 00:17  (00:00)\nstydent  pts/0        223.104.40.248   Wed Jun 26 00:09 - 00:10  (00:00)\nstydent  pts/0        223.104.40.248   Wed Jun 26 00:02 - 00:03  (00:00)\nstydent  pts/0        120.244.62.97    Tue Jun 25 23:20 - 23:21  (00:00)\nstydent  pts/0        223.104.40.248   Tue Jun 25 16:23 - 16:32  (00:09)\nstydent  pts/1        223.104.40.248   Tue Jun 25 16:16 - 16:25  (00:08)\nstydent  pts/0        223.104.40.248   Tue Jun 25 16:10 - 16:19  (00:08)\nstydent  pts/0        223.104.40.248   Tue Jun 25 16:02 - 16:09  (00:06)\nstydent  pts/0        223.104.40.248   Tue Jun 25 15:55 - 15:58  (00:03)\nstydent  pts/2        223.104.40.248   Tue Jun 25 15:32 - 15:46  (00:14)\nstydent  pts/1        120.244.62.221   Tue Jun 25 14:56 - 15:38  (00:42)\nstydent  pts/0        120.244.62.221   Tue Jun 25 14:55 - 15:36  (00:40)\nreboot   system boot  5.15.0-1064-azur Tue Jun 25 14:53   still running\n```\n\n更换ip后依然不行，停止后重启暂时修复\n\n\n\n启动机器人后突然挂掉，应该是负载问题\n\n真相了\n\n**连接校园网就没问题**\n\n**应该是手机热点导致的ip冲突**\n\n\n\n**彻底真相了**\n\n```bash\nlastb\n```\n\n随便截取一些记录\n\n```bash\nuser     ssh:notty    43.134.171.154   Tue Jun 25 16:03 - 16:03  (00:00)\nuser     ssh:notty    43.134.171.154   Tue Jun 25 16:03 - 16:03  (00:00)\nroot     ssh:notty    43.163.200.19    Tue Jun 25 16:03 - 16:03  (00:00)\noracle   ssh:notty    43.163.247.189   Tue Jun 25 16:03 - 16:03  (00:00)\noracle   ssh:notty    43.163.247.189   Tue Jun 25 16:02 - 16:02  (00:00)\nroot     ssh:notty    105.28.108.165   Tue Jun 25 16:02 - 16:02  (00:00)\ndaniel   ssh:notty    201.234.7.122    Tue Jun 25 16:02 - 16:02  (00:00)\ndaniel   ssh:notty    201.234.7.122    Tue Jun 25 16:02 - 16:02  (00:00)\ntest     ssh:notty    43.134.171.154   Tue Jun 25 16:02 - 16:02  (00:00)\ntest     ssh:notty    43.134.171.154   Tue Jun 25 16:02 - 16:02  (00:00)\nroot     ssh:notty    43.163.200.19    Tue Jun 25 16:02 - 16:02  (00:00)\ndaniel   ssh:notty    43.163.247.189   Tue Jun 25 16:02 - 16:02  (00:00)\ndaniel   ssh:notty    43.163.247.189   Tue Jun 25 16:02 - 16:02  (00:00)\nubuntu   ssh:notty    43.163.200.19    Tue Jun 25 16:01 - 16:01  (00:00)\nroot     ssh:notty    201.234.7.122    Tue Jun 25 16:01 - 16:01  (00:00)\nroot     ssh:notty    105.28.108.165   Tue Jun 25 16:01 - 16:01  (00:00)\nubuntu   ssh:notty    43.163.200.19    Tue Jun 25 16:01 - 16:01  (00:00)\nroot     ssh:notty    43.134.171.154   Tue Jun 25 16:01 - 16:01  (00:00)\nroot     ssh:notty    43.163.247.189   Tue Jun 25 16:01 - 16:01  (00:00)\nroot     ssh:notty    43.163.200.19    Tue Jun 25 16:00 - 16:00  (00:00)\nroot     ssh:notty    43.134.171.154   Tue Jun 25 16:00 - 16:00  (00:00)\nroot     ssh:notty    201.234.7.122    Tue Jun 25 16:00 - 16:00  (00:00)\nroot     ssh:notty    43.163.247.189   Tue Jun 25 15:59 - 15:59  (00:00)\nroot     ssh:notty    105.28.108.165   Tue Jun 25 15:59 - 15:59  (00:00)\nroot     ssh:notty    140.246.109.211  Tue Jun 25 15:57 - 15:57  (00:00)\nAdmin    ssh:notty    43.163.200.19    Tue Jun 25 15:56 - 15:56  (00:00)\n```\n\n看1panel的ssh登录日志，发现有两千多条和我无关的ip尝试登录，估计是被挤占的\n\n[linux问题解决：多种方法处理ssh暴力攻击_sshd:all:deny-CSDN博客](https://blog.csdn.net/qq_45698148/article/details/120229559)\n\n"},{"title":"配置zsh遇到的问题","url":"/2025/09/10/配置zsh遇到的问题/","content":"\n### 配置zsh遇到的问题\n\n今天打开wsl，发现外观莫名其妙全变了，修改powershell的外观设置后，发现zsh的命令行颜色怎么改还是舒服，文件夹是蓝底白字的，想修改成蓝底黑字，网上搜索之后发现并没有关于配置文件的教程\n\n我就又去查找了我安装的主题p10k,找到了这篇博客，[powerlevel10k 颜色和图标的自定义设置-CSDN博客](https://blog.csdn.net/qq_36835255/article/details/128101588#:~:text=DIR是段的名称，B)\n\n打开`~/.p10k.zsh`搜索关键词`DIR`\n\n```bash\n############################[ dir: 当前目录 ]###########################\n# 当前目录的背景色。\ntypeset -g POWERLEVEL9K_DIR_BACKGROUND=4\n\n# 当前目录的默认前景色。\ntypeset -g POWERLEVEL9K_DIR_FOREGROUND=232\n\n# 如果目录过长，缩短其中一些段为最短的唯一前缀。缩短后的目录仍可通过 Tab 键补全为原来的完整路径。\ntypeset -g POWERLEVEL9K_SHORTEN_STRATEGY=truncate_to_unique\n\n# 用此符号替换被移除的目录段后缀。\ntypeset -g POWERLEVEL9K_SHORTEN_DELIMITER=\n\n# 缩短后的目录段的颜色。\ntypeset -g POWERLEVEL9K_DIR_SHORTENED_FOREGROUND=232\n\n# 锚点目录段的颜色。锚点段永远不会被缩短。第一个段始终是锚点。\ntypeset -g POWERLEVEL9K_DIR_ANCHOR_FOREGROUND=232\n\n# 将锚点目录段以加粗方式显示。\ntypeset -g POWERLEVEL9K_DIR_ANCHOR_BOLD=true\n```\n\n注释交给gpt翻译了一下，修改即可\n\n按照上面教程的方法，颜色代码可以输入以下命令查看\n\n```bash\nfor code ({000..255}) print -P -- \"$code: %F{$code}最左侧三位数字即颜色值Text Color%f\"\n```\n\n**每次修改配置后一定要输入**\n\n```bash\nsource ~/.p10k.zsh\n```\n\n\n\n修改之后遇到问题，发现缩短后的锚点文件夹不能加粗显示，修改配置文件也不行。\n\n经检查发现是powershell外观配置问题，把`外观->文本格式`强调文本格式部分设置成加粗字体即可\n\n\n\n还有一个意外发现就是在复制上面配置文件时，发现vim不能和windows共享剪贴板\n\n于是搜索得到以下解决方案\n\n[clipboard - How to copy/paste from Vim in WSL - Stack Overflow](https://stackoverflow.com/questions/61550552/how-to-copy-paste-from-vim-in-wsl)\n\n1.按`v`进入可视模式，滑动鼠标或者输入行数选中\n\n2.按`:`，输入以下命令即可\n\n```bash\n:'<,'>w !clip.exe\n```\n\n如果要复制全部文本则直接输入该命令\n\n```bash\n:w !clip.exe\n```\n\n\n\n"},{"title":"09-并发控制","url":"/2025/09/10/09-并发控制/","content":"\n## 09-并发控制：同步\n\n希望可以控制顺序\n\n- 控制并发，使得 “两个或两个以上随时间变化的量在变化过程中保持一定的相对关系”\n\n1.开始同时执行\n\n2.最后等待同时执行\n\n互相已知\n\n\n\n从一个简单状态到另一个简单状态（状态分支聚起来）\n\n简单->复杂->简单........\n\n\n\n先到先等，先完成等待\n\nsync\n\n每个线程都有`wait_next_beat`等待下一个拍子再执行\n\n```c\nvoid wait_next_beat() {\nretry:\n    if (!next_beat_has_come) {\n        goto retry;\n    }\n```\n\n同步（synchronization）指的是多个线程在执行时保持协调，以确保它们在预期的时间点上执行特定的操作。具体来说，这里的同步是指：\n\n1. **开始时间一致**：确保某些操作在多个线程中同时开始。例如，[`wait_next_beat`](vscode-file://vscode-app/c:/Users/86147/AppData/Local/Programs/Microsoft VS Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.esm.html) 函数确保 [`T_player`](vscode-file://vscode-app/c:/Users/86147/AppData/Local/Programs/Microsoft VS Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.esm.html) 线程在预期的节拍时开始播放音符。\n2. **协调执行**：确保线程在执行过程中保持协调。例如，[`release_beat`](vscode-file://vscode-app/c:/Users/86147/AppData/Local/Programs/Microsoft VS Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.esm.html) 函数由 [`T_conductor`](vscode-file://vscode-app/c:/Users/86147/AppData/Local/Programs/Microsoft VS Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.esm.html) 线程调用，以通知 [`T_player`](vscode-file://vscode-app/c:/Users/86147/AppData/Local/Programs/Microsoft VS Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.esm.html) 线程可以继续到下一个节拍。\n\n在这个代码中，[`T_conductor`](vscode-file://vscode-app/c:/Users/86147/AppData/Local/Programs/Microsoft VS Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.esm.html) 线程通过调用 [`release_beat`](vscode-file://vscode-app/c:/Users/86147/AppData/Local/Programs/Microsoft VS Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.esm.html) 来增加节拍计数 [`n`](vscode-file://vscode-app/c:/Users/86147/AppData/Local/Programs/Microsoft VS Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.esm.html)，而 [`T_player`](vscode-file://vscode-app/c:/Users/86147/AppData/Local/Programs/Microsoft VS Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.esm.html) 线程通过 [`wait_next_beat`](vscode-file://vscode-app/c:/Users/86147/AppData/Local/Programs/Microsoft VS Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.esm.html) 来等待节拍计数达到预期值，从而实现同步。\n\n\n\n\n\n## 生产者-消费者问题\n\n共享缓冲区\n\n打印左括号的条件：缓冲区未满就可以\n\n打印右括号的条件：当前有左括号就可以\n\n\n\n等到达成同步条件再执行\n\n错误1：ready是共享变量，可能已经在解锁时被其他线程改变了\n\n```c\nvoid T_produce() {\n    while (1) {\nretry:\n        mutex_lock(&lk);\n        int ready = (depth < n);\n        mutex_unlock(&lk);\n        if (!ready) goto retry;\n\t\t\n        // assert(depth < n);\n\n        mutex_lock(&lk);\n        printf(\"(\");\n        depth++;\n        mutex_unlock(&lk);\n    }\n}\n```\n\n正确:但是如果条件不满足，就会不断锁上再解锁，浪费资源\n\n```c\nvoid T_produce(){\n\twhile(1){\nretry:\n        mutex_lock(&lk);\n        if(!(deepth < n)){\n\t\t\tmutex_unlock(&lk);\n           \tgoto retry;\n        }\n    \n    \tassert(depth < n);\n\n        printf(\"(\");\n        depth++;\n        mutex_unlock(&lk);\n    }\n}\n```\n\n条件变量\n\n```c\n#define CANPRODUCE (depth < n)\n#define CANCONSUME (depth > 0)\n```\n\n不符合条件时，睡眠，等待被唤醒\n\n生产者和消费者是两个不同的线程\n\n所以以下是错误的，因为生产者和消费者的条件变量不相同，唤醒不一定满足自己的条件，所以会使断言不一定正确（详见ostep）\n\n```c\nvoid T_produce() {\n    while (1) {\n        mutex_lock(&lk);\n        if (!CAN_PRODUCE) {\n            cond_wait(&cv, &lk);\n        }\n       // assert(CAN_PRODUCE);\n        printf(\"(\");\n        depth++;\n\n        cond_signal(&cv);\n        mutex_unlock(&lk);\n    }\n}\n```\n\n\n\n条件变量的正确使用，每次改动后都通知所有线程\n\n```c\nmutex_lock(&mutex);\nwhile (!COND)\n{  \n    wait(&cv, &mutex); \n} \nassert(cond);\n...\nmutex_unlock(&mutex); \n```\n\n\n\n\n\n并行编程的本质\n\n\n\n把任务分解\n\n生成有向无环图\n\n并行计算，每个节点满足条件就计算\n\n拓扑排序，计算\n\n\n\n打印鱼\n\n把状态图画出来，根据状态图得到条件\n\n```c\nconst char roles[] = \".<<<<<<<>>>>>>>______\";\n//每个线程获得一个字符，如果太少就不能等到下一个状态，就会阻塞\nvoid fish_thread(int id) {\n    char role = roles[id];\n    while (1) {\n        mutex_lock(&lk);\n        while (!can_print(role)) {\n            cond_wait(&cv, &lk);\n        }\n\n        putchar(role); // Not lock-protected\n\n        current = next(role);\n        assert(current);\n        cond_broadcast(&cv);\n        mutex_unlock(&lk);\n    }\n}\n```\n\n\n\n"},{"title":"10-并发控制同步","url":"/2025/09/10/10-并发控制同步/","content":"\n## 10-并发控制：同步 (2)\n\n可以用互斥锁来实现同步\n\n在约定的状态上锁，然后同时解锁\n\n（mutex库规定不能在一个线程获得锁，在另一个线程释放锁）\n\n初始时都上锁，等待就是请求锁，\n\n\n\n##  (信号量)P是取，V是放\n\n拓展互斥锁，多个\n\nhappens-before\n\nacquire-release\n\n口袋和球，如果是一个球，那就是互斥锁\n\n\n\n**适用于可计数的资源**\n\n可以创建n个口袋\n\n 信号量用来实现生产者消费者\n\n\n\n**哲学家吃饭问题**\n\n刚开始的实现，简单使用信号量表示叉子，会出现死锁，即哲学家都拿起左手边的叉子或右手边的叉子，然后桌子上没有叉子，也没人放下\n\n而用条件变量可以简单解决这个问题（哲学家会同时拿起或放下两只手的叉子）\n\n\n\n信号量解决方法：\n\n赶走桌子上的一个人，哲学家取到一个球才能上桌吃饭，吃完饭放回\n\n但是问题更复杂，要求更多就很难了\n\n给叉子编号也行，\n\n**条件变量是万能模板**\n\n  \n\n\n\n#### 用信号量实现条件变量\n\n该例子是一个生产者一个消费者，缓冲区是1，如果缓冲区很大这个问题就会被忽视了，如果生产者和消费者数量增加，那么死锁概率也会增加\n\n```c\n//错误的\nvoid wait(struct condvar *cv, mutex_t *mutex){\n    mutex_lock(&cv -> lock);\n    cv -> nwait++;\n    mutex_unlock(&cv -> lock);\n//理想状态是球在生产者和消费者之间传递    \n    mutex_unlock(mutex);\n    //但是如果在这里broadcast抢占，先唤醒了，然后nwait=0了，\n    //就相当于唤醒了另一个同样是生产者或者是消费者线程甚至是自己把球抢走了，再检查条件再进入wait,但是没有线程再放球了就会死锁\n    P(&cv -> sleep);//这个睡眠和解锁顺序不能更改\n    \n    \n    mutex_lock(mutex);\n}\n```\n\n问题\n\n```c\n//Producer: Broadcast\nConsumer: begin, execution count: 1449\nConsumer: Waiting\nwaiting at 32\nProducer: begin, execution count: 1450\n(\ndepth = 1\n//nwait: 1\n//broadcast end\n//Producer: Broadcast\nProducer: begin, execution count: 1451\nProducer: Waiting\nwaiting at 32\nwaiting out\nProducer: Waiting\nwaiting at 32\n```\n\n现在的问题是，为什么前一个线程执行完的broadcast后，新建的produce线程为什么球会取走，不应该是执行完一个线程再执行同一种线程吗，而且例子中只有一个生产者和一个消费者，缓冲区大小为1\n\n```c\nProducer: begin, execution count: 14397\n(\ndepth = 1\n\t//Producer: Broadcast\n\t//start broadcast\nnwait: 0\n\t//broadcast end\n\t\t//Consumer: Broadcast\nProducer: begin, execution count: 14398\nProducer: Waiting\nin wait nwait: 1\nwaiting at 32\n\t\t//start broadcast\nnwait: 1\nwaiting out\nProducer: Waiting\n\t\t//broadcast end\nin wait nwait: 1\nwaiting at 32\nConsumer: begin, execution count: 14399\n)\ndepth = 0\n//Consumer: Broadcast\n//start broadcast\nnwait: 1\nbroadcast end\nConsumer: begin, execution count: 14400\nConsumer: Waiting\nin wait nwait: 1\nwaiting at 32\nwaiting out\nConsumer: Waiting\nin wait nwait: 2\nwaiting at 32\n```\n\n"},{"title":"12-并发 Bugs (死锁、数据竞争、原子性顺序违反)","url":"/2025/09/10/12-并发 Bugs (死锁、数据竞争、原子性顺序违反)/","content":"\n## 12-并发 Bugs (死锁、数据竞争、原子性/顺序违反)\n\n\n\n死锁产生的必要条件\n\n\n\n- Atomicity violation，本应原子完成不被打断的代码被打断\n- Order violation，本应按某个顺序完成的未能被正确同步\n\nABA\n\n例如mysql里的解引用指针和将指针置为空的两个线程，也是一种数据\n"},{"title":"13-应对并发 Bugs (动态程序分析：应对死锁、死局和死线)","url":"/2025/09/10/13-应对并发 Bugs (动态程序分析：应对死锁、死局和死线)/","content":"\n## 13-应对并发 Bugs (动态程序分析：应对死锁、死局和死线)\n\n#### 运行时lock ordering检查（动态分析）\n\n应对死锁，给锁编号，构建图\n\n形成环，就有循环等待，就有可能死锁\n\n对上锁的顺序进行一个闭包运算\n\n\n\n同一行分配的锁就是同一个锁（近似）\n\n#### data race\n\n基本原理就是不同线程对同一变量，至少有一个是写操作\n\n编译加`-fsanitize=thread`线程消毒器"},{"title":"14-操作系统上的进程 (forkexecveexit)","url":"/2025/09/10/14-操作系统上的进程 (forkexecveexit)/","content":"\n### 14-操作系统上的进程 (fork/execve/exit)\n\n### 立即复制状态机\n\n- 包括\n\n  所有\n\n  信息的完整拷贝\n\n  - 每一个字节的内存\n  - 打开的文件 (共享)\n  - ……\n  - 复制失败返回 -1\n    - errno 会返回错误原因 (man fork)\n\n### 如何区分两个状态机？\n\n- 新创建进程返回 0\n- 执行 fork 的进程返回子进程的进程号\n\n系统调用的返回值放在rax中\n\n\n\n```bash\nf(){\n\tf | f &\n}\nf\n```\n\n\n\n`printf`缓冲区在每一个进程的内存里，fork会一起复制\n\n遇到了粘贴时乱码问题\n\n\n\n\n\n\n\n`execve`把当前的进程重置成一个可执行文件描述状态机的初始状态\n\n第三个参数是环境变量\n\n`fork`默认直接把环境变量会继承\n\nstrace的使用\n\n`./demo`当前目录下的程序"},{"title":"15-(入侵) 进程的地址空间","url":"/2025/09/10/15-(入侵) 进程的地址空间/","content":"\n### 15-(入侵) 进程的地址空间\n\n状态机里有什么\n\nregisters\n\nmemory\n\ngdb就可以暂停查看\n\n```bash\nfa1e0ff3\n```\n\n```bash\nf3 0f 1e fa\n```\n\n在内存中显示以小端为首\n\n\n\n地址空间是否可读写\n\n在`proc/pid/maps`里都给出了，连续的一段一段的,每一段都给出了权限\n\n```bash\n564af047d000-564af0494000 r--p 00000000 08:20 31005                      /usr/bin/zsh\n564af0494000-564af0552000 r-xp 00017000 08:20 31005                      /usr/bin/zsh\n564af0552000-564af056d000 r--p 000d5000 08:20 31005                      /usr/bin/zsh\n564af056d000-564af056f000 r--p 000ef000 08:20 31005                      /usr/bin/zsh\n564af056f000-564af0575000 rw-p 000f1000 08:20 31005                      /usr/bin/zsh\n```\n\n更可读\n\n```bash\npmap [pid]\n```\n\n创建不同的数组，分配的内存是不一样的\n\n在栈上，在堆上，\n\n不进入内核的系统调用`gettimeofday(2)`\n\n从操作系统读数据\n\n\n\n只有`syscall`指令可以改变地址空间（增删改）\n\n看看`man 5 proc`手册\n\n\n\n\n\n  mmap可以分配内存，控制权限\n\n\n\npython执行时遇到`ModuleNotFoundError: No module named 'hexdump'0`\n\n原因是`sudo`执行时的环境变量不一样\n\nwsl显示全为0\n\n\n\ngdb调试，可以把要调试的程序的内存空间放进自己的内存空间\n\n\n\n##### 变速齿轮\n\nhook，劫持相关代码\n\n"},{"title":"16-系统调用和 UNIX Shell (pipe; xv6 shell)","url":"/2025/09/10/16-系统调用和 UNIX Shell (pipe; xv6 shell)/","content":"\n## 16-系统调用和 UNIX Shell (pipe; xv6 shell) \n\n虚拟化，syscall\n\n#### 操作系统对象：文件和设备，\n\n指针只能指向程序的内存空间\n\n指向操作系统对象的指针（就是文件描述符），在linux中`everything is a file`\n\n访问对象用指针`open, close,read/write(解引用),lseek,dup等`\n\n**复习指针**\n\nwindows中文件描述符时handle，句柄\n\n\n\n#### 管道，IPC\n\n写口，读口\n\n管道是进程之间的同步机制\n\n通信不仅可以用来传送数据，还可以用来同步\n\n**匿名管道**\n\n```bash\npipefd[0] refers to the read  end  of the  pipe.  pipefd[1] refers to the write end  of the  pipe.\n```\n\n`fork`复制时，管道也被复制了\n\n指针也完成了浅拷贝\n\n\n\n\n\n`shell`连接I/O设备和人\n\n`<(command)`把命令变成文件\n\n\n\n`ctrl + z`切换后台\n\n`jobs`查看后台，`fg %1`切换后台到前台\n\n\n\n\n\n`shell`可以调用syscall\n\n\n\n"},{"title":"19-可执行文件：静态链接和加载","url":"/2025/09/10/19-可执行文件：静态链接和加载/","content":"\n# 19-可执行文件：静态链接和加载\n\nexecve（加载）把当前的进程重置成指定可执行文件的初始状态\n\n可执行文件：一个状态机初始状态的数据结构\n\n里面规定了加载该可执行文件后地址空间里该有什么数据（寄存器，代码段等）\n\n状态：内存和寄存器\n\n\n\nelf为了性能丧失了阅读友好性\n\n`magic number`是什么\n\n`Magic number一般是指硬写到代码里的整数常量，数值是编程者自己指定的，其他人不知道数值有什么具体意义，表示不明觉厉，就称作magic number。`\n\n\n\n`a.out`\n\n设计一个可读的可执行文件，需要什么（代码，符号，重定位）\n\n**FLE 加载器：只做一件事**\n\n- 将一段字节序列复制到地址空间中\n  - 赋予可读、可写、可执行权限\n- 然后跳转到 _start 执行\n\n**ELF 并没有多做多少**\n\n- 将多段字节序列复制到地址空间中\n  - **分别**赋予可读/可写/可执行权限\n- 然后跳转到指定的 entry (默认为 _start) 执行\n\n\n\n`#!/bin/bash  `\n\n```bash\n#!A B C\nTHIS\n```\n\n`argc[0] = A`\n\n`argv[1] = B C`\n\n`argv[2]`该 程序的名称\n\n\n\n\n\n"},{"title":"17-C 标准库设计与实现 (_start; offsetof; printf; environ; mallocfree)","url":"/2025/09/10/17-C 标准库设计与实现 (_start; offsetof; printf; environ; mallocfree)/","content":"\n#### 17-C 标准库设计与实现 (_start; offsetof; printf; environ; malloc/free)\n\npipe,就是生产者消费者\n\n看`man 7 pipe`\n\n操作系统把硬件虚拟化成系统调用，对象+API\n\n\n\n```bash\necho $(which musl-gcc)\n```\n\n "},{"title":"20-动态链接和加载","url":"/2025/09/10/20-动态链接和加载/","content":"\n# 20-动态链接和加载 \n\nlibc.o静态链接\n\n容易浪费空间\n\nlibc.so动态链接\n\n生成位置无关代码，使用中间的table存放函数地址\n\n借助编译器完成\n\n\n\n用多个线程链接库，验证只有一个副本\n\n是链接的同一份\n\n\n\n地址空间是怎么分配的（虚拟内存）\n\n## 动态链接（查表）   \n\n![image-20241207160836673](C:/Users/86147/AppData/Roaming/Typora/typora-user-images/image-20241207160836673.png)\n\n编译时，函数调用  = 查表(把函数调用替换成查表)\n\n编译时，动态链接库调用 = 查表 \n\n```\ncall  *TABLE[printf@symtab] \n```\n\n链接时，收集所有符号，**“生成” 符号信息和相关代码**：\n\n```c\n#define foo@symtab     1\n#define printf@symtab  2 \n... \nvoid *TABLE[N_SYMBOLS]; \nvoid load(struct loader *ld) {    \n    TABLE[foo@symtab] = ld->resolve(\"foo\");    \n    TABLE[foo@printf] = ld->resolve(\"printf\");    \n    ... \n} \n```\n\n![image-20241208152058135](C:/Users/86147/AppData/Roaming/Typora/typora-user-images/image-20241208152058135.png)\n\n```assembly\nLOAD(\"libc.dl\")\nLOAD(\"libhello.dl\")\nIMPORT(hello)\nIMPORT(exit)\nEXPORT(_start)\n```\n\n`gdb`过程dlbox main.s\n\n加载符号表，递归调用`dlopen`,调用`libc.dl`，导出符号，\n\n`putchar`,`exit`填到全局的符号表，\n\n解析第二个符号，`libhello.dl`\n\n....\n\n动态解析`hello`,hello不在main.dl里，是?\n\n调用`dlsym`检查符号表，找到hello把地址填入符号表\n\n\n\n执行`DSYM(exit)`\n\n```c\n  #define DSYM(sym)   *sym(%rip)\n```\n\n找到空位把符号填入符号表\n\n\n\n前面的存放地址和函数名的表项，就是 **GOT (Global Offset Table)**\n\n\n\n因为call 的偏移量是64位，跳不到远处\n\n所以使用plt,作为中转，先跳到plt中，plt中存放GOT对应函数的地址\n\n再次跳转到对应函数\n\n![image-20241208121223400](C:/Users/86147/AppData/Roaming/Typora/typora-user-images/image-20241208121223400.png)\n\n数据的链接，plt怎么解决数据链接的问题\n\n<img src=\"C:/Users/86147/AppData/Roaming/Typora/typora-user-images/image-20241208171116351.png\" alt=\"image-20241208171116351\" style=\"zoom:33%;\" />\n\n`get_x`会查表\n\n`get_y`直接得到地址（hidden）\n\n编译器默认`extern`变量来自另外一个共享库单元（保守）\n\n<img src=\"C:/Users/86147/AppData/Roaming/Typora/typora-user-images/image-20241208181848498.png\" alt=\"image-20241208181848498\" style=\"zoom:33%;\" />\n\ngpt对objdump反汇编的分析\n\n**总结**\n\n1. **变量 `x`**：\n   - 默认可见性（`visibility(\"default\")`）。\n   - 使用 `mov` 指令，通过符号表获取地址。\n   - 可被其他模块或共享库访问。\n2. **变量 `y`**：\n   - 隐藏可见性（`visibility(\"hidden\")`）。\n   - 使用 `lea` 指令，直接计算地址，无需符号表查找。\n   - 仅在当前模块内部可见，无法被外部访问。\n3. **性能影响**：\n   - 隐藏符号（`y`）链接效率更高，因为不需要符号表查找。\n   - 默认可见性符号（`x`）灵活性更强，但动态链接时可能会引入额外开销。"},{"title":"22-进程的实现 (虚拟地址空间；UNIX 和 xv6)","url":"/2025/09/10/22-进程的实现 (虚拟地址空间；UNIX 和 xv6)/","content":"\n# 22-进程的实现 (虚拟地址空间；UNIX 和 xv6)\n\n1024叉树\n\n32bit，10bit+10bit+12bit，12bit放访问信息\n\n一个4KB页面,一个放一个4B的指针，总共2^1024\n\n绝大部分节点都是空的,下一层也类似（局部性原理）\n\n\n\n64bit，4KB的页面，一项8B，总共有512项，不是很整齐\n\n\n\n\n\n映射不需要先载入，只需要一个数据结构记录访问权限\n\n到用指针访问时，发生缺页中断，如果合法访问，则改变f，映射一页\n\n\n\n指针单点访问地址空间，一段时间后就能记录哪里能访问，哪里不能访问，把不能访问的释放掉，放到磁盘上\n\nswap机制，闲置页面放到磁盘上，释放内存\n\n可以使所有进程使用的内存总和比物理内存大\n\n\n\n## fork系统调用\n\nfork() 在进行状态机复制时，虽然理论上需要做出完整的状态复制，但本着 “复制的数据可能立即被浪费掉” 的观察，操作系统希望只在 “不得不复制” 时才复制。\n\n现代操作系统会维护页面的共享情况，并在 fork 后将父子进程的地址空间都标记为 read-only，而当双方中的任何一个进程写入发生 page fault 时，才复制一页。对于连续的 fork()，则会产生多个进程共享页面的情况。\n\n \n\n服务器的容错，可以用fork以很小的代价做快照\n\n\n\n  \n"},{"title":"21-系统调用、中断和上下文切换","url":"/2025/09/10/21-系统调用、中断和上下文切换/","content":"\n# 21-系统调用、中断和上下文切换\n\n动态链接，`stderr`和`int x`的调用\n\n\n\n处理器和中断\n\n中断和系统调用都是跳转到某段操作系统代码\n\n`syscall`的代码顺带关中断，节省一条指令\n\n与掩码（MASK）相与可以清零指定位\n\n  "},{"title":"23-处理器调度 (xv6 上下文切换；处理器调度：机制和策略)","url":"/2025/09/10/23-处理器调度 (xv6 上下文切换；处理器调度：机制和策略)/","content":"\n# 23-处理器调度 (xv6 上下文切换；处理器调度：机制和策略)\n\n由用户态，执行syscall\n\n跳转到内核态代码，寄存器保存，切换页表和栈\n\n\n\n调度策略\n\n```bash\ntaskset -c 3 nice -n 19 yes > /dev/null & taskset -c 3 nice -n 9 yes > /dev/null \n```\n\nnice值相差10，占用cpu时间相差1倍\n\n\n\n上下文切换是机制，策略是选择哪个进程执行\n\n\n\n动态优先级，CPU密集型的优先级逐渐降低，交互型的优先级逐渐增加\n\n*动态优先级实现的虚拟时间是什么原理，为什么“好人”和“坏人”会相差几倍*\n\n进程的**nice值越小**（优先级越高），**权重越大**，在实际运行时间相同的情况下，**虚拟运行时间越短**，进程累计的虚拟运行时间**增加得越慢**，在红黑树中**向右移动的速度越慢**，被调度器选中的**机会越大**，被分配的运行**时间相对越多**。随着优先级高进程的虚拟运行时间增长，低优先级的进程也会有机会被调度\n\n```c\n/*\n * Nice levels are multiplicative, with a gentle 10% change for every\n * nice level changed. I.e. when a CPU-bound task goes from nice 0 to\n * nice 1, it will get ~10% less CPU time than another CPU-bound task\n * that remained on nice 0.\n *\n * The \"10% effect\" is relative and cumulative: from _any_ nice level,\n * if you go up 1 level, it's -10% CPU usage, if you go down 1 level\n * it's +10% CPU usage. (to achieve that we use a multiplier of 1.25.\n * If a task goes up by ~10% and another task goes down by ~10% then\n * the relative distance between them is ~25%.)\n */\nstatic const int prio_to_weight[40] = {\n /* -20 */     88761,     71755,     56483,     46273,     36291,\n /* -15 */     29154,     23254,     18705,     14949,     11916,\n /* -10 */      9548,      7620,      6100,      4904,      3906,\n /*  -5 */      3121,      2501,      1991,      1586,      1277,\n /*   0 */      1024,       820,       655,       526,       423,\n /*   5 */       335,       272,       215,       172,       137,\n /*  10 */       110,        87,        70,        56,        45,\n /*  15 */        36,        29,        23,        18,        15,\n};\n\n```\n\n[Linux CFS调度器 vruntime 的计算_linux vruntime-CSDN博客](https://blog.csdn.net/weixin_45030965/article/details/128566265)\n\nCFS，完全公平调度，记录每个进程运行时间，每次都切换到运行时间最少的进程。\n\n红黑树\n\n\n\n"},{"title":"24-状态机模型的应用 (图灵机、Game of Life、状态机思想","url":"/2025/09/10/24-状态机模型的应用 (图灵机、Game of Life、状态机思想/","content":"\n# 24-状态机模型的应用 (图灵机、Game of Life、状态机思想\n\n\n\n要实现状态机的退回\n\n只需要记录“不确定因素”，syscall的前后diff就可以\n\n其他寄存器变化都是固定的\n\n"},{"title":"6.s081debug kernel","url":"/2025/09/10/6.s081debug kernel/","content":"\n6.s081debug kernel\n\n在vscode配置好后无法debug用户程序，不能打断点\n\n在debug console执行-exec file user/_ls \n\n[qemu-gdb debug指南之can not access memory解决！ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/356316638)\n\n当你的xv6 kernel已经运行起来的时候， 你想往一个[用户程序](https://zhida.zhihu.com/search?content_id=167311109&content_type=Article&match_order=1&q=用户程序&zhida_source=entity)打断点，你只能先加载他的[符号表](https://zhida.zhihu.com/search?content_id=167311109&content_type=Article&match_order=1&q=符号表&zhida_source=entity)，然后将断点打在main函数的入口，然后在xv6 调用该程序，触发main函数断点，然后才可以在任意一行打断点。记住顺序不能乱。\n\n\n\n解决方案，先暂停程序，然后在debug console中输入\n\n```bash\n-exec file user/_ \n```\n\n加载该程序文件，然后打断点，运行程序debug","categories":["C++"]},{"title":"=运算符重载","url":"/2025/09/10/=运算符重载/","content":"\n```cpp\nPolynomial& Polynomial::operator=(const Polynomial& p){\n\t\tif(this == &p) return *this;\n\t\tdelete[] coefficients;\n\t\tsize = p.size;\n\t\tcoefficients = new double[size];\n\t\tfor(int i = 0; i < size; i++){\n\t\t\tcoefficients[i] = p.coefficients[i];\n\t\t}\n\t\treturn *this;\n}\n```\n\n多项式类的赋值\n\n要考虑 **a = b = c** 这种情况，所以返回**reference**类型","categories":["C++"]},{"title":"C++部分知识点","url":"/2025/09/10/C++部分知识点/","content":"\n## 关于inline函数\n\n```cpp\nclass Person\n{\npublic:\n\tPerson(const string &name)\n\t{\n\t\tName = name;\n\t}\n    void printName();\n\t//在类里面没有显式声明\nprivate:\n\tstring Name;\n};\nvoid Person::printName()//不是内联函数\n{//在类外面也没有显式定义\n\tcout << Name << endl;\n}\n```\n\n[C++类里面的哪些成员函数是内联函数？_操作符函数是内联的吗-CSDN博客](https://blog.csdn.net/qq_18343569/article/details/83755202)\n\n## 关于友元类和友元函数\n\n- 友元关系是单向的，不具有交换性。\n\n- 友元关系不能传递\n\n- 友元关系不能被继承，但对已有的方法来说访问权限不改变。\n\n- 类A把类B声明为友元类，在前面要有前置声明\n\n- 类A把类B中的函数声明为友元函数，在类A之前必须有类B的完整定义\n\n  ```cpp\n  class Date; // 前置声明\n  class Time\n  {\n      friend class Date; \n      // 声明日期类为时间类的友元类，则在日期类中就直接访问Time类中的私有成员变量\n  public:\n      Time(int hour, int minute, int second): _hour(hour), _minute(minute), _second(second)\n      {}\n   \n  private:\n      int _hour;\n      int _minute;\n      int _second;\n  };\n   \n  class Date\n  {\n  public:\n      Date(int year = 1900, int month = 1, int day = 1): _year(year),                                     \n      _month(month),_day(day)\n      {}\n      void SetTimeOfDate(int hour, int minute, int second)\n      {\n          // 直接访问时间类私有的成员变量\n          _t._hour = hour;\n          _t._minute = minute;\n          _t.second = second;\n      }\n  private:\n      int _year;\n      int _month;\n      int _day;\n      Time _t;\n  };\n  ```\n\n  重载输出运算符设置为全局函数\n\n**为什么输出运算符重载不能是一个成员函数?而非得声明为友元？**\n原因如下：\n\n```csharp\n 返回值 operator运算符(参数列表){}\n```\n\n重载运算符时，函数声明在类内和类外是有区别的，比方说 + - * / 等需要2个操作数的运算符，当声明在类的外部时，则参数列表为2个参数，第一个参数为运算符左边的操作数，而第二个参数为操作符右边的操作数：如下\n\n```csharp\nclassType operator+(classType& left, classType& right);\n```\n\n而当函数声明在类的内部时，即为类的成员函数时，\n\n```csharp\nclassType operator+(classType& right );\n```\n\n而**第一个操作数就是调用该操作符的对象的引用**，**第二个操作数是传进来的参数**，所以，如果要重载<<运算符，一般写法是这样的\n\n```csharp\nostream& operator<<(ostream& os, const classType& obj);\n```\n\n则**第一个参数是该运算符的第一个操作数，然而，却不是类对象**，\n所以当该类运算符重载时写在类的内部时，又为了访问类内除public外的其它变量或函数\n\n[C++中友元函数和成员函数的区别-CSDN博客](https://blog.csdn.net/dandanzmc/article/details/11660897)\n\n\n\n## 关于protected和private\n\n在C++中，`private`和`protected`是两种不同的访问修饰符，它们控制类成员的访问权限。\n\n- `private`：私有成员只能被该类的成员函数和友元函数访问，不能被该类的对象或者任何其他类访问。\n- `protected`：受保护成员可以被该类的成员函数、该类派生出的子类的成员函数以及友元函数访问，但不能被该类的对象访问。\n\n在你的代码中，`object`类的成员`a`是私有的，所以它只能被`object`类的成员函数和友元函数访问。如果你想让`a`能被`object`类派生出的子类访问，你应该将`a`声明为受保护的，例如：\n\n```cpp\nclass object {\npublic:\n    object() {\n        a = 0;\n    }\nprotected:\n    int a;\n};\n```\n\n在这个例子中，`a`是受保护的，所以它可以被`object`类的成员函数、`object`类派生出的子类的成员函数以及友元函数访问。\n\n## 虚函数和static互斥,static函数也不能加const\n\n#### 虚函数\n\n- **与对象关联**：虚函数是与具体的对象实例关联的，它们通过对象的虚函数表（vtbl）实现动态绑定。\n- **需要对象上下文**：调用虚函数时，需要知道具体对象的类型，以便调用正确的函数实现。这需要通过`this`指针来访问对象的状态和虚函数表。\n\n#### 静态成员函数\n\n- **与类关联**：静态成员函数是与类本身关联的，而不是与具体的对象实例关联的。\n- **没有对象上下文**：静态成员函数没有`this`指针，不能访问对象的非静态成员或虚函数表，因为它们在类层次上调用，而不是通过对象。\n\n#### 简单总结\n\n- **虚函数**：需要对象实例来确定调用哪个函数实现。\n- **静态成员函数**：不依赖任何对象实例，只能访问类的静态成员。\n\n由于虚函数依赖于对象的上下文，而静态成员函数没有对象上下文，因此它们不能结合在一起使用。虚函数需要对象实例和虚函数表，而静态成员函数不具备这些特性，因此它们是互斥的。\n\n#### 为何static成员函数不能为const函数 \n\n当声明一个非静态成员函数为const时，对this指针会有影响。对于一个Test类中的const修饰的成员函数，this指针相当于Test const *, 而对于非const成员函数，this指针相当于Test *.  而static成员函数没有this指针，所以使用const来修饰static成员函数没有任何意义。  volatile的道理也是如此。\n\n## 关于new运算符\n\nnew运算符做的三件事：获得一块内存空间、调用构造函数、返回正确的指针\n\n#### New运算符的使用方法：\n\n1、new() ：分配这种类型的一个大小的内存空间,并以括号中的值来初始化这个变量;\n\n2、 new[] ：分配这种类型的n个大小的内存空间,并用默认构造函数来初始化这些变量;  \n\nchar* p=new char[6];   strcpy(p,\"Hello\");\n\n3、当使用new运算符定义一个多维数组变量或数组对象时，它产生一个指向数组第一个元素的指针，返回的类型保持了除最左边维数外的所有维数。例如：  \n\n```cpp\nint *p1 = new int[10];\n\n返回的是一个指向int的指针int*  \n\nint (*p2)[10] = new int[2][10];\n\nnew了一个二维数组, 去掉最左边那一维[2], 剩下int[10], 所以返回的是一个指向int[10]这种一维数组的指针int (*)[10].  \n\nint (*p3)[2][10] = new int[5][2][10];\n\n new了一个三维数组, 去掉最左边那一维[5], 还有int[2][10], 所以返回的是一个指向二维数组int[2][10]这种类型的指针int (*)[2][10].\n```\n\n4、创建类对象\n\n1）new创建对象，pTest用来接收对象指针。new申请的对象，则只有调用到delete时才会执行析构函数，如果程序退出而没有执行delete则会造成内存泄漏：\n\nCTest*  pTest = new  CTest();  delete pTest;\n\n2）不用new，直接使用类定义申明，使用完后不需要手动释放，该类析构函数会自动执行：\n\nCTest  mTest;\n\n3）使用普通方式创建的类对象，在创建之初就已经分配了内存空间。而类指针，如果未经过对象初始化，则不需要delete释放：\n\nCTest*  pTest = NULL;\n\n## 作用域运算符::\n\n ::是运算符中等级最高的，它分为三种：全局作用域符，类作用域符，命名空间作用域符\n\n### 全局作用\n\n全局作用域符号：当全局变量在局部函数中与其中某个变量重名，那么就可以用::来区分如： \n\n```cpp\nchar zhou; //全局变量 \n　　void sleep（） \n　　{ \n　　char zhou; //局部变量 \n　　zhou(局部变量) = zhou(局部变量) *zhou(局部变量) ; \n　　::zhou(全局变量) =::zhou(全局变量) *zhou(局部变量); \n}\n```\n\n### 类作用\n\n作用域符号::的前面一般是类名称，后面一般是该类的成员名称，C++为了避免不同的类有名称相同的成员而采用作用域的方式进行区分\n　　如：A,B表示两个类，在A,B中都有成员member。那么\n　　A::member就表示类A中的成员member\n　　B::member就表示类B中的成员member\n\n### 命名空间\n\n\"::\"是作用域[限定符](http://baike.baidu.com/view/6987276.htm)或者称作用域运算符或者作用域操作符（scope operator）.例如命名空间\n\n\"::\"作用：\n\n```cpp\nnamespace::name\n```\n\n###   :: 的另一种用法\n\n  直接用在全局函数前，表示是全局函数。\n\n## 关于缺省值函数\n\n在C++中，函数形参的缺省值（默认值）有以下规则：\n\n缺省值必须从右向左连续设定。也就是说，如果一个参数有缺省值，那么它右边的所有参数都必须有缺省值。例如，以下函数声明是合法的：\n\n```cpp\nvoid fun(int x, int y = 1, int z = 2);\n```\n\n但是，以下函数声明是非法的，因为`y`有缺省值，但是它右边的参数`z`没有缺省值：\n\n```cpp\nvoid fun(int x, int y = 1, int z); // 非法\n```\n\n缺省值只能在函数声明时设定，不能在函数定义时设定。例如，以下代码是合法的：\n\n```cpp\n// 在函数声明时设定缺省值\nvoid fun(int x = 0);\n// 函数定义\nvoid fun(int x) {\n  // ...\n}\n但是，以下代码是非法的，因为缺省值在函数定义时设定：\n// 函数声明\nvoid fun(int x);\n// 在函数定义时设定缺省值\nvoid fun(int x = 0) { // 非法\n  // ...\n}\n```\n\n如果函数在同一作用域内多次声明，那么它的每个参数的缺省值最多只能设定一次。但是，如果函数在不同的作用域内声明，那么在不同的作用域内可以给同一个参数设定不同的缺省值。\n\n## 关于try和catch\n\n\n\n\n\n## 多态\n\n**动态多态**\n\n  运行时的多态存在于继承类中，通过虚函数现动态选择调用。\n\n**静态多态**\n\n  静态多态是发生在编译时期的，通过**模板和函数重载**实现，相比动态多态不需派生关系。\n\n\n\n## C++文件操作\n\n[C++文件操作（2023最新详解）-CSDN博客](https://blog.csdn.net/weixin_43256263/article/details/127502981)\n\n1、要打开一个输入文件流，需要定义一个 **ifstream**类型的对象。->Input-stream\n2、要打开一个输出文件流，需要定义一个 **ofstream**类型的对象。->Output-stream\n3、如果要打开输入输出文件流，则要定义一个 **fstream**类型的对象。->File-stream\n\n**这3种类型都定义在头文件 **fstream里\n\n```cpp\nofstream ofs;   \t\t  //2、打开一个相应的文件流\nofs.open(\"mytest.txt\");\t  //3、流与文件关联上\n```\n\n因为**ifstream**、**ofstream**和**fstream**这3个类都具有**自动打开文件的构造函数**，而这个构造函数就具有 **open()** 的功能。\n\n因此，我们可以在创建流对象的时候就可以关联文件：`ofstream myStream(\"myText.txt\");`\n\n**open函数的原型如下**：\n\n```cpp\nvoid open(char const *,int filemode,int =filebuf::openprot);\n```\n\n| ios::in     | 打开文件进行读操作，这种方式可避免删除现存文件的内容         |\n| ----------- | ------------------------------------------------------------ |\n| ios::out    | 打开文件进行写操作，这是默认模式                             |\n| ios::ate    | 打开一个已有的输入或输出文件并查找到文件尾开始               |\n| ios::app    | 在文件尾追加方式写文件                                       |\n| ios::binary | 指定文件以二进制方式打开，默认为文本方式                     |\n| ios::trunc  | 如文件存在，将其长度截断为零并清除原有内容，如果文件存在先删除，再创建 |\n\n\n\n\n\n\n\n## 三种继承\n\n### 1.公有继承–public:（原样复制）\n\n公有继承时，对基类的`公有成员和保护成员`的`访问属性不变`，派生类的新增成员只能访问基类的`公有成员和保护成员`**（都一样）**。派生类的对象`只能访问派生类的公有成员`（包括继承的公有成员），访问不了保护成员和私有成员**（公有继承的对象多了个访问继承的公有成员）**。\n\n### 2.保护继承–protected\n\n保护继承中，基类的`公有成员和保护成员`被派生类继承后变成`保护成员`，派生类的新增成员只能访问基类的`公有成员和保护成员`**（都一样）**，派生类的对象`只能访问派生类的公有成员`。\n\n### 3.私有继承–private\n\n私有继承时，基类的`公有成员和保护成员`都被派生类继承下来之后变成`私有成员`，派生类的新增成员只能访问基类的`公有成员和保护成员`**（都一样）**。派生类的对象`只能访问派生类的公有成员`**(这里和protected继承一样)**。\n\n## 关于多继承\n\n[C++多继承中的二义性问题_c++多重继承引起的二义性问题-CSDN博客](https://blog.csdn.net/buknow/article/details/80436010)\n\n#### 同名二义性\n\n一个子类继承两个有同名数据成员的父类\n\n#### 路径二义性\n\n一个子类继承两个父类，这两个父类又继承自同一个祖父类\n\n"},{"title":"class7自旋锁","url":"/2025/09/10/class7自旋锁/","content":"\n在class7的自旋锁多核启动失败，只能单cpu\n\n解决方法\n\n修改`/home/cgz/work/nju-os-workbench/abstract-machine/scripts/platform/qemu.mk`\n\n```makefile\n.PHONY: build-arg\n\nsmp        ?= 4//改这个\nLDFLAGS    += -N -Ttext-segment=0x00100000\nQEMU_FLAGS += -serial mon:stdio \\\n              -machine accel=tcg \\\n              -smp \"$(smp),cores=1,sockets=$(smp)\" \\//改这里的sockets和cores\n              -drive format=raw,file=$(IMAGE)\n\nbuild-arg: image\n\t@( echo -n $(mainargs); ) | dd if=/dev/stdin of=$(IMAGE) bs=512 count=2 seek=1 conv=notrunc status=none\n\nBOOT_HOME := $(AM_HOME)/am/src/x86/qemu/boot\n\nimage: $(IMAGE).elf\n\t@$(MAKE) -s -C $(BOOT_HOME)\n\t@echo + CREATE \"->\" $(IMAGE_REL)\n\t@( cat $(BOOT_HOME)/bootblock.o; head -c 1024 /dev/zero; cat $(IMAGE).elf ) > $(IMAGE)\n\n```\n\n"},{"title":"collect采用gpt生成，适用于mosaic结果的分析","url":"/2025/09/10/collect采用gpt生成，适用于mosaic结果的分析/","content":"\ncollect采用gpt生成，适用于mosaic结果的分析\n\n```bash\n#!/bin/bash\n\n# 从管道读取 JSON 格式输入\ninput=$(cat)\n\n# 检查 JSON 数据中是否包含 \"vertices\" 和 \"edges\"\nif ! echo \"$input\" | jq -e '.vertices and .edges' > /dev/null; then\n    echo \"Error: JSON input must contain 'vertices' and 'edges' arrays.\"\n    exit 1\nfi\n\n# 提取路径中的节点信息\npath=$(echo \"$input\" | jq -r '.vertices[-1].stdout')\n# 计算顶点 |V| 和边 |E| 数量\nnum_vertices=$(echo \"$input\" | jq '.vertices | length')\nnum_edges=$(echo \"$input\" | jq '.edges | length')\n\n# 生成唯一的输出计数\nunique_outputs=1\n\n# 输出格式\necho \"$path\"\necho \"|V| = $num_vertices, |E| = $num_edges.\"\necho \"There are $unique_outputs distinct outputs.\"\n```\n\n"},{"title":"gdbinit","url":"/2025/09/10/gdbinit/","content":"\n让gdb启动时就打开tui\n\n编写gdbinit文件\n\n![img](https://i-blog.csdnimg.cn/blog_migrate/3de5637f0c72114511dcd7d825934660.png)\n\n所以先在home目录下设置gdbinit\n\n然后执行\n\n```bash\nsource ~/.gdbinit\n```\n\n\n\n\n\n"},{"title":"hanoi","url":"/2025/09/10/hanoi/","content":"\nhanoi\n\n\n\n每个Frame（栈帧）都有自己的变量，pc是相互独立的，指示自身栈帧下一步要执行什么\n\n每次call，入栈，把pc置为0，在while(1)开头再指向top\n\n每次执行完case语句，都把pc加1，不一定是栈顶的\n\n\n\n把递归的分解为6步，逐步执行，case3移动一个不需要保存，在case6加1就行\n\n```c\nint hanoi(int n, char from, char to, char via) {\n    Frame stk[64];\n    Frame *top = stk - 1;\n\n    // Function call: push a new frame (PC=0) onto the stack\n    #define call(...) ({ *(++top) = (Frame){.pc = 0, __VA_ARGS__}; })\n    \n    // Function return: pop the top-most frame\n    #define ret(val) ({ top--; retval = (val); })\n\n\n    // The last function-return's value. It is not obvious\n    // that we only need one retval.\n    int retval = 0;\n\n    // The initial call to the recursive function\n    call(n, from, to, via);\n\n    while (1) {\n        // Fetch the top-most frame.\n        Frame *f = top;\n        printf(\"pc=%d\\n\",  f->pc);\n       \n       \n        if (top < stk) {\n           // No top-most frame any more; we're done.\n            break;\n        }\n\n        // Jumps may change this default next pc.\n        int next_pc = f->pc + 1;\n        \n        // Single step execution.\n\n        // Extract the parameters from the current frame. (It's\n        // generally a bad idea to reuse variable names in\n        // practice; but we did it here for readability.)\n        int n = f->n, from = f->from, to = f->to, via = f->via;\n        \n        switch (f->pc) {\n            case 0:\n                if (n == 1) {\n                    printf(\"%c -> %c\\n\", from, to);\n                    ret(1);\n                }\n                break;\n            case 1: call(n - 1, from, via, to); break;\n            case 2: f->c1 = retval; break;\n            case 3: call(1, from, to, via); break;\n            case 4: call(n - 1, via, to, from); break;\n            case 5: f->c2 = retval; break;\n            case 6: ret(f->c1 + f->c2 + 1); break;\n            default: assert(0);\n        }\n\n        f->pc = next_pc;\n    }\n\n    return retval;\n}\n```\n\n"},{"title":"ostep28.14使用pack和unpack","url":"/2025/09/10/ostep28.14使用pack和unpack/","content":"\n### ostep28.14使用pack和unpack\n\n存在自旋，但是自旋仅在guard保护修改flag和队列中，比用户的临界区短\n\n```c\n1  typedef struct __lock_t {\n2      int flag;\n3      int guard;\n4      queue_t *q;\n5  } lock_t;\n\n6  void lock_init(lock_t *m) {\n7      m->flag = 0;\n8      m->guard = 0;\n9      queue_init(m->q);\n10 }\n\n11 void lock(lock_t *m) {\n12     while (TestAndSet(&m->guard, 1) == 1) // acquire guard lock by spinning\n13         ; // 自旋直到获取到guard锁\n14     if (m->flag == 0) { // 如果flag为0，表示锁未被占用\n15         m->flag = 1; // 获取锁\n16         m->guard = 0; // 释放guard锁\n17     } else { // 锁已被占用\n18         queue_add(m->q, gettid()); // 将当前线程加入等待队列\n19         m->guard = 0; // 释放guard锁\n20         park(); // 将线程挂起，进入睡眠状态\n21     }\n22 }\n\n23 void unlock(lock_t *m) {\n24     while (TestAndSet(&m->guard, 1) == 1) // acquire guard lock by spinning\n25         ; // 自旋直到获取到guard锁\n26     if (queue_empty(m->q)) { // 如果队列为空，表示没有等待线程\n27         m->flag = 0; // 释放锁\n28     } else {\n29         unpark(queue_remove(m->q)); // 唤醒等待队列中的下一个线程\n30     }\n31     m->guard = 0; // 释放guard锁\n32 }\n```\n\nguard的作用是保护flag和队列的修改，flag保护临界区\n\n在unlock中，唤醒等待线程后，不需要设置flag=1,这样直接将锁从解锁的线程传给了被唤醒的线程。\n\n是的，在原文的代码实现中，线程被唤醒后就**直接进入临界区**\n\n\n\n\n\n存在的问题就是唤醒的丢失，因为A线程加入队列后如果切换到释放锁的线程B，线程B唤醒A后，A继续执行然后睡眠，但是此时等待队列已经没有A了，所以会造成死锁\n\n使用setpark,如果setpark后切换到另一个线程，调用unpark释放后，返回lock函数，pack会直接返回而不再睡眠\n\n```c\nvoid lock(lock_t *m) {\n    while (TestAndSet(&m->guard, 1) == 1)\n        ;  // 自旋等待获取guard锁\n    \n    if (m->flag == 0) {  // 如果锁未被占用\n        m->flag = 1;     // 获取锁\n        m->guard = 0;    // 释放guard锁\n    } else {             // 如果锁被占用\n        queue_add(m->q, gettid());  // 将当前线程加入等待队列\n        setpark();                  // 设置park状态，防止丢失唤醒\n        m->guard = 0;               // 释放guard锁\n        park();                     // 挂起线程，等待被唤醒\n        // 唤醒后继续执行\n    }\n}\n```\n\n"},{"title":"pstree","url":"/2025/09/10/pstree/","content":"\n1.解析参数\n\n2.创建根节点\n\n3.遍历进程文件建树，用read_proc_info读取父进程，创建节点\n\n```c\nchar name[100] = \"\\0\"; \n            pid_t p = 0; \n            pid_t pp = 0; \n            getPPid(stat_detail, &p, name, &pp);\n\n            ProcessNode* node = creatnode(name, p, pp);\n            ProcessNode* proc = process_table[pp];\n\n            \n            if(pp == 0)continue;//加上这一段就只能打印init\n\n            proc -> children[proc -> childrencount++] = node;\n```\n\n本意是想取掉一个多余的0号进程，不打印\n\n\n\n调试发现是出现了段错误，把print_tree改成打印table[0]就可以了\n\n具体错误有待查询\n\n\n\n\n\n打印节点\n\n加前缀\n\n```bash\ninit(Ubuntu-22.\n      ├──── init\n      ├──── SessionLeader\n      │     └──── Relay(17)\n      │           ├──── zsh\n      │           │     └──── pstree-64\n      │           ├──── zsh\n      │           │     └──── gitstatusd-linu\n      │           ├──── zsh\n      │           └──── zsh\n      └──── SessionLeader\n```\n\n分三种情况\n\n1.没有父进程，不加前缀\n\n2.有父进程，但没有兄弟进程或者是兄弟进程中的最后一个`└──── `\n\n3.有父进程，有兄弟进程，且不是最后一个`├────`\n\n根据深度，加`|`或者空格\n\n\n\n可以选择打印传入参数的子进程\n\n修改printf函数之后就可以了\n\n```c\nvoid print_tree(ProcessNode* node, int level,char* prefix) {\n    if (node -> childrencount == 0) return;\n\n    for(int i = 0;i < node -> childrencount;i++)\n    {   \n        \n        printf(\"%s\", prefix);//打印前缀\n        assert(node -> children[i] != NULL);\n         //printf(\"%s(%d)\\n\", node->children[i] -> name,node->children[i] -> pid);\n        if (level > 0) //如果不是根节点，若是最后一个孩子，则打印└────，否则打印├────\n            printf(node -> childrencount == (i + 1) ? \"└──── \" : \"├──── \");\n   \n        //参数为true时，打印pid\n        if (showpid == 1) \n        {\n            printf(\"%s(%d)\\n\", node->children[i] -> name,node->children[i] -> pid);\n        } \n        else \n        {\n            printf(\"%s\\n\", node->children[i] -> name);\n        }\n\n        char new_prefix[MAX_SIZE];\n        strncpy(new_prefix, prefix, sizeof(new_prefix) - 1);\n        if (level > 0)//如果不是根节点，若是最后一个孩子，则前缀加空格，否则加竖线 \n        {\n            strcat(new_prefix, node->childrencount == (i + 1) ? \"      \" : \"│     \");\n        }\n\n        print_tree(node->children[i], level + 1, new_prefix);//递归打印孩子的孩子节点\n    }\n \n}\n```\n\n"},{"title":"vptr和tbl，typedef","url":"/2025/09/10/vptr和tbl，typedef/","content":"\nvptr和tbl，typedef\n\n动态绑定\n\n函数指针\n\n```cpp\n#include <iostream>\nusing namespace std;\nclass base{\n    int a;\n    public:\n    base(int x):a(x){}\n    base(){}\n    ~base(){}\n\n    virtual void print(){cout << \"base print\" << endl;}\n};\n\nclass derived: public base{\n    public:\n    derived(int x):base(x){}\n    ~derived(){}\n    virtual void print(){cout << \"derived print\" << endl;}\n};\nint main(void)\n{\n    derived d(1);\n\n    base* p = new base(1); \n    p->print();\n\n    base c ;\n    typedef void (*Fun)(void);\n    Fun pFun = NULL;\n\n    cout << \"虚函数表地址\" << (int*)(&c) << endl;   \n    // 其实就是虚指针vbtr的值,因为vbtr的地址和对象的地址相同\n\n    cout << \"虚函数表: 第一个函数地址\" << (int*)*(int*)(&c) << endl;\n\n    pFun = (Fun)*((int*)*(int*)(&c));\n    pFun();\n\nreturn 0;\n}\n```\n\n```cpp\nFun pFun = NULL;：这里，pFun是一个Fun类型的指针，也就是一个函数指针。它被初始化为NULL，表示它不指向任何函数。\n\npFun = (Fun)*((int*)*(int*)(&c));：这里，pFun被赋值为c对象的虚函数表中的第一个函数的地址。这行代码首先获取c的地址&c，然后将其转换为int*类型，解引用得到虚函数表的地址，再次将其转换为int*类型，解引用得到第一个虚函数的地址，最后将其转换为Fun类型。\n```\n\n`   typedef `\n\n[C/C++ typedef用法详解（真的很详细）-CSDN博客](https://blog.csdn.net/Andrewniu/article/details/80566324)\n\n```c\ntype (*)(....)函数指针 \ntype (*)[]数组指针\n```\n\n```c\n理解复杂声明可用的“右左法则”：\n从变量名看起，先往右，再往左，碰到一个圆括号就调转阅读的方向；括号内分析完就跳出括号，还是按先右后左的顺序，如此循环，直到整个声明分析完。举例：\nint (*func)(int *p);\n首 先找到变量名func，外面有一对圆括号，而且左边是一个*号，这说明func是一个指针；然后跳出这个圆括号，先看右边，又遇到圆括号，这说明 (*func)是一个函数，所以func是一个指向这类函数的指针，即函数指针，这类函数具有int*类型的形参，返回值类型是int。\nint (*func[5])(int *);\nfunc 右边是一个[]运算符，说明func是具有5个元素的数组；func的左边有一个*，说明func的元素是指针（注意这里的*不是修饰func，而是修饰 func[5]的，原因是[]运算符优先级比*高，func先跟[]结合）。跳出这个括号，看右边，又遇到圆括号，说明func数组的元素是函数类型的指 针，它指向的函数具有int*类型的形参，返回值类型为int。\n```\n\n```cpp\n1. 原声明：int *(*a[5])(int, char*);\n变量名为a，直接用一个新别名pFun替换a就可以了：\ntypedef int *(*pFun)(int, char*); \n原声明的最简化版：\npFun a[5];\n\n2. 原声明：void (*b[10]) (void (*)());\n变量名为b，先替换右边部分括号里的，pFunParam为别名一：\ntypedef void (*pFunParam)();\n再替换左边的变量b，pFunx为别名二：\ntypedef void (*pFunx)(pFunParam);\n原声明的最简化版：\npFunx b[10];\n\n3. 原声明：doube(*)() (*e)[9]; \n变量名为e，先替换左边部分，pFuny为别名一：\ntypedef double(*pFuny)();\n再替换右边的变量e，pFunParamy为别名二\ntypedef pFuny (*pFunParamy)[9];\n原声明的最简化版：\npFunParamy e;\n```\n\n"},{"title":"互斥","url":"/2025/09/10/互斥/","content":"\n实现原子指令用到了什么，一小段的不可被打断的指令\n\n自旋锁，把`1`交换出去，其他的线程只能交换出`0`，并不断循环交换，临界区结束了之后把`1`还回去\n\n另一个线程就把锁换过来\n\n\n\n如果`lock` `unlock`函数加上参数，就相当于可以设多个锁，试图得到同一把锁的线程就实现了互斥\n\n`lock(&status)`\n\n```c\nbool holding(spinlock_t *lk) {//当前是有锁状态，且锁的拥有者是当前cpu\n    return (\n        lk->status == LOCKED &&\n        lk->cpu == &cpus[cpu_current()]\n    );\n}\n```\n\n\n\n\n\n要正确使用锁很难，要经常使用断言，检查中断是否符合预测`assert`，可以读读**xv6源码**\n\n\n\n\n\n在用户态\n\n用户程序`sum++`拥有锁，被操作系统中断了，切换到了其他程序，\n\n其他各个线程都无法获得锁，要等操作系统切回去\n\n在操作系统中\n\n会中断来实现锁\n\n\n\n\n\n在操作系统内核：\n\n连续上两次锁，中断一次再上锁，无法获得锁，就发生死锁\n\n正确性准则\n\n单处理器上锁解锁前后，中断状态不可改变，原来是中断还是中断，原来不中断还是不中断\n\n多处理器，\n\n使用栈保存中断状态\n\n\n\n\n\n为了实现自旋一定要中断吗？\n\n\n\n在用户态\n\n\n\n\n\n因为自旋锁资源浪费严重\n\n互斥锁（mutex）的实现使用了syscall，具有较好的scalability\n\nfutex如果没有锁直接访问，fast path\n\n如何唤醒被syscall挂起的线程？\n\n## 06-并发控制：互斥 (1)\n\n自己思考一下，想各种情况，修改后可以立即用model checker来验证\n\n\n\n## 互斥 2)\n\n关中断+自旋实现互斥\n\n保存锁前中断状态"},{"title":"多线程","url":"/2025/09/10/多线程/","content":"\n多线程\n\n独立的栈，共享的内存空间\n\n\n\n阅读thread.h源码\n\n\n\n在thread-qa中\n\n将thread.h移入文件夹，执行make报错找不到库\n\n解决方法：设置TLIB_PATH路径为thread.h所在的文件夹\n\n```makefile\nCFLAGS := -O1 -g -I$(TLIB_PATH)\n```\n\n解释\n\n1. `-I$(TLIB_PATH)`：\n   - 这个选项指定了一个包含路径，该路径由 `$(TLIB_PATH)` 变量定义。\n   - `$(TLIB_PATH)` 可能在 [Makefile](vscode-file://vscode-app/c:/Users/86147/AppData/Local/Programs/Microsoft VS Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html) 的其他地方定义，或者在运行 `make` 命令时通过环境变量传递。\n   - 编译器会在 `$(TLIB_PATH)` 指定的目录中查找头文件。\n2. `-I.`：\n   - 这个选项指定当前目录（`.`）作为包含路径。\n   - 编译器会在当前目录中查找头文件。\n\n\n\n多个进程读取写入\n\n支付宝，第一个减去100，第二个在该进程没有减去的时候进行条件判断，也减去100，由于是unsigned long 结果变成很大的数\n\n### copilot解释\n\n#### 竞态条件的发生\n\n1. **共享变量**：[`balance`](vscode-file://vscode-app/c:/Users/86147/AppData/Local/Programs/Microsoft VS Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html) 是一个全局变量，多个线程可以同时访问和修改它。\n2. **线程创建**：[`main`](vscode-file://vscode-app/c:/Users/86147/AppData/Local/Programs/Microsoft VS Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html) 函数中创建了两个线程，分别执行 [`T_alipay`](vscode-file://vscode-app/c:/Users/86147/AppData/Local/Programs/Microsoft VS Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html) 函数。\n3. **函数调用**：每个线程调用 `Alipay_withdraw(100)`，尝试从 [`balance`](vscode-file://vscode-app/c:/Users/86147/AppData/Local/Programs/Microsoft VS Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html) 中扣除 100。\n\n#### 竞态条件的具体过程\n\n1. **线程1和线程2同时检查 [`balance`](vscode-file://vscode-app/c:/Users/86147/AppData/Local/Programs/Microsoft VS Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html)**：\n\n   - 线程1检查 [`balance`](vscode-file://vscode-app/c:/Users/86147/AppData/Local/Programs/Microsoft VS Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html) 是否大于等于 100，结果为真。\n   - 线程2也检查 [`balance`](vscode-file://vscode-app/c:/Users/86147/AppData/Local/Programs/Microsoft VS Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html) 是否大于等于 100，结果也为真。\n\n2. **线程1和线程2同时进入 [`if`](vscode-file://vscode-app/c:/Users/86147/AppData/Local/Programs/Microsoft VS Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html) 块**：\n\n   - 线程1进入 [`if`](vscode-file://vscode-app/c:/Users/86147/AppData/Local/Programs/Microsoft VS Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html) 块并调用 `usleep(1)`，暂时让出CPU。\n   - 线程2也进入 [`if`](vscode-file://vscode-app/c:/Users/86147/AppData/Local/Programs/Microsoft VS Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html) 块并调用 `usleep(1)`，暂时让出CPU。\n\n3. **线程1和线程2同时修改 [`balance`](vscode-file://vscode-app/c:/Users/86147/AppData/Local/Programs/Microsoft VS Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html)**：\n\n   - 线程1从 [`balance`](vscode-file://vscode-app/c:/Users/86147/AppData/Local/Programs/Microsoft VS Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html) 中减去 100，[`balance`](vscode-file://vscode-app/c:/Users/86147/AppData/Local/Programs/Microsoft VS Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html) 变为 0。\n   - 线程2也从 [`balance`](vscode-file://vscode-app/c:/Users/86147/AppData/Local/Programs/Microsoft VS Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html) 中减去 100，[`balance`](vscode-file://vscode-app/c:/Users/86147/AppData/Local/Programs/Microsoft VS Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html) 无符号整数会溢出\n\n   \n\n如果是两个进程都循环加1加到10000，结果不会是20000\n\n\n\n\n\n原代码反汇编\n\n```assembly\n 13ea:       48 8b 05 4f 2c 00 00    mov    0x2c4f(%rip),%rax       \n # 4040 <sum>\n 13f1:       48 83 c0 01             add    $0x1,%rax\n 13f5:       48 89 05 44 2c 00 00    mov    %rax,0x2c44(%rip) \n```\n\n修改成一条汇编指令\n\n```assembly\n   13ea:       48 ff 05 4f 2c 00 00    incq   0x2c4f(%rip)  \n```\n\n改成一条指令，如果在一个处理器上还能正确，但是在多处理器上还会错误。\n\n看着是一条指令，实际上不是原子指令。\n\n`printf`是线程安全的\n\n\n\n因为汇编指令取值，在中间寄存器加1后可能会中断，再放入变量对应地址中，结果可能就只是加一个1，而不是两个1\n\n最小可以小于10000，可以改成汇编指令\n\n\n\n为什么是2？\n\n每个进程有一个n次循环，n个进程\n\n在关键进程中，最后一步store，之前，已经循环了n-1次了，这两次的最小值为1（进程A第一个循环store()时，关键进程第n-1个循环正好结束，进程A，store后sum=1）关键进程执行前两步，然后关键进程等待其他进程结束后执行store(2,sum)\n\n\n\n编译器优化，可能会隐藏并发的bug(都假设状态迁移是原子性，顺序执行)\n\nO1优化sum=100000000\n\n```asm\nload(sum + N)\n;循环N次\nstore(num)\n```\n\n\n\nO2优化sum=200000000\n\n```asm\n0000000000001260 <T_sum>:\n    1264:       48 81 05 d1 2d 00 00    addq   $0x5f5e100,0x2dd1(%rip)       \n ;改成了一条指令，两个进程碰在一起的概率很低\n```\n\n\n\n处理器也是编译器，所以单线程的处理器可能会优化，调换程序执行的顺序（在结果不变的情况下）\n\n也是状态机，流水线，读写不冲突就能同时执行\n\n所以......相对论？\n\n共享内存只是一个简化的假象\n\nmem-modle\n\n一个是写Y读X，一个是写X读Y，得按特定顺序才能输出1，1，所以很少\n\narm与x86的内存模型不同，对于多线程的程序模拟难度大\n\n\n\n"},{"title":"实现库函数printf","url":"/2025/09/10/实现库函数printf/","content":"\n实现库函数printf\n\n```c\nint    printf    (const char *format, ...);\n```\n\n这个程序除了调用的库函数不同 (例如没有 stdio.h；多了 am.h) 之外，它就是一个完全符合 C 标准的普通程序，但因为没有操作系统和标准库的支持，我们需要编写所有的库函数。例如，printf 也来自我们的代码，它调用了 AbstractMachine 提供的 putch API:\n\n\n\n"},{"title":"嵌套类","url":"/2025/09/10/嵌套类/","content":"\nClub嵌套Coach\n\n```cpp\nclass Coach{\n    string name;\n    int winRate;\npublic:\n    Coach(string n, int wr){\n        name=n; winRate=wr;\n    }\n    void show();\n};\nclass Club{\n    string name;\n    Coach c;\n    int year;\npublic:\n    Club(string n1, int y, string n2, int wr);\n    void show();\n};\n```\n\nClub的初始化和show函数要利用Club类中的东西\n\n```cpp\nClub::Club(string n1,int y,string n2,int wr):c(n2,wr){\n    name = n1;\n    year = y;\n}\nvoid Club::show(){\n    cout << name << \" \" << year << \"\\n\";\n    c.show();\n}\n```\n\n同样，在下面Circle调用内部Point类型的变量，要有Point中的get函数配合才能取出相应的x,y\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nclass Point{\n    private:\n        double x,y;\n    public:\n        Point(int n,int m):x(n),y(m){}\n    double get_x(){return x;}\n    double get_y(){return y;}\n};\nclass Circle{\n        private:\n            Point o;\n            double r;\n        public:\n    Circle(Point p,double x):o(p){r = x;}\n            bool isPointIn(Point p){\n                double a = o.get_x();\n                double b = o.get_y();\n                double c = p.get_x();\n                double d = p.get_y();\n                double x = sqrt((a - c) * (a - c) + (b - d) * (b - d));\n                if(x < r)return true;\n                return false;\n            }   \n};\n```\n\n"},{"title":"并发问题","url":"/2025/09/10/并发问题/","content":"\n该例子是一个生产者一个消费者，缓冲区是1，如果缓冲区很大这个问题就会被忽视了，如果生产者和消费者数量增加，那么死锁概率也会增加\n\n```c\n//错误的\nvoid wait(struct condvar *cv, mutex_t *mutex){\n    mutex_lock(&cv -> lock);\n    cv -> nwait++;\n    mutex_unlock(&cv -> lock);\n//理想状态是球在生产者和消费者之间传递    \n    mutex_unlock(mutex);\n    //但是如果在这里broadcast抢占，先唤醒了，然后nwait=0了，\n    //就相当于唤醒了另一个同样是生产者或者是消费者线程甚至是自己把球抢走了，再检查条件再进入wait,但是没有线程再放球了就会死锁\n    P(&cv -> sleep);//这个睡眠和解锁顺序不能更改\n    \n    \n    mutex_lock(mutex);\n}\n```\n\n问题是，为什么前一个线程执行完的broadcast后，consumer（12896）为什么没被唤醒，而后面的producer(12897)被唤醒了，而且例子中只有一个生产者和一个消费者，缓冲区大小为1\n\n```c\n------Consumer: begin, execution count: 12896------\nConsumer: Waiting\n------waiting------\nin wait nwait: 1\nwaiting before sleep\n\n------Producer: begin, execution count: 12896------\n(\ndepth = 1\nProducer: Broadcast\n------broadcast_start------\nstart broadcast\nint broadcast nwait: 1\n------broadcast_end------\n------Producer: end, execution count: 12896------\n    \n------Producer: begin, execution count: 12897------\nProducer: Waiting\n------waiting------\nin wait nwait: 1\nwaiting before sleep\n------waiting out------\nProducer: Waiting\n------waiting------\nin wait nwait: 2\nwaiting before sleep\n```\n\n"},{"title":"标准C＋＋类stdstring的内存共享和Copy-On-Write技术","url":"/2025/09/10/标准C＋＋类stdstring的内存共享和Copy-On-Write技术/","content":"\n[标准C＋＋类std::string的内存共享和Copy-On-Write技术_std::string重新分配内存拷贝字符串-CSDN博客](https://blog.csdn.net/armman/article/details/1741261)\n\n**string的懒拷贝**\n\n当函数返回一个静态字符串时，这个字符串存储在函数的静态存储区域中。这个静态存储区域在程序的整个生命周期内都存在，并且在程序加载时分配，在程序退出时释放。\n\n在你描述的情况中，函数`GetIPAddress`返回一个静态字符串，它在动态链接库的地址空间中分配。当动态链接库被释放时，这个地址空间也被释放，导致返回的静态字符串指向的内存变得无效。但是，由于字符串对象的值是存储在这个无效内存中的，所以在后续程序中使用这个字符串时就会出现未定义行为，因为访问了无效的内存地址。\n\n这种情况下，即使程序在后续没有使用到这个字符串，当程序退出时，会调用字符串对象的析构函数，尝试释放这个无效内存，进而导致内存访问异常，导致程序崩溃。"},{"title":"模拟实现Windows系统资源管理器","url":"/2025/09/10/模拟实现Windows系统资源管理器/","content":"\n# 题目1：模拟实现Windows系统资源管理器\n\n报告内容至少包括关键的数据结构、算法流程图、结果展示和人员分工。\n\n课程设计目的：熟悉操作系统资源管理原理，掌握编程接口，能够使用高级语言调用编程接口，设计并实现Windows操作系统任务管理器的全部功能。\n\n <img src=\"C:/Users/86147/Desktop/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241219210333.png\" alt=\"微信图片_20241219210333\" style=\"zoom: 67%;\" />\n\n![微信图片_20241219210338](C:/Users/86147/Desktop/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241219210338.png)\n\n![微信图片_20241219210357](C:/Users/86147/Desktop/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E8%AE%BE/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241219210357.png)\n\n创新点，持久化，拖拽，前进后退，支持用路径和文件名查找文件\n\n"},{"title":"模板的全特化与偏特化","url":"/2025/09/10/模板的全特化与偏特化/","content":"\n# 模板的全特化与偏特化\n\n模板函数和模板类有的时候可能需要对传入的不同类型进行不同的处理，比如说有的模板传入int或double类型都可以处理，但是传入char型则会出错，这时就需要模板特化的方式。\n\n## 类模板全特化：\n\n全特化即将模板类型里的所有类型参数全部具体指明之后处理，如下\n\n```cpp\ntemplate<typename T,typename C>\nstruct A\n{\n    A(){cout<<\"泛化版本构造函数\"<<endl;}\n    void func()\n    {\n        cout<<\"泛化版本\"<<endl;    \n    }\n};\n \ntemplate<>//把类型取出\nstruct A<int,int>\n{\n   A(){cout<<\"int,int特化版本构造函数\"<<endl;}\n   void func()\n   {\n       cout<<\"int,int特化版本\"<<endl;    \n   } \n};\n```\n\n`template<>`中为空，代表所有类型都在下面特殊化处理，上面相当于对int,int进行了分别的处理，其他类型依然是泛化版本。\n\n### 对类中的某个成员函数进行特化处理\n\n还是以上面给的例子为基础，特化func()成员函数，当A的模板参数为<int,double>时，调用特化版的func()。\n\n```cpp\ntemplate<>\nvoid A<int,double>::func\n{\n    cout<<\"int,double特化版本函数\"<<endl;\n}\n```\n\n## 类模板的偏特化\n\n类模板偏特化（局部特化）：顾名思义，只特殊化几个参数或者一定的参数范围\n\n### 个数偏特化\n\n```cpp\ntemplate<typename T,typename C,typename D>\nstruct A\n{\n\tvoid func()\n\t{\n\t\tcout << \"泛化版本\" << endl;\n\t}\n};\n \ntemplate<typename C>\nstruct A<int,C,int>\n{\n\tvoid func()\n\t{\n\t\tcout << \"int,C,int偏特化版本\" << endl;\n\t}\n};\n```\n\n`template<>`括号中存留的参数是依然可以任意填的参数。\n\nSTL中的一个个数偏特化例子：\n\n```cpp\n//泛化\ntemplate <class T,class Alloc = alloc>\nclass vector{}\n```\n\n```cpp\n//特化\ntemplate <class Alloc>\nclass vector<bool, Alloc>  \n{};\n```\n\n\n\n### 范围偏特化\n\n**记住这种情况的template<>中还是要填上原有的大类型**，且`const T*属于T*不属于const T`。\n\n注意范围二字，`比如const int属于int的一个小范围，int *和const int*属于int的一个小范围，int&属于int的一个小范围，int&&属于int的一个小范围`\n\n```cpp\ntemplate<typename T>\nstruct A\n{\n\tvoid func()\n\t{\n\t\tcout << \"泛化版本\" << endl;\n\t}\n};\n \ntemplate<typename T>\nstruct A<const T>\n{\n\tvoid func()\n\t{\n\t\tcout << \"const T版本\" << endl;\n\t}\n};\n \ntemplate<typename T>\nstruct A<T*>\n{\n\tvoid func()\n\t{\n\t\tcout << \"T*版本\" << endl;\n\t}\n};\n```\n\n\n\nSTL中的一个范围偏特化例子：\n![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/5dfcc94de47d1100dba17b4524b6b7b6.png)"},{"title":"调试","url":"/2025/09/10/调试/","content":"\n### 理解状态机执行：不是 “调试”，也是 “调试”\n\n- `ssh`：使用 `-v` 选项检查日志\n- `gcc`：使用 `-v` 选项打印各种过程\n- `make`：使用 `-nB` 选项查看完整命令历史\n\n### 调试：不仅是 “调试器”\n\n- Profiler: `perf` - “采样” 状态机\n- Trace: `strace` - 追踪系统调用\n\n\n\n将日志文件重定向到vim进行各种操作\n\n```bash\nstrace -f g++ a.cc |& vim -\n```\n\n执行 `grep` 命令进行过滤，可以通过 `:!` 来运行外部命令并将结果显示在 `vim` 中。\n\n步骤如下：\n\n1. 在 `vim` 中输入：\n\n   ```bash\n   :!grep \"关键词\" 文件名\n   ```\n\n   或者，你可以直接对 `vim` 缓冲区的内容使用管道进行过滤：\n\n   ```bash\n   :%!grep \"关键词\"\n   ```\n\n   - `:!grep \"关键词\"`：会在当前终端执行 `grep`，但不影响你在 `vim` 中的内容。\n   - `:%!grep \"关键词\"`：会将当前文件内容通过管道传递给 `grep`，然后将过滤结果替换当前文件的内容。\n\n2. 例如：\n\n   ```bash\n   :%!grep \"error\"\n   ```\n\n   这会将所有包含 `error` 的行保留，并替换掉当前缓冲区的内容。\n\n如果包含.h这种，使用转义字符\n\n```bash\n:%!grep \"\\.h\"\n```\n\n"},{"title":"调试bootloader","url":"/2025/09/10/调试bootloader/","content":"\ngdb调试\n\n目的：复现jyy的调试过程\n\n直接执行`make debug`会报错，显示`no file`问题就是boot里的文件是bootblock.o而不是boot.o，所以在其Makefile里添加\n\n```bash\ncp bootblock.o boot.o\n```\n\n复制一份，如何就再次执行`make debug `就会出现新的bug\n\n```bash\ngdb.error: \"/home/cgz/work/os-workbench/abstract-machine/am/src/x86/qemu/boot/boot.o\": not in executable format: file format not recognized\n```\n\n显示格式不能识别，问gpt回答为该种格式不能直接调试，需要启动qemu，连接调试，事实也是这样，\n\n问题不是这个。所以就是Makefile里缺少-ggdb\n\n需要-ggdb提供调试信息，gdb才能调试可执行文件\n\n\n\n在\n\n```bash\nabstract-machine/am/src/x86/qemu/boot/Makefile\n```\n\n添加-ggdb可以同时解决打印不出来的问题，不实现stdio里的printf函数也能打印\n\n\n\n设置`$AM_HOME`为pa的框架，改写Makefile不起作用\n\n但是改写为直接clone的\n\n```ba\n/home/cgz/work/os-workbench/abstract-machine/am/src/x86/qemu/boot/Makefile\n```\n\n就能正常使用printf，但是用make debug还是没有标记\n\n```b\ngdb.error: \"/home/cgz/work/os-workbench/abstract-machine/am/src/x86/qemu/boot/boot.o\": not in executable format: file format not recognized\n```\n\n造成这个的原因是在文件上没有gdb可以识别的标记\n\n解决方法应该是加上-ggdb应该就可以\n\n但是还是报错没有标记，把bulid生成的.o文件全部删除，再执行也一样。\n\n\n\n尝试把py程序代码手动输入，看看能否解决\n\n```bash\ndebug:\n\tqemu-system-i386 -s -S -machine accel=tcg -smp \"1,sockets=1\" \\\n\t\t-drive format=raw,file=build/hello-x86-qemu &\n\tgdb -x debug.py\n```\n\n```python\n# Register the quit hook\ndef on_quit():\n    gdb.execute('kill')\n\ngdb.events.exited.connect(on_quit)\n\n# Connect to the remote target\ngdb.execute('target remote localhost:1234')\n\n# Load the debug symbols\nam_home = os.environ['AM_HOME']\npath = f'{am_home}/am/src/x86/qemu/boot/boot.o'\ngdb.execute(f'file {path}')\n\n# This is the 0x7c00\ngdb.Breakpoint('_start')\n\n# This is where 32-bit code starts\ngdb.Breakpoint('start32')\n\n# Continue execution\ngdb.execute('continue')\n\n```\n\n提取出命令\n\n```bash\nqemu-system-i386 -s -S -machine accel=tcg -smp \"1,sockets=1\" -drive format=raw,file=build/hello-x86-qemu &\n//打开虚拟机文件夹\ngdb am/src/x86/qemu/boot/boot.o\n\ntarget remote localhost:1234\n\n//然后打断点执行\n(gdb)b _start\n(gdb)b start 32\n(gdb)c\n\n```\n\n同样的报错\n\n\n\n\n\n**已解决**\n\n把Makefile的两行交换位置即可\n\n```makefile\nSRCS := start.S main.c\nbootblock.o: $(SRCS) Makefile\n        @echo + CC $(SRCS)\n        @$(CROSS_COMPILE)gcc -ggdb -static -m32 -fno-pic -Os -nostdlib  -Ttext 0x7c00 -I$(AM_HOME)/am/src -o bootblock.o $(SRCS)\n        cp bootblock.o boot.o\n        @python3 genboot.py bootblock.o#该pyhton程序的作用是将bootblock.o转换成其他格式供底层程序使用，破坏了其可调试性\n\nclean:\n        rm -rf *.o\n```\n\n"},{"title":"递归算法的时间复杂度","url":"/2025/09/10/递归算法的时间复杂度/","content":"\n递归算法的时间复杂度\n\n[彻底搞懂递归的时间复杂度_递归排序的时间复杂度-CSDN博客](https://blog.csdn.net/pengfeicfan/article/details/120299868)\n\n二分查找(Binary search)：一般发生在一个数列本身有序的时候，要在有序的数列中找到目标数，所以它每次都一分为二，只查一边，这样的话，最后它的时间复杂度是O(logn)\n\n二叉树遍历(Binary tree traversal)：如果是二叉树遍历的话，它的时间复杂度为O(n)。因为通过主定理可以知道，它每次要一分为二，但是每次一分为二之后，每一边它是相同的时间复杂度。最后它的递推公式就变成了图中T(n)=2T(n/2)+O(1)这样。最后根据这个主定理就可以推出它的运行时间为O(n)。当然这里也有一个简化的思考方式，就是二叉树的遍历的话，会每一个节点都访问一次，且仅访问一次，所以它的时间复杂度就是O(n)\n\n二维矩阵(Optimal sorted matrix search)：在一个排好序的二维矩阵中进行二分查找，这个时候也是通过主定理可以得出时间复杂度是O(n)，记住就可以了\n\n归并排序(merge sort)：所有排序最优的办法就是nlogn，归并排序的时间复杂度就是O(nlogn)"},{"title":"错误递归","url":"/2025/09/10/错误递归/","content":"\n错误递归\n\n```cpp\nPolynomial& Polynomial::operator=(const Polynomial& p) {\n    if (this == &p) return *this;\n    delete[] coefficients;\n    size = p.size;\n    coefficients = new double[size];\n    for (int i = 0; i < size; i++)\n        coefficients[i] = p.coefficients[i];\n    return *this;\n}\n```\n\n```cpp\nPolynomial& Polynomial::operator=(const Polynomial& p) {\n    if (this == &p) return *this;\n    delete[] coefficients;\n    *this = Polynomial(p);//重复调用了=\n    return *this;\n}\n```\n\n"},{"title":"面向对象","url":"/2025/09/10/面向对象/","content":"\n## 面向对象\n\n封装，继承和多态\n\n\n\n### 多态\n\n1. 覆盖（也叫重写）（override）： 是指子类重新定义父类的虚函数的做法，**是在类中才有的概念**\n2.  重载（overload）： 是指**允许存在多个同名函数**，而这些函数的参数表不同（或许参数个数不同，或许参数 类型不同，或许两者都不同）**不一定是在类中的**\n\n**重写与重载的本质区别是,加入了override的修饰符的方法,此方法始终只有⼀个被你使用的方法**\n\n\n\n#### return by reference\n\n| 场景                           | 返回类型            | 原因                                                         |\n| ------------------------------ | ------------------- | ------------------------------------------------------------ |\n| 操作当前对象并希望支持链式调用 | 返回引用（`Type&`） | 提高性能，支持链式操作。                                     |\n| 提供对内部成员的直接访问       | 返回引用（`Type&`） | 允许外界修改内部数据，避免拷贝开销。                         |\n| 计算新结果并返回               | 返回值（`Type`）    | 返回一个新对象，不修改原始对象，符合语义要求。               |\n| 后置 `++` 或 `--`              | 返回值（`Type`）    | 符合“返回操作前的状态”的语义要求，需返回旧值副本。           |\n| 局部变量或临时对象             | 返回值（`Type`）    | 局部对象的生命周期短，不能返回局部对象的引用，否则将导致未定义行为（悬空引用） |"}]