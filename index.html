<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/stun-logo.jpg?v=2.8.0" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/stun-logo.jpg?v=2.8.0" type="image/png" sizes="32x32"><meta property="og:type" content="website">
<meta property="og:title" content="linyuww&#39;s blog">
<meta property="og:url" content="https://linyuww.github.io/index.html">
<meta property="og:site_name" content="linyuww&#39;s blog">
<meta property="og:locale" content="en_US">
<meta name="twitter:card" content="summary"><title>linyuww's blog</title><link ref="canonical" href="https://linyuww.github.io/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.8.0"><link rel="stylesheet" href="css/custom.css"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":false,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"Copy","copySuccess":"Copy Success","copyError":"Copy Error"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="linyuww's blog" type="application/atom+xml">
</head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">Home</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">Archives</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">Categories</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">Search</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">Hello Welcome to my blog</div><div class="header-banner-info__subtitle">一个大学生的个人博客</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2026/01/04/os%E5%A4%8D%E4%B9%A0/">os复习</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2026-01-04</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2026-01-04</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="操作系统"   >
          <a href="#操作系统" class="heading-link"><i class="fas fa-link"></i></a><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1>
      <p>填空题（1*20&#x3D;20分）简单看看概念</p>
<p>选择题（1*20+ 2 * 5&#x3D;30分）</p>
<p>简答题（4*5&#x3D;20分）5道题目，辅修考了：进程的概念，基本特征，中断处理过程</p>
<p>综合题（5*6&#x3D;30分）6道题目，</p>
<p>考：银行家算法，作业调度算法，PV原语，管程，页面替换算法，存储空间管理，文件索引</p>
<p>[TOC]</p>

        <h2 id="绪论"   >
          <a href="#绪论" class="heading-link"><i class="fas fa-link"></i></a><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2>
      
        <h3 id="操作系统的定义"   >
          <a href="#操作系统的定义" class="heading-link"><i class="fas fa-link"></i></a><a href="#操作系统的定义" class="headerlink" title="操作系统的定义"></a>操作系统的定义</h3>
      <p>操作系统是计算机系统中的一个系统软件，是一些程序模块的集合，它们管理和控制计算机系统中的硬件及软件资源，合理地组织计算机工作流程。以便有效地利用这些资源为用户提供一个具有最够的功能、使用方便、可扩展、安全和可管理的工作环境，从而在计算机与用户之间起到接口的作用。</p>

        <h3 id="操作系统的基本类型和特点"   >
          <a href="#操作系统的基本类型和特点" class="heading-link"><i class="fas fa-link"></i></a><a href="#操作系统的基本类型和特点" class="headerlink" title="操作系统的基本类型和特点"></a>操作系统的基本类型和特点</h3>
      <p><strong>批处理操作系统</strong></p>
<p>操作员把用户提交的作业分类，把一批作业编成一个作业执行序列，由专门编制的监督程序自动依次处理</p>
<p>特点：用户脱机使用计算机、成批处理、多道程序运行</p>
<p><strong>分时操作系统</strong></p>
<p>把处理机的运行时间分成很短的时间片，按时间片轮转的方式，把处理机分配给各个进程使用</p>
<p>特点：交互性、多用户同时性、独立性</p>
<p><strong>实时操作系统</strong> </p>
<p>在被控对象允许时间范围内做出响应</p>
<p>特征：对实时信息分析处理速度要比进入系统快、要求安全可靠</p>

        <h3 id="微机操作系统"   >
          <a href="#微机操作系统" class="heading-link"><i class="fas fa-link"></i></a><a href="#微机操作系统" class="headerlink" title="微机操作系统"></a>微机操作系统</h3>
      <p><strong>单用户单任务OS</strong></p>
<p>只允许一个用户上机，且只允许用户程序作为一个任务运行</p>
<p>最具代表性的是CP&#x2F;M和MS-DOS</p>
<p><strong>单用户多任务OS</strong></p>
<p>只允许一个用户上机，但允许将一个用户程序分为若干个任务，使他们并发执行</p>
<p>最具代表性的是os&#x2F;2和MS-WINDOWS</p>
<p><strong>多用户多任务OS</strong></p>
<p>允许多个用户通过各自的终端使用同一台主机，共享主机的各类资源，同时用户程序又可以分成几个任务使它们并发执行</p>
<p>最具代表性的是UNIX OS</p>

        <h3 id="操作系统的功能"   >
          <a href="#操作系统的功能" class="heading-link"><i class="fas fa-link"></i></a><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h3>
      <p>处理机管理</p>
<p>存储管理</p>
<p>设备管理</p>
<p>文件系统管理（信息管理）</p>
<p>用户接口</p>
<p><strong>程序一级接口</strong></p>
<p><strong>作业一级接口</strong></p>

        <h3 id="思考题"   >
          <a href="#思考题" class="heading-link"><i class="fas fa-link"></i></a><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3>
      <p>问题：鼠标点击“绪论.ppt”图标到屏幕上显示该文件内容</p>
<p>这个过程中，按照先后顺序描述操作系统完成了哪些功能？（尽可能描述细节）</p>
<p>鼠标点击—设备管理，用户接口</p>
<p>启动powerpoint程序—-存储管理，处理器管理</p>
<p>打开绪论.ppt文件—-文件管理，设备管理，存储管理</p>
<p>在屏幕上显示—-设备管理，用户接口</p>

        <h3 id="操作系统的特点"   >
          <a href="#操作系统的特点" class="heading-link"><i class="fas fa-link"></i></a><a href="#操作系统的特点" class="headerlink" title="操作系统的特点"></a>操作系统的特点</h3>
      <p><strong>并发</strong>是两或多个事件在同一时间间隔内发生。</p>
<p><strong>共享性</strong>：系统中的所有资源不再为一个程序所独占，而是供同时存在于系统中的多道程序所共同使用</p>
<p><strong>虚拟</strong>是指通过某种技术把一个物理实体变为若干个逻辑上的对应物</p>
<p><strong>异步性和不确定性</strong>：程序的执行并非“一气呵成”，而是以“走走停停”的方式运行，即程序是以异步方式运行的</p>

        <h3 id="作业"   >
          <a href="#作业" class="heading-link"><i class="fas fa-link"></i></a><a href="#作业" class="headerlink" title="作业"></a>作业</h3>
      <p>是指在一次应用业务处理过程中，从输入开始到输出结束，用户要求计算机所做的有关该次业务处理的全部工作</p>

        <h3 id="系统调用"   >
          <a href="#系统调用" class="heading-link"><i class="fas fa-link"></i></a><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3>
      <p><strong>作用</strong>：系统调用是系统向编程人员（应用程序，用户程序）提供的唯一接口</p>
<p><strong>实现过程</strong>：</p>
<p>（1）用户在源程序中使用系统调用，并给出系统调用名和参数，即产生一条相应的陷阱指令</p>
<p>（2）处理机在执行到这条指令后，引起处理机中断，并发出有关信号给陷阱处理机构</p>
<p>（3）该处理机构收到信号后，启动相关程序保护处理机现场，取系统调用功能号并寻找子程序入口，通过入口地址表找到该系统子程序并执行</p>
<p>（4）执行完毕后，退出中断，返回到用户程序的断点，恢复现场，继续执行用户程序</p>

        <h2 id="进程管理"   >
          <a href="#进程管理" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2>
      
        <h3 id="程序顺序执行的特征"   >
          <a href="#程序顺序执行的特征" class="heading-link"><i class="fas fa-link"></i></a><a href="#程序顺序执行的特征" class="headerlink" title="程序顺序执行的特征"></a>程序顺序执行的特征</h3>
      <p>顺序性，一个程序开始执行必须要等到前一个程序已执行完成。</p>
<p>封闭性，程序一旦开始执行，其计算结果不受外界因素影响。</p>
<p>可再现性，程序的结果与它的执行速度无关（即与时间无关），只要给定相同的输入，一定会得到相同的结果</p>

        <h3 id="程序并发执行的特征"   >
          <a href="#程序并发执行的特征" class="heading-link"><i class="fas fa-link"></i></a><a href="#程序并发执行的特征" class="headerlink" title="程序并发执行的特征"></a>程序并发执行的特征</h3>
      <p>间断性，“走走停停”，一个程序可能走到中途停下来，失去原有的时序关系</p>
<p>失去封闭性，程序在并发执行时，是多个程序共享系统中的各种资源，因而这些资源的状态将由多个程序来改变，致使程序的运行失去了封闭性</p>
<p>不可再现性，程序在并发执行时，由于失去了封闭性，也导致失去了可再现性</p>

        <h3 id="并发"   >
          <a href="#并发" class="heading-link"><i class="fas fa-link"></i></a><a href="#并发" class="headerlink" title="并发"></a>并发</h3>
      <p><strong>概念</strong>，一组在逻辑上相互独立的程序或程序段在执行过程中，其执行时间在客观上相互重叠</p>

        <h3 id="并发带来的效率提升"   >
          <a href="#并发带来的效率提升" class="heading-link"><i class="fas fa-link"></i></a><a href="#并发带来的效率提升" class="headerlink" title="并发带来的效率提升"></a>并发带来的效率提升</h3>
      <img src="/images/image-20241211161920342.png" alt="image-20241211161920342" style="zoom:33%;" />

<img src="/images/image-20241211161935929.png" alt="image-20241211161935929" style="zoom:33%;" />


        <h3 id="进程"   >
          <a href="#进程" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程" class="headerlink" title="进程"></a>进程</h3>
      <p><strong>概念</strong>：在操作系统中进程是一个拥有资源的基本单位，也是一个调度和执行的基本单位 </p>
<p><strong>特征</strong>：动态性（最基本），并发性，独立性，异步性，结构特性</p>
<div class="table-container"><table>
<thead>
<tr>
<th align="left"></th>
<th>区别</th>
<th>联系</th>
</tr>
</thead>
<tbody><tr>
<td align="left">作业</td>
<td>用户向计算机提交任务的任务实体</td>
<td>一个作业可由多个进程组成，且必须至少一个</td>
</tr>
<tr>
<td align="left">进程</td>
<td>1.完成用户任务的执行实体，具有并发特性。2.进程是竞争计算机系统资源的基本单位，从而其并发性受到系统自己的制约。</td>
<td></td>
</tr>
<tr>
<td align="left">程序</td>
<td>静态概念，没有并发特性</td>
<td>不同的进程可以包含同一程序，只要该程序所对应的数据集不同。</td>
</tr>
</tbody></table></div>
<img src="/images/image-20241211164506642.png" alt="image-20241211164506642" style="zoom:33%;" />


        <h3 id="进程的静态结构"   >
          <a href="#进程的静态结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程的静态结构" class="headerlink" title="进程的静态结构"></a>进程的静态结构</h3>
      <p>PCB :OS感知进程的存在的唯一标识</p>
<p>PCB，由进程创建原语创建</p>
<p>程序段</p>
<p>数据结构集</p>

        <h3 id="进程状态转换"   >
          <a href="#进程状态转换" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程状态转换" class="headerlink" title="进程状态转换"></a>进程状态转换</h3>
      <p>执行，等待，就绪</p>
 <img src="/images/image-20241211200805596.png" alt="image-20241211200805596" style="zoom:33%;" />


        <h3 id="思考题-1"   >
          <a href="#思考题-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#思考题-1" class="headerlink" title="思考题"></a>思考题</h3>
      <p>如果系统中有N个进程，运行的进程最多几个，最少几个；就绪进程最多几个，最少几个；等待进程最多几个，最少几个？</p>
<p>答：最多有1个进程运行，最少是0个，就绪进程最多N-1个，最少0个</p>
<p>等待进程最多N个，最少0个（死锁）</p>

        <h3 id="原语"   >
          <a href="#原语" class="heading-link"><i class="fas fa-link"></i></a><a href="#原语" class="headerlink" title="原语"></a>原语</h3>
      <p><strong>概念</strong>：是指系统态下执行的某些具有特定功能的程序段</p>
<p>原语又称为“原子操作(Atomic Operation)”过程，作为一个整体而不可分割——要么全都完成，要么全都不做</p>
<p><strong>机器指令级的</strong>:执行期间不允许中断</p>
<p><strong>功能级的</strong>:作为原语的程序段不允许并发执行</p>

        <h3 id="临界区"   >
          <a href="#临界区" class="heading-link"><i class="fas fa-link"></i></a><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3>
      <p><strong>概念</strong>：一个进程访问临界资源的那段程序代码称为临界部分或者称为临界区.即访问公用数据的那段程序</p>
<p><strong>使用准则</strong>：</p>
<p>（1）不能假设各并发进程的相对执行速度。即各并发进程享有平等的、独立的竞争共有资源的权利，且在不采取任何措施的条件下，在临界区内任一指令结束时，其他并发进程可以进入临界区</p>
<p>（2）并发进程中的某个进程不在临界区时，它不阻止其他进程进入临界区；放弃处理机</p>
<p>（3）并发进程中的若干个进程申请进入临界区时，只能允许一个进程进入。</p>
<p>（4）从并发进程中的某个进程申请进入临界区时开始，应在有限时间内能够进入其临界区</p>
<p>即：<strong>空则让进，等则让权（让权等待），忙则等待，等则有限</strong></p>

        <h3 id="信号量"   >
          <a href="#信号量" class="heading-link"><i class="fas fa-link"></i></a><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3>
      <p><strong>信号量的本质是计数器</strong>，一个口袋，P是申请拿球，V是放球</p>
<p>sem&gt;0表示有sem个资源可用</p>
<p>sem&#x3D;0表示无资源可用</p>
<p>sem&lt;0则| sem |表示sem等待队列中的进程个数</p>
<p>sem的应该初值大于等于零</p>
<p>P(S):表示申请一个资源</p>
<p>V(S):表示释放一个资源</p>

        <h3 id="进程互斥的实现"   >
          <a href="#进程互斥的实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程互斥的实现" class="headerlink" title="进程互斥的实现"></a>进程互斥的实现</h3>
      <p><strong>软件法</strong>：通过平等协商方式实现进程互斥</p>
<p>单标志算法，双标志、先检查算法，双标志、先修改后检查算法，先修改、后检查、后修改者等待算法</p>
<p><strong>硬件法</strong>：关中断，专用指令（testset, swap）</p>
<p><strong>信号量</strong></p>
<p>单个临界资源：整型信号量，记录型信号量</p>
<p>多个临界资源:AND型信号量</p>
<p><strong>管程</strong></p>
<p><strong>条件变量</strong>：cwait,csignal</p>
<p>局部变量,操作</p>

        <h3 id="实现进程的同步和互斥"   >
          <a href="#实现进程的同步和互斥" class="heading-link"><i class="fas fa-link"></i></a><a href="#实现进程的同步和互斥" class="headerlink" title="实现进程的同步和互斥"></a>实现进程的同步和互斥</h3>
      <p><strong>进程的互斥</strong>：由于共享资源而引起的在临界区内不允许并发进程交叉执行的现象称为由共享公有资源而造成的对并发进程执行速度的间接制约</p>
<p><strong>进程的同步</strong>：由于并发进程互相共享对方的私有资源所引起的直接制约</p>
<p><strong>进程的前驱关系（时间同步）</strong></p>
<p>一组有关的并发进程在执行时间上有严格的先后顺序时，就会出现时间上的进程同步问题，或者称为进程的前驱关系</p>

        <h3 id="进程通信"   >
          <a href="#进程通信" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3>
      <p><strong>低级通信</strong>：进程之间控制信息的交换。一般只传送一个和几个字节的信息，达到控制进程执行速度的作用。（进程的同步和互斥）</p>
<p><strong>高级通信</strong>：用户可以直接利用操作系统所提供的一组通信命令，高效地传送大量数据的一种通信方式。</p>
<p>方式：主从式 (master-servant system) 　，会话式(dialogue system)，</p>
<p>消息或信箱机制(message)，共享存储区方式(shared memory）</p>

        <h3 id="死锁"   >
          <a href="#死锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3>
      <p>**概念：**指多个进程因竞争资源而造成的一种僵局，若无外力的作用，这些进程将永远不能再向前推进</p>
<p><strong>产生死锁的必要条件</strong>：互斥，部分分配，不剥夺条件，环路等待</p>
<ol>
<li>Mutual-exclusion - 一个口袋一个球，得到球才能继续</li>
<li>Wait-for - 得到球的人想要更多的球</li>
<li>No-preemption - 不能抢别人的持有的球</li>
<li>Circular-chain - 形成循环等待球的关系</li>
</ol>

        <h3 id="预防死锁"   >
          <a href="#预防死锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3>
      <p>**预防死锁设计思路：**设置某些限制条件，去破坏死锁四个必要条件中的一个或多个，来防止死锁。</p>
<p>防止“互斥条件”：使用Spooling技术来管理设备</p>
<p>防止“不剥夺”条件的出现：一个已经保持了某些资源的进程，当它再提出新的资源要求而不能立即得到满足时，必须释放它已经保持的所有资源，待以后需要时再重新申请</p>
<p>防止部分分配（摒弃请求和保持条件）：系统要求任一进程必须预先申请它所需的全部资源，而且仅当该进程的全部资源要求能得到满足时，系统才能给予一次性分配，然后启动该进程运行</p>
<p>防止“环路等待”条件的出现：把系统中所有资源类型线性排队，并按递增规则赋予每类资源以唯一的编号，进程申请资源时，必须严格按资源编号的递增顺序进行，否则系统不予分配</p>
<p><strong>死锁避免</strong>：</p>
<p><strong>安全状态</strong>：存在某种资源调度顺序，来为每个进程分配其所需资源，直至最大需求,保证所有进程正常运行完成，则称该状态为安全状态。</p>
<p><strong>不安全状态</strong>：不存在可满足所有进程正常运行的资源调度顺序，则称该状态为不安全状态</p>
<p><strong>避免死锁的实质是如何使系统不进入不安全状态</strong></p>

        <h3 id="银行家算法"   >
          <a href="#银行家算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3>
      <p>判断是否为安全状态，对于进程的资源请求，判断是否能够进行分配</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1kJ411E7AQ?spm_id_from=333.788.videopod.episodes&vd_source=07ce431f0897d40efe75d8ff3761e5f6&p=4" >银行家算法_Banker’s_Algorithm_哔哩哔哩_bilibili</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="死锁的检测和恢复"   >
          <a href="#死锁的检测和恢复" class="heading-link"><i class="fas fa-link"></i></a><a href="#死锁的检测和恢复" class="headerlink" title="死锁的检测和恢复"></a>死锁的检测和恢复</h3>
      <p>死锁的检测：实质是确定是否存在环路等待现象</p>
<p>死锁的恢复：立即结束所有进程的执行,并重新启动操作系统；撤销进程；剥夺资源</p>

        <h3 id="线程"   >
          <a href="#线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程" class="headerlink" title="线程"></a>线程</h3>
      <p>线程是调度和执行的基本单位，不作为独立分配资源的单位</p>
<p>引入线程则是为了减少程序并发执行时的所付出的时空开销</p>
<p>线程本身拥有少数资源，多个线程共享所属进程的资源</p>
<p><strong>线程分类</strong>：用户级线程，系统级线程</p>
<p><strong>适用范围</strong>：多处理机系统，网络与分布式系统</p>

        <h2 id="处理器调度"   >
          <a href="#处理器调度" class="heading-link"><i class="fas fa-link"></i></a><a href="#处理器调度" class="headerlink" title="处理器调度"></a>处理器调度</h2>
      
        <h3 id="调度的分级"   >
          <a href="#调度的分级" class="heading-link"><i class="fas fa-link"></i></a><a href="#调度的分级" class="headerlink" title="调度的分级"></a>调度的分级</h3>
      <p>作业调度（宏观调度，高级调度），交换调度（中级调度），内外存的进程交换，进程调度，分配处理机</p>

        <h3 id="作业调度的衡量"   >
          <a href="#作业调度的衡量" class="heading-link"><i class="fas fa-link"></i></a><a href="#作业调度的衡量" class="headerlink" title="作业调度的衡量"></a>作业调度的衡量</h3>
      <p><strong>周转时间</strong>：从提交到完成的时间</p>
<p><strong>带权周转时间</strong>：周转时间除运行时间</p>

        <h3 id="调度算法（考）"   >
          <a href="#调度算法（考）" class="heading-link"><i class="fas fa-link"></i></a><a href="#调度算法（考）" class="headerlink" title="调度算法（考）"></a>调度算法（考）</h3>
      <p><strong>先来先服务（FCFS）</strong>：将用户作业和就绪进程按提交顺序或变为就绪状态的先后排成队列，并按照先来先服务的方式进行调度处理，它优先考虑在系统中等待时间最长的作业，而不管要求运行时间的长短</p>
<p><strong>轮转法</strong>:</p>
<p>把CPU划分成若干时间片。将系统中所有的就绪进程按照FCFS原则，排成一个队列每次调度时将CPU分派给队首进程，让其执行一个时间片</p>
<p>时间片的选择：</p>
<p>时间片长度S＝R&#x2F;Nmax</p>
<p>R：响应时间;</p>
<p>Nmax：最大进程数</p>
<p><strong>多级反馈轮转法</strong>: </p>
<p>系统中设置多个就绪队列</p>
<p>每个就绪队列分配给不同时间片，优先级高的为第一级队列，时间片最小，随着队列级别的降低，时间片加大</p>
<p><strong>优先级法</strong>:静态优先级,动态优先级</p>
<p><strong>最短作业优先法</strong></p>
<p>对预计执行时间短的作业（进程）优先分派处理机</p>
<p>比FCFS改善平均周转时间和平均带权周转时间，缩短作业的等待时间；</p>
<p>提高系统的吞吐量</p>
<p><strong>最高响应比优先法</strong>:响应比R &#x3D; 1 +（作业等待时间&#x2F; 作业执行时间）</p>

        <h3 id="实时系统中的任务分类"   >
          <a href="#实时系统中的任务分类" class="heading-link"><i class="fas fa-link"></i></a><a href="#实时系统中的任务分类" class="headerlink" title="实时系统中的任务分类"></a>实时系统中的任务分类</h3>
      <p><strong>按照时限严格程度类型分类</strong></p>
<p><strong>硬实时任务</strong>：要求系统必须完全满足任务的时间要求</p>
<p><strong>软实时任务</strong>：允许系统对任务的时限要求有一定的延迟，时限要求是一个相对条件</p>
<p><strong>按照时限是周期or时刻分类</strong></p>
<p><strong>周期性任务</strong>：要求在周期T内完成或开始进行处理</p>
<p><strong>非周期性任务</strong>：存在一个完成或开始进行处理的时间</p>

        <h2 id="存储管理"   >
          <a href="#存储管理" class="heading-link"><i class="fas fa-link"></i></a><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h2>
      
        <h3 id="概念"   >
          <a href="#概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#概念" class="headerlink" title="概念"></a>概念</h3>
      <p>**逻辑地址:**程序经编译或汇编以后形成目标程序，其指令的顺序都是以零作为参考地址，这些地址称为 逻辑地址</p>
<p><strong>虚拟地址空间</strong>:</p>
<p>虚存容量的扩大是以牺牲CPU工作时间以及内、外存交换时间为代价的 （时间换空间）</p>
<p>虚拟存储器的最大容量（用户编程空间）由计算机的地址结构和寻址方式决定</p>
<p>如直接寻址时，若CPU的有效长度为16位，则其地址范围是0～～64K-1(216-1)，最大容量为64K**(确认地址位数)**</p>
<p><strong>静态重定位</strong></p>
<p>在装入一个作业时，把作业中的指令地址和数据地址全部转换为物理地址（地址转换工作是在作业执行前集中一次完成的）在作业执行过程中就无须再进行地址转换工作</p>
<p><strong>动态重定位</strong>:地址转换是在作业执行时动态完成</p>

        <h3 id="内存保护"   >
          <a href="#内存保护" class="heading-link"><i class="fas fa-link"></i></a><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h3>
      <p><strong>上下界保护法</strong></p>
<p>在CPU中设置一对上界寄存器和下界寄存器存放用户作业在内存中的起始地址和终止地址；每当CPU要访问内存时，硬件自动将被访问的内存地址与界限寄存器的内容进行<strong>比较</strong>，以判断是否越界</p>
<p><strong>保护键法</strong></p>
<p>为每一个被保护存储块分配一个单独的保护键。保护键可设置成对读写同时保护的或只对读、写进行单项保护的；在程序状态字中则设置相应的<strong>保护键开关字段</strong>, 不同的进程赋予不同的开关代码；</p>
<p><strong>界限寄存器与CPU的用户态或核心态工作方式相结合的保护方式</strong></p>
<p>在这种保护模式下，<strong>用户态进程</strong>只能访问那些在界限寄存器所规定范围内的内存部分，而<strong>核心态进程</strong>则可以访问整个内存地址空间</p>

        <h3 id="内存扩充"   >
          <a href="#内存扩充" class="heading-link"><i class="fas fa-link"></i></a><a href="#内存扩充" class="headerlink" title="内存扩充"></a>内存扩充</h3>
      <p><strong>覆盖方式</strong>：</p>
<p>一个程序的几个代码段或数据段，按照时间先后来占用公共的内存空间</p>
<p><strong>交换方式</strong>：</p>
<p>由操作系统把那些在内存中处于等待状态的进程换出内存，以及把那些等待事件已经发生，处于就绪态的进程换入内存，以及那些即将执行的程序数据调入内存</p>
<p><strong>调入方式</strong>：</p>
<p>请求调入方式, 预调入方式</p>

        <h3 id="内存管理"   >
          <a href="#内存管理" class="heading-link"><i class="fas fa-link"></i></a><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3>
      <p><strong>常用方法</strong>:</p>
<p>分区存储管理,页式管理,段式管理,段页式管理</p>

        <h3 id="动态分区分配"   >
          <a href="#动态分区分配" class="heading-link"><i class="fas fa-link"></i></a><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h3>
      <p><strong>最先适应法</strong>:要求空闲分区按首址递增的次序组织可用表或自由链</p>
<p><strong>最佳适应法</strong>:空闲分区链按照分区容量递增的方式形成</p>
<p><strong>最坏适应法</strong>:要求空闲区按大小递减的顺序组织可用表(或自由链)</p>
<p><strong>动态分区回收</strong>:</p>
<img src="/images/image-20241212112546853.png" alt="image-20241212112546853" style="zoom:33%;" />

<p>a,与空闲区合并。b,与上空闲区合并。c,与下空闲区合并。d,不合并</p>
<p><strong>缺点</strong>：</p>
<p>所谓“碎片”(fragmentation)：就是指不能分配给作业使用的一段无效存贮空间。</p>
<p>固定分区管理存在内碎片，可变分区管理存在外碎片</p>
<p>碎片使得内存的空闲空间得不到充分利用，并且存储每个用户作业都要受到实际存储容量的限制。</p>

        <h3 id="页式管理（考计算）"   >
          <a href="#页式管理（考计算）" class="heading-link"><i class="fas fa-link"></i></a><a href="#页式管理（考计算）" class="headerlink" title="页式管理（考计算）"></a>页式管理（考计算）</h3>
      <p>页式管理中给定逻辑地址的组成，页表，将逻辑地址转换为物理地址</p>
<p><strong>计算过程：程序地址&#x2F;页长</strong></p>
<p><strong>页式管理的问题</strong>：CPU要存取一个数据，需访问主存两次</p>
<p><strong>解决</strong>：快表</p>
<img src="/images/image-20241212113343060.png" alt="image-20241212113343060" style="zoom:50%;" />

<p><strong>请求（动态）页式管理的实现</strong>：</p>
<p>与每个虚页号相对应，除了页面号之外，再增设该页是否在内存的中断位以及该页在外存中的副本起始地址，还应增加一项以记录该页是否曾被改变 </p>
<img src="/images/image-20241212113502613.png" alt="image-20241212113502613" style="zoom:50%;" />


        <h3 id="段式存储管理（考计算）"   >
          <a href="#段式存储管理（考计算）" class="heading-link"><i class="fas fa-link"></i></a><a href="#段式存储管理（考计算）" class="headerlink" title="段式存储管理（考计算）"></a>段式存储管理（考计算）</h3>
      <p>给定段表，计算逻辑地址对应的物理地址</p>
<img src="/images/image-20241212113915402.png" alt="image-20241212113915402" style="zoom:50%;" />

<div class="table-container"><table>
<thead>
<tr>
<th></th>
<th>区别</th>
</tr>
</thead>
<tbody><tr>
<td>页式管理</td>
<td>页是信息的<strong>物理</strong>单位，进行分页是出于<strong>系统管理</strong>的需要；页的大小是<strong>固定</strong>的。</td>
</tr>
<tr>
<td>段式管理</td>
<td>段是信息的<strong>逻辑</strong>单位，分段是出于<strong>用户</strong>的需要 ；段的大小是<strong>可变</strong>的。</td>
</tr>
</tbody></table></div>

        <h3 id="页面置换算法（考）"   >
          <a href="#页面置换算法（考）" class="heading-link"><i class="fas fa-link"></i></a><a href="#页面置换算法（考）" class="headerlink" title="页面置换算法（考）"></a>页面置换算法（考）</h3>
      <p>注意刚开是空页放入也计入表格</p>
<p><strong>FIFO算法</strong>：淘汰最早建立的页面，Belady现象</p>
<p><strong>LRU</strong>:最近最久没有使用,当需要淘汰时，应淘汰当前时间最近的一段时间内最久没有使用过的页</p>
<p><strong>LFU</strong>:最不经常使用,淘汰被访问次数最少的页</p>
<p><strong>NUR</strong>：当需要淘汰某一页时，从那些最近一个时期内未被访问的页中任选一页淘汰</p>
<p><strong>理想型页面置换法（OPT）</strong>：选择“未来不再使用的”或“在离当前最远位 置上出现的”页面被置换</p>
<p><strong>缺页率的计算</strong>：缺页次数&#x2F;访问页面次数</p>

        <h3 id="Belady现象"   >
          <a href="#Belady现象" class="heading-link"><i class="fas fa-link"></i></a><a href="#Belady现象" class="headerlink" title="Belady现象"></a>Belady现象</h3>
      <p>采用FIFO算法时，如果对一个进程未分配它所要求的全部页面，有时就会出现分配的页面数增多，缺页率反而提高的异常现象。</p>
<p><strong>原因</strong>：</p>
<p>FIFO算法的置换特征与进程访问内存的动态特征是矛盾的，即被置换的页面并不是进程不会访问的</p>

        <h3 id="局部性原理"   >
          <a href="#局部性原理" class="heading-link"><i class="fas fa-link"></i></a><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3>
      <p>指程序在执行过程中的一个较短时期，所执行的指令地址和指令的操作数地址，分别局限于一定区域</p>
<p><strong>还可以表现为：</strong></p>
<p><strong>时间局部性</strong>，即一条指令的一次执行和下次执行，一个数据的一次访问和下次访问都集中在一个较短时期内；</p>
<p><strong>空间局部性</strong>，即当前指令和邻近的几条指令，当前访问的数据和邻近的数据都集中在一个较小区域内</p>

        <h3 id="内存抖动问题"   >
          <a href="#内存抖动问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#内存抖动问题" class="headerlink" title="内存抖动问题"></a>内存抖动问题</h3>
      <p><strong>定义：</strong></p>
<p>在虚存中，页面在内存与外存之间频繁调度，以至于调度页面所需时间比进程实际运行的时间还多，此时系统效率急剧下降，甚至导致系统崩溃。这种现象称为颠簸或抖动</p>
<p><strong>产生的原因</strong></p>
<p>分配给进程的物理页面数太少</p>
<p>页面淘汰算法不合理</p>
<p>避免的方法</p>
<p>扩大工作集</p>
<p>选择不同的淘汰算法</p>

        <h2 id="文件系统"   >
          <a href="#文件系统" class="heading-link"><i class="fas fa-link"></i></a><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2>
      
        <h3 id="文件的逻辑结构与存取方法"   >
          <a href="#文件的逻辑结构与存取方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#文件的逻辑结构与存取方法" class="headerlink" title="文件的逻辑结构与存取方法"></a>文件的逻辑结构与存取方法</h3>
      <p><strong>逻辑结构</strong></p>
<p>字符流式的无结构文件：源程序、可执行文件、库函数等</p>
<p>记录式的有结构文件：数据库</p>
<p><strong>存取方法</strong></p>
<p>(1)顺序存取法</p>
<p>⑵ 随机（直接）存取法</p>
<p>⑶ 按关键字存取法</p>

        <h3 id="文件的物理结构与存储设备"   >
          <a href="#文件的物理结构与存储设备" class="heading-link"><i class="fas fa-link"></i></a><a href="#文件的物理结构与存储设备" class="headerlink" title="文件的物理结构与存储设备"></a>文件的物理结构与存储设备</h3>
      <p><strong>物理结构</strong></p>
<p>为了有效地管理文件存储器，通常把文件存储空间划分成若干个大小相等的物理块，物理块是分配及传输信息的基本单位</p>
<p>常用的物理结构：连续文件，串联文件，索引文件；</p>
<p><strong>存储设备</strong></p>
<p>顺序存储设备：磁带</p>
<p>直接存储设备：磁盘</p>

        <h3 id="磁盘臂调度算法"   >
          <a href="#磁盘臂调度算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#磁盘臂调度算法" class="headerlink" title="磁盘臂调度算法"></a>磁盘臂调度算法</h3>
      <p><strong>先来先服务(FCFS)</strong>:</p>
<p>磁盘驱动程序每次接收一个请求并按照接收顺序完成请求</p>
<p><strong>最短寻道时间优先（shortest seek time first，SSTF）</strong>:</p>
<p>下一次总是处理与磁头距离最近的请求以使寻道时间最小化</p>

        <h3 id="文件空间管理"   >
          <a href="#文件空间管理" class="heading-link"><i class="fas fa-link"></i></a><a href="#文件空间管理" class="headerlink" title="文件空间管理"></a>文件空间管理</h3>
      <p>空闲文件目录</p>
<p>空闲块链</p>
<p><strong>UNIX中使用成组链法</strong></p>
<p>位视图</p>

        <h3 id="文件接口"   >
          <a href="#文件接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#文件接口" class="headerlink" title="文件接口"></a>文件接口</h3>
      <p><strong>OPEN, close, create,delete</strong></p>

        <h3 id="目录结构"   >
          <a href="#目录结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3>
      <p><strong>单级目录</strong></p>
<p>结构简单，实现容易</p>
<p>搜索速度较慢，不允许文件重名</p>
<p><strong>二级目录</strong></p>
<p>解决了文件的重名问题和文件共享问题</p>
<p>提高搜索速度，查找时间降低</p>
<p><strong>多级目录</strong></p>
<p>层次结构清晰，便于管理和保护；有利于文件分类；解决重名问题；</p>
<p>查找一个文件按路径名逐层检查，由于每个文件都放在外存，多次访盘影响速度</p>

        <h3 id="文件的共享"   >
          <a href="#文件的共享" class="heading-link"><i class="fas fa-link"></i></a><a href="#文件的共享" class="headerlink" title="文件的共享"></a>文件的共享</h3>
      <p><strong>绕道法</strong></p>
<p>使用绕道法进行文件共享时，用户从当前目录出发向上返回到与所要共享文件所在路径的交叉点再顺序下访到共享文件</p>
<p><strong>链接法</strong></p>
<p>在相应目录表之间进行链接。即将一个目录中的链指针直接指向被共享文件所在的目录</p>
<p><strong>基本文件目录表BFD</strong></p>
<p>把所有文件目录的内容分成两部分：</p>
<p>基本文件目录表BFD：存放除了文件名之外的文件说明信息和文件内部标识符；</p>
<p>符号文件目录表SDF：存放文件名和文件内部标识符</p>

        <h3 id="存取权限控制"   >
          <a href="#存取权限控制" class="heading-link"><i class="fas fa-link"></i></a><a href="#存取权限控制" class="headerlink" title="存取权限控制"></a>存取权限控制</h3>
      <p>（1）文件的共享：指不同的用户共同使用一个文件</p>
<p>（<strong>2</strong>）文件的保护：指文件本身需要防止文件的拥有者或其他用户破坏文件内容。</p>
<p>（<strong>3</strong>）文件的保密：指未经拥有者许可，任何用户不得访问该文件。（防止窃取）</p>

        <h2 id="设备管理"   >
          <a href="#设备管理" class="heading-link"><i class="fas fa-link"></i></a><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2>
      
        <h3 id="SPOOLNG系统"   >
          <a href="#SPOOLNG系统" class="heading-link"><i class="fas fa-link"></i></a><a href="#SPOOLNG系统" class="headerlink" title="SPOOLNG系统"></a>SPOOLNG系统</h3>
      <p>假脱机真联机技术：设备管理的虚拟技术</p>
<p>它使用直接存取的大容量磁盘作为缓冲，将一个可共享的磁盘空间改造成若干个输入设备和输出设备，并使得I&#x2F;O设备和CPU并行操作。（在联机情况下实现的同时外围操作）</p>
<p><img src="/images/image-20241211203737885.png" alt="image-20241211203737885" style="zoom:33%;" />SPOOLING 系统的组成</p>
<p>（1）输入井和输出井（2）输入缓冲区和输出缓冲区</p>
<p>（3）输入进程和输出进程（输入管理模块、输出管理模块）</p>
<p><strong>特点</strong>：</p>
<ol>
<li><p>提高了I&#x2F;O速度</p>
<p>从对低速I&#x2F;O设备进行的I&#x2F;O操作变为对输入井或输出井的操作,如同脱机操作一样,提高了I&#x2F;O速度,缓和了CPU与低速I&#x2F;O设备速度不匹配的矛盾</p>
</li>
<li><p>设备并没有分配给任何进程</p>
<p>在输入井或输出井中,分配给进程的是一存储区和建立一张I&#x2F;O请求表.</p>
</li>
<li><p>实现了虚拟设备功能</p>
<p>多个进程同时使用一独享设备,而对每一进程而言,都认为自己独占这一设备,不过,该设备是逻辑上的设备</p>
</li>
</ol>

        <h3 id="数据传输控制方式"   >
          <a href="#数据传输控制方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据传输控制方式" class="headerlink" title="数据传输控制方式"></a>数据传输控制方式</h3>
      <p><strong>程序直接控制</strong>：由用户进程来直接控制内存或CPU和外设间的信息传送。</p>
<p><strong>中断方式</strong>：进程通过CPU发出指令启动外设，该进程阻塞。当输入完成时，I&#x2F;O控制器通过中断请求线向CPU发出中断信号，CPU进行中断处理。</p>
<p><strong>DMA方式</strong>：在外设和内存之间开辟直接的数据交换通路。（成块）</p>
<p><strong>通道控制方式</strong>：CPU发出启动指令，指出通道相应的操作和I&#x2F;O 设备，该指令就可启动通道并使该通道从内存中调出相应的通道指令执行。（成组）</p>

        <h3 id="中断技术"   >
          <a href="#中断技术" class="heading-link"><i class="fas fa-link"></i></a><a href="#中断技术" class="headerlink" title="中断技术"></a>中断技术</h3>
      <p><strong>中断的概念</strong></p>
<p>指CPU对系统发生的某个事件作出的一种反应：</p>
<p>CPU暂停正在执行的程序，</p>
<p>保留现场后自动转去执行相应的处理程序，</p>
<p>处理完该事件后再返回断点继续执行被“打断”的程序。</p>
<p><strong>中断的处理过程</strong></p>
<p>1、保存被中断程序的现场，其目的是为了在中断处理完之后，可以返回到原来被中断的地方继续执行；</p>
<p>2、分析中断源，判断中断原因； </p>
<p>3、转去执行相应的处理程序； </p>
<p>4、恢复被中断程序现场，继续执行被中断程序。 </p>
<p><strong>分类</strong></p>
<p>根据中断源的产生的条件，可把中断分为<strong>外中断</strong>和<strong>内中断</strong></p>
<p>中断和陷阱的主要区别</p>
<p>将中断源按照外界因素的作用程度进行划分，常可分为自愿型中断与强迫型中断两大类</p>
<div class="table-container"><table>
<thead>
<tr>
<th align="left"></th>
<th>区别</th>
</tr>
</thead>
<tbody><tr>
<td align="left">中断</td>
<td><img src="D:/Documents/WeChat%20Files/wxid_ty1ak7qdulk622/FileStorage/Temp/85657902ab75540595b752303f0eb1d.jpg" alt="85657902ab75540595b752303f0eb1d" style="zoom: 33%;" />强迫型中断</td>
</tr>
<tr>
<td align="left">陷阱</td>
<td><img src="D:/Documents/WeChat%20Files/wxid_ty1ak7qdulk622/FileStorage/Temp/2876e996378f11d2051d0611885b93b.jpg" alt="2876e996378f11d2051d0611885b93b" style="zoom:33%;" />自愿型中断</td>
</tr>
</tbody></table></div>

        <h3 id="缓冲技术"   >
          <a href="#缓冲技术" class="heading-link"><i class="fas fa-link"></i></a><a href="#缓冲技术" class="headerlink" title="缓冲技术"></a>缓冲技术</h3>
      <p><strong>引入缓冲技术的原因</strong></p>
<p>1、改善CPU与I&#x2F;O设备间速度不匹配的矛盾</p>
<p>2、可以减少对 CPU的中断频率，放宽对中断响应时间的限制</p>
<p>3、提高 CPU和 I／O设备之间的并行性</p>
<p><strong>缓冲的设置</strong></p>
<p><strong>根据位置</strong>：专用硬件缓冲器，软件缓冲</p>
<p><strong>根据个数</strong>：单缓冲、双缓冲和缓冲池</p>

        <h3 id="设备分配数据结构"   >
          <a href="#设备分配数据结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#设备分配数据结构" class="headerlink" title="设备分配数据结构"></a>设备分配数据结构</h3>
      <img src="/images/image-20241212120917660.png" alt="image-20241212120917660" style="zoom:40%;" />


        <h3 id="设备无关性"   >
          <a href="#设备无关性" class="heading-link"><i class="fas fa-link"></i></a><a href="#设备无关性" class="headerlink" title="设备无关性"></a>设备无关性</h3>
      <p>为了提高系统的可适应性和可扩展性，我们希望所编制的用户程序与实际使用的物理设备无关，这就是所谓与<strong>设备无关性</strong>。</p>
<p>为此，我们将逻辑设备与物理设备区分，并引入逻辑设备名称和物理设备名称的概念</p>
<p><strong>为了实现与设备的无关性，系统中必须有一张联系逻辑设备名称和物理设备名称的映射表，（ＬＵＴ表）</strong></p>
<img src="/images/image-20241212121212267.png" alt="image-20241212121212267" style="zoom:33%;" />

<img src="/images/image-20241212121304673.png" alt="image-20241212121304673" style="zoom:45%;" />

<p><strong>用户I&#x2F;O</strong>：用户程序通过内核提供的系统调用接口与逻辑I&#x2F;O层交互</p>

        <h3 id="设备无关程序"   >
          <a href="#设备无关程序" class="heading-link"><i class="fas fa-link"></i></a><a href="#设备无关程序" class="headerlink" title="设备无关程序"></a>设备无关程序</h3>
      <p>对设备驱动程序的统一接口——向用户层软件提供一个一致接口</p>
<p>设备命名——设备无关软件负责将设备名映射到相应驱动程序</p>
<p>设备保护——检查是否有权访问申请的设备（个人计算机不提供任何保护）</p>
<p>提供独立于设备块大小——逻辑记录到物理记录的转换 </p>
<p>缓冲区管理与块设备的存储分配</p>
<p>独占性外围设备的分配和释放——通过 OPEN 打开相应的设备文件进行申请；关闭独占设备同时将释放该设备</p>
<p>错误报告——关键系统数据结构出错（如读磁盘使用状况位图），操作系统打印出错信息，并终止运行</p>

        <h3 id="设备驱动程序的功能"   >
          <a href="#设备驱动程序的功能" class="heading-link"><i class="fas fa-link"></i></a><a href="#设备驱动程序的功能" class="headerlink" title="设备驱动程序的功能"></a>设备驱动程序的功能</h3>
      <p>(1) <strong>接收</strong>由I&#x2F;O进程发来的<strong>命令和参数</strong>，并将命令中的抽象要求转换为具体要求，例如，将磁盘块号转换为磁盘的盘面、磁道号及扇区号。　</p>
<p>(2) 检查用户I&#x2F;O请求的<strong>合法性</strong>，了解I&#x2F;O设备的状态，传递有关参数，设置设备的工作方式。</p>
<p>(3) <strong>发出I&#x2F;O命令</strong>，如果设备空闲，便立即启动I&#x2F;O设备去完成指定的I&#x2F;O操作；如果设备处于忙碌状态，则将请求者的请求块挂在设备队列上等待。　</p>
<p>(4) 及时<strong>响应</strong>由控制器或通道发来的<strong>中断请求</strong>，并根据其中断类型调用相应的中断处理程序进行处理。</p>
<p>(5) 对于设置有通道的计算机系统，驱动程序还应能够根据用户的I&#x2F;O请求，自动地构成通道程序。</p>

        <h3 id="I-O中断处理程序"   >
          <a href="#I-O中断处理程序" class="heading-link"><i class="fas fa-link"></i></a><a href="#I-O中断处理程序" class="headerlink" title="I&#x2F;O中断处理程序"></a>I&#x2F;O中断处理程序</h3>
      <p>通知用户程序输入输出操作<strong>推进的程度</strong> </p>
<p>通知用户程序输入输出操作<strong>正常结束</strong>（设备通知通道&#x2F;控制器→CPU） </p>
<p>通知用户程序发现的输入输出操作<strong>异常</strong>，及提前中止操作的<strong>原因</strong></p>
<p>通知程序外围设备上有重要的<strong>异步信号</strong>，如设备报到、设备结束等 </p>

        <h3 id="LINUX操作系统"   >
          <a href="#LINUX操作系统" class="heading-link"><i class="fas fa-link"></i></a><a href="#LINUX操作系统" class="headerlink" title="LINUX操作系统"></a>LINUX操作系统</h3>
      <p><strong>Linux进程调度原则</strong>：</p>
<p>按照进程优先级，调度最高优先级进程</p>
<p>进程优先级随时间动态变化</p>
<p><strong>Linux的进程分为普通进程和实时进程</strong></p>
<p>对于普通进程采用可抢占式动态优先级调度：SCHED_OTHER</p>
<p>对于实时进程，采用两种调度策略：</p>
<p>基于优先级(rt-priority)的先进先出调度：SCHED_FIFO，</p>
<p>基于优先级(rt-priority)的时间片轮转调度：SCHED_RR</p>
<p><strong>Linux系统采用段页式存储管理技术，提供虚拟存储功能</strong></p>

        <h2 id="补充"   >
          <a href="#补充" class="heading-link"><i class="fas fa-link"></i></a><a href="#补充" class="headerlink" title="补充"></a>补充</h2>
      
        <h3 id="管程"   >
          <a href="#管程" class="heading-link"><i class="fas fa-link"></i></a><a href="#管程" class="headerlink" title="管程"></a>管程</h3>
      <p>是一种共享的数据结构，内部资源只能由内部函数访问，</p>
<p><strong>基本特征</strong>：</p>
<p>各外部进程&#x2F;线程只能通过管程提供的特定入口才能访问共享数据，</p>
<p>每次仅允许一个进程在管程内执行某个内部进程</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2025/11/23/Github%E9%85%8D%E7%BD%AEssh-key/">Github配置ssh key</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2025-11-23</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2025-11-26</span></span></div></header><div class="post-body"><div class="post-excerpt"><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://docs.github.com/zh/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account" >新增 SSH 密钥到 GitHub 帐户 - GitHub 文档</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h5 id="第一步"   >
          <a href="#第一步" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h5>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line">//看是否存在 id_rsa 和 id_rsa.pub文件，如果存在，说明已经有SSH Key</span><br></pre></td></tr></table></div></figure>


        <h5 id="第二步：生成ssh-key"   >
          <a href="#第二步：生成ssh-key" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二步：生成ssh-key" class="headerlink" title="第二步：生成ssh key"></a>第二步：生成ssh key</h5>
      <p>如果不存在ssh key，使用如下命令生成</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;xxx@xxx.com&quot;</span></span><br><span class="line">//执行后一直回车即可</span><br></pre></td></tr></table></div></figure>


        <h5 id="第三步：获取ssh-key公钥内容（id-rsa-pub）"   >
          <a href="#第三步：获取ssh-key公钥内容（id-rsa-pub）" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三步：获取ssh-key公钥内容（id-rsa-pub）" class="headerlink" title="第三步：获取ssh key公钥内容（id_rsa.pub）"></a>第三步：获取ssh key公钥内容（id_rsa.pub）</h5>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br><span class="line"><span class="built_in">cat</span> id_rsa.pub</span><br></pre></td></tr></table></div></figure>

<p>复制该内容</p>

        <h5 id="第四步：Github账号上添加公钥"   >
          <a href="#第四步：Github账号上添加公钥" class="heading-link"><i class="fas fa-link"></i></a><a href="#第四步：Github账号上添加公钥" class="headerlink" title="第四步：Github账号上添加公钥"></a>第四步：Github账号上添加公钥</h5>
      <p>进入Settings设置<br>添加ssh key，把刚才复制的内容粘贴上去保存即</p>

        <h5 id="第五步：验证是否设置成功"   >
          <a href="#第五步：验证是否设置成功" class="heading-link"><i class="fas fa-link"></i></a><a href="#第五步：验证是否设置成功" class="headerlink" title="第五步：验证是否设置成功"></a>第五步：验证是否设置成功</h5>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></div></figure>

<p><strong>注意之后在clone仓库的时候要使用ssh的url，而不是https！</strong></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2025/09/10/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">linux文件系统</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2025-09-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2025-11-26</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="Mysql问题"   >
          <a href="#Mysql问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#Mysql问题" class="headerlink" title="Mysql问题"></a>Mysql问题</h2>
      <p> 说一说事物隔离级别 </p>
<p>SQL标准的事务隔离级别包括：</p>
<p>读未提交，读提交，可重复读，串行化</p>
<p> 事务的四大特性有哪些？ </p>
<p>原子性，一致性，隔离性，持久性</p>

        <h2 id="Linux系统目录"   >
          <a href="#Linux系统目录" class="heading-link"><i class="fas fa-link"></i></a><a href="#Linux系统目录" class="headerlink" title="Linux系统目录"></a>Linux系统目录</h2>
      <p><img src="/images/linux_folder.jpeg" alt="目录2"></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2025/09/10/C++11%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/">C++11新特性总结</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2025-09-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2025-11-26</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="C-11新特性总结"   >
          <a href="#C-11新特性总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#C-11新特性总结" class="headerlink" title="C++11新特性总结"></a>C++11新特性总结</h1>
      
        <h3 id="final关键字"   >
          <a href="#final关键字" class="heading-link"><i class="fas fa-link"></i></a><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3>
      <p>使派生类不可覆盖它所修饰的虚函数</p>

        <h3 id="override描述符"   >
          <a href="#override描述符" class="heading-link"><i class="fas fa-link"></i></a><a href="#override描述符" class="headerlink" title="override描述符"></a>override描述符</h3>
      <p>如果派生类在虚函数声明时使用了override描述符，那么该函数必须重载其基类中的同名函数</p>

        <h3 id="关于左值，右值"   >
          <a href="#关于左值，右值" class="heading-link"><i class="fas fa-link"></i></a><a href="#关于左值，右值" class="headerlink" title="关于左值，右值"></a>关于左值，右值</h3>
      <p><code>C++</code>中所有的值都必然属于左值、右值二者之一。左值是指表达式结束后依然存在的<em>持久化对象</em>，右值是指表达式结束时就不再存在的<em>临时对象</em>。所有的具名变量或者对象都是左值，而右值不具名。很难得到左值和右值的真正定义，但是有一个可以区分左值和右值的便捷方法：<strong>看能不能对表达式取地址，如果能，则为左值，否则为右值</strong>。</p>

        <h3 id="右值引用"   >
          <a href="#右值引用" class="heading-link"><i class="fas fa-link"></i></a><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3>
      <p>左值是指可以出现在&#x3D;左侧者，</p>
<p>右值是指只能出现在&#x3D;右侧者</p>
<p>临时对象是个右值</p>

        <h5 id="右值引用与move语义的关系"   >
          <a href="#右值引用与move语义的关系" class="heading-link"><i class="fas fa-link"></i></a><a href="#右值引用与move语义的关系" class="headerlink" title="右值引用与move语义的关系"></a>右值引用与move语义的关系</h5>
      <ul>
<li>关联性: 右值引用是实现move语义的基础</li>
<li>作用: 允许”偷取”临时对象的资源而非复制</li>
<li>应用场景: 容器操作中大量临时对象的处理</li>
</ul>

        <h3 id="移动语义"   >
          <a href="#移动语义" class="heading-link"><i class="fas fa-link"></i></a><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h3>
      <p>右值则临时对象</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.<span class="built_in">insert</span>(ite,<span class="built_in">Vtype</span>(buf));</span><br></pre></td></tr></table></div></figure>

<p>左值则使用move关键字</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">M <span class="title">c1</span><span class="params">(c)</span></span>;</span><br><span class="line"><span class="function">M <span class="title">c2</span><span class="params">(std::move(c1))</span></span>;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>核心机制<ul>
<li>当赋值右侧是右值时，左侧对象可直接”偷取”资源</li>
<li>避免不必要的资源分配和拷贝</li>
</ul>
</li>
<li>实现要点<ul>
<li>类需要同时实现拷贝和移动语义版本</li>
<li>移动操作后原对象应处于有效但未定义状态</li>
<li>容器需要支持右值版本的插入操作</li>
</ul>
</li>
<li>注意事项<ul>
<li>被移动后的对象不应再使用</li>
<li>移动构造函数应标记为noexcept</li>
<li>临时对象自动被视为右值</li>
</ul>
</li>
<li>典型应用<ul>
<li>容器扩容时的元素迁移</li>
<li>返回临时对象的优化</li>
<li>明确不再使用的左值资源转移</li>
</ul>
</li>
</ul>
<p>应用</p>
<ol>
<li><strong>函数返回值优化</strong>。</li>
<li><strong>STL 容器的高效插入与操作</strong>。</li>
<li><strong>动态资源管理（如智能指针）</strong>。</li>
</ol>

        <h3 id="完美转发"   >
          <a href="#完美转发" class="heading-link"><i class="fas fa-link"></i></a><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h3>
      </div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2025/09/10/STL%E7%9A%84%E5%AF%B9%E6%AF%94/">STL的对比</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2025-09-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2025-11-26</span></span></div></header><div class="post-body"><div class="post-excerpt"><div class="table-container"><table>
<thead>
<tr>
<th>容器类型</th>
<th>底层数据结构</th>
<th>元素存储特点</th>
<th>访问方式</th>
<th>是否支持随机访问</th>
<th>动态大小调整</th>
<th>典型应用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>vector</code></strong></td>
<td>动态数组 (连续内存)</td>
<td>按加入顺序连续存储</td>
<td>下标访问 (<code>[]</code>)</td>
<td>是</td>
<td>是</td>
<td>动态数组的替代，快速随机访问，大量数据按顺序存取。</td>
</tr>
<tr>
<td><strong><code>deque</code></strong></td>
<td>分段连续内存</td>
<td>按加入顺序存储（分段实现）</td>
<td>双向访问（头尾操作快）</td>
<td>是</td>
<td>是</td>
<td>需要快速在首尾插入与删除，而仍然支持随机访问的场景。</td>
</tr>
<tr>
<td><strong><code>list</code></strong></td>
<td>双向链表</td>
<td>不连续，每个元素存储指针</td>
<td>双向遍历</td>
<td>否</td>
<td>是</td>
<td>频繁插入&#x2F;删除操作的场景，尤其在需要中间修改的情况下。</td>
</tr>
<tr>
<td><strong><code>forward_list</code></strong></td>
<td>单向链表</td>
<td>不连续，只有前向指针</td>
<td>单向遍历</td>
<td>否</td>
<td>是</td>
<td>内存占用较小的场景，在对链表操作需求简单时用作优化。</td>
</tr>
<tr>
<td><strong><code>array</code></strong></td>
<td>静态数组 (固定大小)</td>
<td>按加入顺序连续存储</td>
<td>下标访问 (<code>[]</code>)</td>
<td>是</td>
<td>否</td>
<td>小容量、固定大小、性能关键的场景，避免动态分配。</td>
</tr>
<tr>
<td><strong><code>set</code></strong></td>
<td>平衡二叉搜索树（通常是 Red-Black 树）</td>
<td>按键值自动排序</td>
<td>基于 key 查找和遍历</td>
<td>否</td>
<td>是</td>
<td>唯一值的集合，不允许重复值，支持快速有序的查找和插入。</td>
</tr>
<tr>
<td><strong><code>multiset</code></strong></td>
<td>平衡二叉搜索树</td>
<td>按键值自动排序</td>
<td>基于 key 查找和遍历</td>
<td>否</td>
<td>是</td>
<td>允许重复值的集合，多次插入同一值场景（按顺序存储）。</td>
</tr>
<tr>
<td><strong><code>map</code></strong></td>
<td>平衡二叉搜索树</td>
<td>按键值自动排序</td>
<td>基于 key 查找</td>
<td>否</td>
<td>是</td>
<td>有序的键值对储存，适合频繁按 key 查找具体值的场景。</td>
</tr>
<tr>
<td><strong><code>multimap</code></strong></td>
<td>平衡二叉搜索树</td>
<td>按键值自动排序</td>
<td>基于 key 查找</td>
<td>否</td>
<td>是</td>
<td>允许同一键值存在多个映射值的场景。</td>
</tr>
<tr>
<td><strong><code>unordered_set</code></strong></td>
<td>哈希表</td>
<td>无序存储</td>
<td>常数时间 key 查找</td>
<td>否</td>
<td>是</td>
<td>唯一值的集合，但无需排序，适合大量 key 快速判断是否存在的场景。</td>
</tr>
<tr>
<td><strong><code>unordered_multiset</code></strong></td>
<td>哈希表</td>
<td>无序存储</td>
<td>常数时间 key 查找</td>
<td>否</td>
<td>是</td>
<td>允许重复值的集合，但无序存储，适合大数据去重分析场景。</td>
</tr>
<tr>
<td><strong><code>unordered_map</code></strong></td>
<td>哈希表</td>
<td>无序存储</td>
<td>常数时间 key-value 查找</td>
<td>否</td>
<td>是</td>
<td>可快速通过 key 查找 value 的场景（无需排序）。</td>
</tr>
<tr>
<td><strong><code>unordered_multimap</code></strong></td>
<td>哈希表</td>
<td>无序存储</td>
<td>常数时间 key 查找</td>
<td>否</td>
<td>是</td>
<td>允许同一个 key 存储多个值（无需排序）的场景。</td>
</tr>
<tr>
<td><strong><code>stack</code></strong></td>
<td>基于 <code>deque</code> 实现</td>
<td>后进先出 (LIFO)</td>
<td>只访问顶端 (<code>top</code>)</td>
<td>否</td>
<td>是</td>
<td>后进先出的场景，比如函数调用栈、括号匹配等。</td>
</tr>
<tr>
<td><strong><code>queue</code></strong></td>
<td>基于 <code>deque</code> 实现</td>
<td>先进先出 (FIFO)</td>
<td>只访问头部和尾部</td>
<td>否</td>
<td>是</td>
<td>先进先出的场景，比如任务排队、消息队列等。</td>
</tr>
<tr>
<td><strong><code>priority_queue</code></strong></td>
<td>基于堆实现</td>
<td>按优先级排序</td>
<td>访问最大（默认情况）值</td>
<td>否</td>
<td>是</td>
<td>按优先级任务调度、动态获取最大&#x2F;最小值的场景。</td>
</tr>
<tr>
<td><strong><code>bitset</code></strong></td>
<td>定长的位数组</td>
<td>每个位存储 true&#x2F;false</td>
<td>位访问 (<code>[]</code>)</td>
<td>是</td>
<td>否</td>
<td>高效存储和操作布尔值，适合空间和位运算优化场景。</td>
</tr>
</tbody></table></div>

        <h4 id="1-底层数据结构"   >
          <a href="#1-底层数据结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-底层数据结构" class="headerlink" title="1. 底层数据结构"></a><strong>1. 底层数据结构</strong></h4>
      <ul>
<li><strong>动态数组</strong>：元素连续存放且可动态扩展的数组。</li>
<li><strong>链表</strong>：使用指针将元素链接而成的结构，可分为单向链表与双向链表。</li>
<li><strong>平衡二叉树</strong>：自平衡的二叉搜索树，常用的是红黑树（Red-Black Tree）。</li>
<li><strong>哈希表</strong>：以哈希函数作为索引，通过哈希冲突解决机制（如拉链法）高效存储数据。</li>
<li><strong>堆</strong>：通常是二叉堆，支持动态调整以保证堆顶始终是最大值或最小值。</li>
</ul>
<hr>

        <h4 id="2-元素存储特点"   >
          <a href="#2-元素存储特点" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-元素存储特点" class="headerlink" title="2. 元素存储特点"></a><strong>2. 元素存储特点</strong></h4>
      <ul>
<li><strong>连续存储</strong>：<code>vector</code> 和 <code>array</code> 采用连续存储，内存紧凑，随机访问快。</li>
<li><strong>分段连续存储</strong>：<code>deque</code> 分段实现，以保证在头尾添加数据的高效性。</li>
<li><strong>不连续存储</strong>：<code>list</code>、<code>forward_list</code>、<code>set</code> 等采用链表或树结构，插入&#x2F;删除效率高，但随机访问速度较慢。</li>
</ul>
<hr>

        <h4 id="3-访问方式"   >
          <a href="#3-访问方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-访问方式" class="headerlink" title="3. 访问方式"></a><strong>3. 访问方式</strong></h4>
      <ul>
<li><strong>下标访问 (<code>[]</code>)</strong>：<code>vector</code>、<code>array</code> 支持随机访问，可迅速获取指定位置的元素。</li>
<li><strong>头尾访问</strong>：<code>stack</code> 和 <code>queue</code> 限制为某些特定操作。</li>
<li><strong>优先访问</strong>：<code>priority_queue</code> 只能访问堆顶元素（最大值&#x2F;最小值）。</li>
<li><strong>基于 key 访问</strong>：<code>map</code>、<code>unordered_map</code> 以键值对方式支持查找。</li>
</ul>
<hr>

        <h4 id="4-是否支持随机访问"   >
          <a href="#4-是否支持随机访问" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-是否支持随机访问" class="headerlink" title="4. 是否支持随机访问"></a><strong>4. 是否支持随机访问</strong></h4>
      <ul>
<li>支持随机访问的容器（如 <code>vector</code>、<code>array</code>、<code>deque</code> 等）提供 O(1) 复杂度的下标访问，操作简单。</li>
<li>不支持随机访问的容器（如 <code>list</code>、<code>set</code> 等）需要遍历或依赖搜索结构，访问效率较低。</li>
</ul>
<hr>

        <h4 id="5-动态大小调整"   >
          <a href="#5-动态大小调整" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-动态大小调整" class="headerlink" title="5. 动态大小调整"></a><strong>5. 动态大小调整</strong></h4>
      <ul>
<li>动态容器（如 <code>vector</code>、<code>deque</code>、<code>list</code>）可以根据元素数目动态分配或收缩内存。</li>
<li>静态容器（如 <code>array</code>）在定义时需指定固定大小。</li>
</ul>
<hr>

        <h4 id="6-应用场景"   >
          <a href="#6-应用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-应用场景" class="headerlink" title="6. 应用场景"></a><strong>6. 应用场景</strong></h4>
      <p>每种容器都有其典型应用场景，选择合适的容器取决于业务需求（如性能、顺序性、查找效率）。</p>

        <h4 id="根据需求选择不同容器："   >
          <a href="#根据需求选择不同容器：" class="heading-link"><i class="fas fa-link"></i></a><a href="#根据需求选择不同容器：" class="headerlink" title="根据需求选择不同容器："></a>根据需求选择不同容器：</h4>
      <ol>
<li><strong>需要快速随机访问</strong>：使用 <code>vector</code>、<code>array</code>。</li>
<li><strong>需要频繁插入和删除</strong>：使用 <code>list</code>、<code>deque</code>（插入和删除表现良好）。</li>
<li><strong>需要数据自动排序</strong>：使用 <code>set</code>、<code>multiset</code>（有序集合）或 <code>map</code>、<code>multimap</code>（有序键值对）。</li>
<li><strong>需要快速查找，不关心顺序</strong>：优先选择哈希容器，比如 <code>unordered_set</code> 和 <code>unordered_map</code>。</li>
<li><strong>使用栈或队列模型</strong>：考虑 <code>stack</code>、<code>queue</code> 或 <code>priority_queue</code>。</li>
</ol>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2025/09/10/%E5%85%B3%E4%BA%8E%E9%A1%B9%E7%9B%AE/">关于项目</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2025-09-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2025-11-26</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>项目背景： 设计并实现了一个基于 Linux 平台的轻量级 HTTP 服务器，采用<strong>多 Reactor 多线程</strong>高并发模型，通过 <strong>epoll 提供高效的 I&#x2F;O 复用</strong>。结合<strong>自动增长缓冲区</strong>、<strong>定时器和异步日志</strong>等技术，实现了高性能和稳定运行的目标。 </p>
<p>主要工作  </p>
<p>内存优化：设计了<strong>内存池和 LFU 缓存</strong>，减少内存碎片，提升内存使用效率。  </p>
<p>高效事件处理：利用 <strong>epoll 多路复用机制</strong>，高效监听和处理客户端连接及数据传输事件。  </p>
<p>高并发模型：基于 <strong>Reactor 模型</strong>，实现 <strong>One Loop per Thread</strong>，支持多客户端并发连接。  </p>
<p>动态缓冲区：实现<strong>自动增长缓冲区</strong>，动态调整大小以适配不同请求，优化内存分配。  </p>
<p>连接管理：使用<strong>小根堆实现高效定时器</strong>，管理连接超时时间，防止长期空闲连接浪费资源。  </p>
<p>异步日志：设计<strong>异步日志</strong>模块，基于<strong>单例模式和阻塞队列</strong>，实现高效日志写入，避免同步写入的性能开销。 </p>

        <h2 id="关于项目"   >
          <a href="#关于项目" class="heading-link"><i class="fas fa-link"></i></a><a href="#关于项目" class="headerlink" title="关于项目"></a>关于项目</h2>
      
        <h3 id="介绍一下"   >
          <a href="#介绍一下" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍一下" class="headerlink" title="介绍一下"></a>介绍一下</h3>
      <p>本项目是一个高性能的WEB服务器，使用C++实现，项目底层采用了多线程多Reactor的网络模型，并且在这基础上增加了内存池，高效的双缓冲异步日志系统，以及LFU的缓存。</p>
<p>服务器的网络模型是<strong>主从reactor加线程池</strong>的模式，IO处理使用了<strong>非阻塞IO和IO多路复用技术</strong>，具备<strong>处理多个客户端</strong>的http请求和ftp请求，以及对外<strong>提供轻量级储存</strong>的能力。</p>
<p>项目中的工作可以分为两部分，</p>
<p>一部分是服务器网络框架、日志系统、存储引擎等一些基本系统的搭建，</p>
<p>另一部分 是为了提高服务器性能所做的一些优化，比如缓存机制、内存池等一些额外系统的搭建。</p>
<p>最后还对系统中的部分功能进行了功能和压力测试。对于存储引擎的压力测试，</p>
<p>在本地测试下，存储引擎读操作的QPS可以达到36万，写操作的QPS可以达到30万。对于网络框架的测试，使用webbench创建1000个进程对服务器进行60s并发请求，测试结果表明，对于短连接的QPS为1.8万，对于长连接的QPS为5.2万。</p>

        <h3 id="项目难点"   >
          <a href="#项目难点" class="heading-link"><i class="fas fa-link"></i></a><a href="#项目难点" class="headerlink" title="项目难点"></a>项目难点</h3>
      <p>根据工作分为两部分</p>
<p>一部分是服务器网络框架，日志系统，存储引擎等一些基本系统的搭建，这部分的难点主要就是技术理解和选型，以及将一些开源的框架调整后应用到我的项目中去。</p>
<p>另一部分就是性能优化方面，比如缓存机制，内存池等一些额外系统的搭建。这部分的难点在于找出服务器的性能瓶颈所在，然后结合自己的想法突破瓶颈，提高服务器性能。</p>

        <h3 id="遇到的困难，怎么解决"   >
          <a href="#遇到的困难，怎么解决" class="heading-link"><i class="fas fa-link"></i></a><a href="#遇到的困难，怎么解决" class="headerlink" title="遇到的困难，怎么解决"></a>遇到的困难，怎么解决</h3>
      <p>一方面是对技术理解不够深刻，难以选出合适的技术框架，这部分主要是阅读作者的技术文档，找相关的解析文章看</p>
<p>另一部分是编程遇到的困难，由于工程能力不足出现bug，这部分主要是通过日志定位bug，推断bug出现的原因并尝试修复，如果以自己能力无法修复，先问问ai能提供什么思路，或者搜索相关的博客。</p>

        <h2 id="内存优化"   >
          <a href="#内存优化" class="heading-link"><i class="fas fa-link"></i></a><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h2>
      <p>设计了<strong>内存池</strong>和 <strong>LFU 缓存</strong></p>

        <h3 id="缓存机制"   >
          <a href="#缓存机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h3>
      
        <h3 id="为什么选择LFU"   >
          <a href="#为什么选择LFU" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么选择LFU" class="headerlink" title="为什么选择LFU"></a>为什么选择LFU</h3>
      <p>因为最近加入的数据因为起始的频率很低，容易被淘汰，而早期的热点数据会一直占据缓存。</p>

        <h2 id="高效事件处理："   >
          <a href="#高效事件处理：" class="heading-link"><i class="fas fa-link"></i></a><a href="#高效事件处理：" class="headerlink" title="高效事件处理："></a>高效事件处理：</h2>
      <p><strong>epoll 多路复用机制</strong></p>
<p>采用非阻塞I&#x2F;O模型，执行系统调用就立即返回，不检查事件是否发生，没有立即发生返回-1，errno设置为在处理中。所以要采用I&#x2F;O通知机制（I&#x2F;O复用和SIGIO信号）来得知就绪事件。</p>
<figure class="highlight tex"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">I/O多路复用技术</span><br><span class="line">I/O 多路复用允许一个线程同时监视多个 I/O 文件描述符（如网络 socket），并在其中一个或多个文件描述符变为&quot;可操作&quot;时返回。应用程序可以据此进行相应的 I/O 操作（如读、写）。</span><br><span class="line"></span><br><span class="line">1.1 select</span><br><span class="line">简介</span><br><span class="line">select 是一种最早的 I/O 多路复用接口，几乎所有主流平台都支持。</span><br><span class="line"></span><br><span class="line">它允许程序监视多个文件描述符，查询它们是否可读、可写或出现错误。</span><br><span class="line">select 的接口会使用三个位图（readset、writeset 和 exceptset）指定文件描述符的状态。</span><br><span class="line">工作原理</span><br><span class="line">调用 select 时，程序将文件描述符集（一个位图）传递给内核。</span><br><span class="line">内核在超时时间内扫描这些文件描述符并返回那些状态发生变化的描述符（如变为可读或可写）。</span><br><span class="line">用户态程序可根据返回结果进行相应的 I/O 操作。</span><br><span class="line">缺点</span><br><span class="line">支持的文件描述符数量有限（通常受 FD<span class="built_in">_</span>SETSIZE 限制，默认 1024）。</span><br><span class="line">每次调用时都需要将文件描述符的状态从用户态复制到内核态，这带来一定的性能开销。</span><br><span class="line">内核需要线性遍历所有文件描述符（效率低），尤其在大并发连接时性能较差。</span><br><span class="line">1.2 poll</span><br><span class="line">简介</span><br><span class="line">poll 是 select 的改进版本，克服了文件描述符数量限制的问题。</span><br><span class="line"></span><br><span class="line">它使用一个数组结构而不是位图来描述文件描述符及其事件。</span><br><span class="line">工作原理</span><br><span class="line">用户定义一个 pollfd 数组，该数组中每一个元素保存一个文件描述符及其相关事件。</span><br><span class="line">调用 poll 时，内核会遍历这个数组，检查哪些文件描述符有事件发生，并返回结果。</span><br><span class="line">优点</span><br><span class="line">支持任意数量的文件描述符，突破了 select 的 FD<span class="built_in">_</span>SETSIZE 限制。</span><br><span class="line">缺点</span><br><span class="line">和 select 类似，每次调用都需要将监控的文件描述符数组从用户态复制到内核态，开销较大。</span><br><span class="line">和 select 一样，内核需要线性遍历文件描述符，在高并发场景下效率仍然较低。</span><br><span class="line">1.3 epoll</span><br><span class="line">简介</span><br><span class="line">epoll 是 Linux 平台下提供的高性能 I/O 多路复用接口，它是 select 和 poll 的替代品。</span><br><span class="line"></span><br><span class="line">epoll 被设计用于解决 select 和 poll 的性能问题，是一种效率更高的方式处理大量并发连接的技术。</span><br><span class="line">工作原理</span><br><span class="line">epoll 的核心思想是使用事件驱动机制（Event-Driven）替代轮询机制。</span><br><span class="line"></span><br><span class="line">创建一个 epoll 实例（epoll<span class="built_in">_</span>create），用作事件管理器。</span><br><span class="line">使用 epoll<span class="built_in">_</span>ctl 向内核注册需要监听的具体文件描述符及其事件类型（关注可读、可写或异常事件）。</span><br><span class="line">调用 epoll<span class="built_in">_</span>wait，等待事件发生。</span><br><span class="line">发生事件的文件描述符被加入到一个内核维护的就绪列表，并从中直接返回。</span><br><span class="line">这避免了不必要的遍历额外文件描述符的开销。</span><br><span class="line">优点</span><br><span class="line">事件驱动模型：文件描述符有变化时通过回调机制加入就绪列表，只需处理活跃文件描述符。</span><br><span class="line">无大小限制：最大受限于系统的内存资源，而非固定限制。</span><br><span class="line">高性能：避免了线性遍历，即使监视十万连接，只需处理少量已就绪的描述符。</span><br><span class="line">缺点</span><br><span class="line">仅支持 Linux 系统，不跨平台。</span><br><span class="line">epoll 的两种触发模式</span><br><span class="line">LT（Level Trigger，水平触发）： 默认模式，文件描述符只要处于就绪状态，就会不断返回。</span><br><span class="line">ET（Edge Trigger，边缘触发）： 更高效，只在文件描述符状态从未就绪到就绪时触发（适用于非阻塞 I/O）</span><br></pre></td></tr></table></div></figure>


        <h3 id="IO多路复用"   >
          <a href="#IO多路复用" class="heading-link"><i class="fas fa-link"></i></a><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3>
      
        <h3 id="LT与ET"   >
          <a href="#LT与ET" class="heading-link"><i class="fas fa-link"></i></a><a href="#LT与ET" class="headerlink" title="LT与ET"></a>LT与ET</h3>
      <p>LT:水平触发模式，只要内核缓冲区有数据就一直通知，只要socket处于可读状态就一直返回sockfd；是默认的工作模式，支持阻塞IO和非阻塞IO</p>
<p>ET：边沿触发模式，只有状态发生变化才通知并且这个状态只会通知一次，只有当socket由不可写到可写或由不可读到可读，才会返回sockfd：只支持非阻塞IO</p>

        <h3 id="为什么用epoll，其他多路复用方式以及区别"   >
          <a href="#为什么用epoll，其他多路复用方式以及区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么用epoll，其他多路复用方式以及区别" class="headerlink" title="为什么用epoll，其他多路复用方式以及区别"></a>为什么用epoll，其他多路复用方式以及区别</h3>
      
        <h2 id="高并发模型"   >
          <a href="#高并发模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#高并发模型" class="headerlink" title="高并发模型"></a>高并发模型</h2>
      <p>基于 <strong>Reactor 模型</strong>，实现 One Loop per Thread</p>
<p>Reactor模式通常用同步I&#x2F;O模型实现</p>
<p>Proactor模式通常用异步I&#x2F;O模型实现</p>
<ol>
<li>主线程往epoll内核事件表注册socket读就绪事件</li>
<li>主线程调用epoll_wait等待socket上有数据可读</li>
<li>当socket上有数据可读时，epoll_wait通知主线程，主线程将socket可读事件放入请求队列</li>
<li>工作线程被唤醒，读数据处理请求，然后往epoll内核事件表注测socket写就绪事件</li>
<li>主线程调用epoll_wait等待socket可写</li>
<li>当socket可写，epoll_wait通知主线程，主线程将socket可写事件放入请求队列</li>
<li>睡眠在请求队列的工作线程被唤醒，往socket上写入服务器处理客户请求的结果</li>
</ol>

        <h2 id="动态缓冲区"   >
          <a href="#动态缓冲区" class="heading-link"><i class="fas fa-link"></i></a><a href="#动态缓冲区" class="headerlink" title="动态缓冲区"></a>动态缓冲区</h2>
      <p>实现<strong>自动增长缓冲区</strong></p>
<p><strong>1. 核心数据结构</strong></p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">char</span>&gt; buffer_;  <span class="comment">// 主缓冲区（使用vector自动管理内存）</span></span><br><span class="line">    <span class="type">size_t</span> readerIndex_;         <span class="comment">// 读指针（数据起始位置）</span></span><br><span class="line">    <span class="type">size_t</span> writerIndex_;         <span class="comment">// 写指针（数据结束位置）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>采用vector作为底层容器，自动处理内存分配&#x2F;释放</p>
<p>读写指针分离设计，支持零拷贝操作</p>
<p><code>零拷贝是指计算机执行IO操作时，CPU不需要将数据从一个存储区域复制到另一个存储区域，从而可以减少上下文切换以及CPU的拷贝时间。它是一种I/O操作优化技术。</code></p>
<p><strong>2. 自动增长机制</strong></p>
<p><strong>(1) 扩容触发条件</strong></p>
<p>当<code>writableBytes() &lt; 待写入数据量</code>时自动扩容</p>
<p>通过vector的resize实现：</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* data, <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">writableBytes</span>() &lt; len) &#123;</span><br><span class="line">        <span class="built_in">makeSpace</span>(len);  <span class="comment">// 扩容操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">copy</span>(data, data+len, <span class="built_in">beginWrite</span>());</span><br><span class="line">    writerIndex_ += len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>(2) 智能扩容策略</strong></p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeSpace</span><span class="params">(<span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">writableBytes</span>() + <span class="built_in">prependableBytes</span>() &lt; len) &#123;</span><br><span class="line">        <span class="comment">// 需要真正扩容：vector.resize(writerIndex_ + len)</span></span><br><span class="line">        buffer_.<span class="built_in">resize</span>(writerIndex_ + len);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 通过移动数据复用空间</span></span><br><span class="line">        <span class="type">size_t</span> readable = <span class="built_in">readableBytes</span>();</span><br><span class="line">        std::<span class="built_in">copy</span>(<span class="built_in">begin</span>()+readerIndex_, <span class="built_in">begin</span>()+writerIndex_, <span class="built_in">begin</span>());</span><br><span class="line">        readerIndex_ = <span class="number">0</span>;</span><br><span class="line">        writerIndex_ = readable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



<p><strong>3. 高性能IO优化</strong></p>
<p><strong>(1) 双缓冲区读操作</strong></p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">readFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* saveErrno)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> extrabuf[<span class="number">65536</span>]; <span class="comment">// 64KB栈缓冲区</span></span><br><span class="line">    iovec vec[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    vec[<span class="number">0</span>].iov_base = <span class="built_in">begin</span>() + writerIndex_;</span><br><span class="line">    vec[<span class="number">0</span>].iov_len = <span class="built_in">writableBytes</span>();</span><br><span class="line">    vec[<span class="number">1</span>].iov_base = extrabuf;</span><br><span class="line">    vec[<span class="number">1</span>].iov_len = <span class="built_in">sizeof</span>(extrabuf);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据剩余空间决定使用1个还是2个缓冲区</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> iovcnt = (<span class="built_in">writableBytes</span>() &lt; <span class="built_in">sizeof</span>(extrabuf)) ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="type">ssize_t</span> n = <span class="built_in">readv</span>(fd, vec, iovcnt);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理读入的数据...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>使用<code>readv</code>系统调用实现分散读</p>
<p>优先使用主缓冲区空间，不足时使用栈缓冲区过渡</p>
<p>避免频繁扩容带来的性能损耗</p>
<p><strong>(2) 写操作优化</strong></p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">writeFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* saveErrno)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ::<span class="built_in">write</span>(fd, <span class="built_in">peek</span>(), <span class="built_in">readableBytes</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>直接使用<code>write</code>系统调用</p>
<p><code>peek()</code>返回有效数据起始指针，避免内存拷贝</p>
<p><strong>4. 关键特性总结</strong></p>
<ol>
<li><p><strong>智能扩容</strong>：按需自动增长，兼顾内存使用效率</p>
</li>
<li><p><strong>零拷贝设计</strong>：读写指针分离，减少内存拷贝</p>
</li>
<li><p><strong>双缓冲策略</strong>：栈空间+主缓冲区组合优化IO性能</p>
</li>
<li><p><strong>线程安全</strong>：单次IO操作原子性保证</p>
</li>
<li><p><strong>内存高效</strong>：自动回收已读区域空间</p>
</li>
</ol>
<p>典型工作流程：</p>
<ol>
<li><p>读取数据时优先使用主缓冲区空间</p>
</li>
<li><p>空间不足时暂存到栈缓冲区</p>
</li>
<li><p>触发自动扩容后合并数据</p>
</li>
<li><p>写入数据时直接操作有效数据区域</p>
</li>
</ol>

        <h2 id="连接管理"   >
          <a href="#连接管理" class="heading-link"><i class="fas fa-link"></i></a><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2>
      <p>使用<strong>小根堆实现高效定时器</strong>，管理连接超时时间</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Entry = std::pair&lt;Timestamp, Timer*&gt;; <span class="comment">// 以时间戳作为键值获取定时器</span></span><br><span class="line"><span class="keyword">using</span> TimerList = std::set&lt;Entry&gt;;          <span class="comment">// 底层使用红黑树管理，自动按照时间戳进行排序</span></span><br></pre></td></tr></table></div></figure>

<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定时器管理红黑树插入此新定时器</span></span><br><span class="line">timers_.<span class="built_in">insert</span>(<span class="built_in">Entry</span>(when, timer));</span><br></pre></td></tr></table></div></figure>








        <h2 id="异步日志"   >
          <a href="#异步日志" class="heading-link"><i class="fas fa-link"></i></a><a href="#异步日志" class="headerlink" title="异步日志"></a>异步日志</h2>
      <p>设计<strong>异步日志</strong>模块，基于<strong>单例模式和阻塞队列</strong></p>
<p>日志系统是多生产者，单消费者的任务场景</p>
<p>多生产者负责把日志写入缓冲区，单消费者负责把缓冲区数据写入文件</p>
<p><img   src="https://cdn.nlark.com/yuque/0/2025/png/47188040/1737792284038-49feb6bc-6920-4e1c-9c4a-516ffee44982.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_26,text_5Luj56CB6ZqP5oOz5b2V55-l6K-G5pif55CD,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" style="width: image/watermark,type_d3F5LW1pY3JvaGVp,size_26,tepx;height: t_5Luj56CB6ZqP5oOz5b2V55-l6K-G5pif55CD,color_FFFFFF,shadow_50,t_80,g_se,px;"  alt="img"></p>
<p>前端往后端写，后端往硬盘写</p>
<p>双缓冲技术 ，写满就交换，相当于将多条日志拼接成一个大buffer传送到后端然后写入文件，减少了线程开销</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2025/09/10/%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98/">其他问题</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2025-09-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2025-11-26</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="Mysql问题"   >
          <a href="#Mysql问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#Mysql问题" class="headerlink" title="Mysql问题"></a>Mysql问题</h2>
      <p> 说一说事物隔离级别 </p>
<p>SQL标准的事务隔离级别包括：</p>
<p>读未提交，读提交，可重复读，串行化</p>
<p> 事务的四大特性有哪些？ </p>
<p>原子性，一致性，隔离性，持久性</p>

        <h2 id="Linux系统目录"   >
          <a href="#Linux系统目录" class="heading-link"><i class="fas fa-link"></i></a><a href="#Linux系统目录" class="headerlink" title="Linux系统目录"></a>Linux系统目录</h2>
      <p><img src="/images/linux_folder.webp" alt="目录2" title="linux系统文件夹"></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2025/09/10/%E5%85%B6%E4%BB%96%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98/">其他项目问题</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2025-09-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2025-11-26</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h3 id="为什么服务器要以root身份启动，不能以root身份运行"   >
          <a href="#为什么服务器要以root身份启动，不能以root身份运行" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么服务器要以root身份启动，不能以root身份运行" class="headerlink" title="为什么服务器要以root身份启动，不能以root身份运行"></a>为什么服务器要以root身份启动，不能以root身份运行</h3>
      <p>为什么要以 root 启动？</p>
<p>绑定低编号端口（如 80、443）。<br>配置共享内存、设备文件、调整资源等需要的高权限操作。</p>
<p>为什么不能以 root 运行？</p>
<p>潜在漏洞可能导致系统被完全攻破。<br>不符合最小权限原则。<br>服务隔离无法实现，其他服务可能受到影响。<br>意外操作可能导致灾难性的后果。<br>如何解决这个问题？</p>
<p>启动时以 root 完成特权操作，然后立刻降级为普通用户运行。<br>使用 setuid() 和 setgid() 等 Linux 用户管理接口实现特权降级。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2025/09/10/%E5%AD%97%E8%8A%82%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">字节面试准备</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2025-09-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2025-11-26</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="字节面试准备"   >
          <a href="#字节面试准备" class="heading-link"><i class="fas fa-link"></i></a><a href="#字节面试准备" class="headerlink" title="字节面试准备"></a>字节面试准备</h1>
      
        <h3 id="1-C-基础"   >
          <a href="#1-C-基础" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-C-基础" class="headerlink" title="1. C++ 基础"></a><strong>1. C++ 基础</strong></h3>
      
        <h4 id="1-面向对象的三个特性"   >
          <a href="#1-面向对象的三个特性" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-面向对象的三个特性" class="headerlink" title="(1) 面向对象的三个特性"></a><strong>(1) 面向对象的三个特性</strong></h4>
      <p>C++ 是一种支持面向对象编程的语言，其面向对象编程的三个核心特性是：封装（Encapsulation）、继承（Inheritance）、多态（Polymorphism）。</p>
<ul>
<li><p><strong>封装</strong><br>封装是将数据（成员变量）和操作这些数据的代码（成员函数）绑定在一起，形成一个整体（类）。<br><strong>优点：</strong></p>
<ul>
<li>限制对内部成员的访问，保护数据隐私（通过 <code>public</code>、<code>protected</code>、<code>private</code> 访问权限控制关键字）。</li>
<li>提高代码的可维护性和复用性。</li>
</ul>
</li>
<li><p><strong>继承</strong><br>继承是一种用于实现代码复用和建立层次化关系的机制。子类可以继承父类的属性和行为。<br><strong>优点：</strong></p>
<ul>
<li>重用父类代码。</li>
<li>可以通过父类指针或引用操作多态对象。</li>
</ul>
</li>
<li><p><strong>多态</strong><br>多态是允许通过基类引用或指针访问派生类对象，并调用派生类的重写方法。基于动态绑定（Run-time Polymorphism）的多态主要通过虚函数实现。<br><strong>优点：</strong></p>
<ul>
<li>提高代码的扩展性和灵活性，可以使用统一的接口处理不同类型的对象。</li>
</ul>
</li>
</ul>

        <h4 id="2-多态和虚函数的底层实现"   >
          <a href="#2-多态和虚函数的底层实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-多态和虚函数的底层实现" class="headerlink" title="(2) 多态和虚函数的底层实现"></a><strong>(2) 多态和虚函数的底层实现</strong></h4>
      <ul>
<li><p><strong>多态的实现</strong></p>
<ul>
<li>多态的核心是通过 <strong>虚函数表（Virtual Table）和虚函数表指针</strong>实现的。</li>
<li>编译器会在类中生成一个指向虚函数表的指针，称为 <strong>vptr</strong>。</li>
<li>虚函数表是一个数组，存储了该类的所有虚函数的函数指针。</li>
<li>在运行时，通过 <code>vptr</code> 指向的虚函数表，根据实际的动态类型调用对应的方法。</li>
</ul>
</li>
<li><p><strong>虚函数的底层实现</strong></p>
<ul>
<li>类中有虚函数时，类会生成一个虚函数表（存储虚函数指针）。</li>
<li>每个对象的内存布局中会加入一个指向虚函数表的指针（vptr）。</li>
<li>通过 <code>vptr</code> 和虚函数表在运行时找到并调用具体的函数。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* obj = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    obj-&gt;<span class="built_in">display</span>(); <span class="comment">// 执行 Derived::display()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>区别场景：带虚函数与不带虚函数</strong></p>
<ul>
<li>如果类中没有虚函数，那么对象内存只存储成员变量。</li>
<li>带虚函数的类，内存中会存储额外的虚函数表指针。</li>
<li>因此，带虚函数的对象的内存占用会比没有虚函数的对象多。</li>
</ul>
<hr>

        <h4 id="3-多继承的特殊情况（菱形继承问题）"   >
          <a href="#3-多继承的特殊情况（菱形继承问题）" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-多继承的特殊情况（菱形继承问题）" class="headerlink" title="(3) 多继承的特殊情况（菱形继承问题）"></a><strong>(3) 多继承的特殊情况（菱形继承问题）</strong></h4>
      <p>场景：如何区分多继承中调用的同名成员和方法？</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;A::func()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;B::func()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;C::func()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    D obj;</span><br><span class="line">    <span class="comment">// 调用 B::func 或 C::func？</span></span><br><span class="line">    obj.B::<span class="built_in">func</span>(); <span class="comment">// 通过类名加作用域区分</span></span><br><span class="line">    obj.C::<span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>菱形继承问题的解决方式：</strong></p>
<ul>
<li>普通继承会导致 <code>A</code> 的成员在 <code>B</code> 和 <code>C</code> 中各有一份（两份副本）。</li>
<li>使用 <strong>虚继承</strong> 可以解决该问题，确保 <code>A</code> 的成员在多继承的子类中只有一份。</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="keyword">public</span>: <span class="type">int</span> x; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;&#125;;</span><br></pre></td></tr></table></div></figure>

<p><code>D</code> 类中只有一份 <code>A::x</code>。</p>
<hr>

        <h3 id="3-内存"   >
          <a href="#3-内存" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-内存" class="headerlink" title="3. 内存"></a><strong>3. 内存</strong></h3>
      
        <h4 id="1-malloc-和-new-的区别"   >
          <a href="#1-malloc-和-new-的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-malloc-和-new-的区别" class="headerlink" title="(1) malloc 和 new 的区别"></a><strong>(1) malloc 和 new 的区别</strong></h4>
      <ol>
<li><p><strong><code>malloc</code>：</strong></p>
<ul>
<li>只分配内存，不调用构造函数。</li>
<li>返回 <code>void*</code> 需要强制类型转换。</li>
<li>需要 <code>free</code> 手动释放。</li>
</ul>
</li>
<li><p><strong><code>new</code>：</strong></p>
<ul>
<li>分配内存并自动调用构造函数初始化对象。</li>
<li>返回目标类型的指针，无需强转。</li>
<li>使用 <code>delete</code> 释放内存并调用析构函数。</li>
</ul>
</li>
</ol>

        <h4 id="2-只分配内存或只调用构造函数"   >
          <a href="#2-只分配内存或只调用构造函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-只分配内存或只调用构造函数" class="headerlink" title="(2) 只分配内存或只调用构造函数"></a><strong>(2) 只分配内存或只调用构造函数</strong></h4>
      <ol>
<li><p>只分配内存（不调用构造函数）：</p>
<ul>
<li>可使用 <code>operator new</code>：<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* ptr = ::<span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(MyClass)); <span class="comment">// 只分配内存</span></span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>只调用构造函数（对象已分配内存）：</p>
<ul>
<li>可通过 <code>placement new</code>：<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass* obj = <span class="built_in">new</span>(ptr) <span class="built_in">MyClass</span>(args); <span class="comment">// 在已有内存 `ptr` 上构造对象</span></span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
</ol>
<p><strong>operator new：用来分配原始内存，不涉及对象的构造。</strong><br><strong>operator delete：用来释放原始内存，不涉及对象的析构。</strong><br>普通的 new 调用等价于：</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass* obj = <span class="built_in">static_cast</span>&lt;MyClass*&gt;(::<span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(MyClass))); <span class="comment">// 分配内存</span></span><br><span class="line"><span class="keyword">new</span> (obj) <span class="built_in">MyClass</span>(); <span class="comment">// 构造对象</span></span><br></pre></td></tr></table></div></figure>


<p>普通的 delete 调用等价于：</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj-&gt;~<span class="built_in">MyClass</span>();             <span class="comment">// 调用析构函数</span></span><br><span class="line">::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(obj)</span></span>;      <span class="comment">// 释放内存</span></span><br></pre></td></tr></table></div></figure>

<p><strong>注意：new不能重载，只有operator new才能重载</strong></p>

        <h4 id="3-sizeof-结构体的对齐规则"   >
          <a href="#3-sizeof-结构体的对齐规则" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-sizeof-结构体的对齐规则" class="headerlink" title="(3) sizeof 结构体的对齐规则"></a><strong>(3) <code>sizeof</code> 结构体的对齐规则</strong></h4>
      <p>C++ 中结构体内存对齐主要受到以下因素影响：</p>
<ol>
<li>每个成员变量的对齐方式由编译器决定（通常与成员类型的大小相关）。</li>
<li><strong>结构体的总大小必须是最大对齐成员的倍数。</strong></li>
</ol>
<p>示例：</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S1</span> &#123;</span><br><span class="line">    <span class="type">char</span> A;  <span class="comment">// 1 字节</span></span><br><span class="line">    <span class="type">char</span> B;  <span class="comment">// 1 字节</span></span><br><span class="line">    <span class="type">int</span> C;   <span class="comment">// 4 字节</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S2</span> &#123;</span><br><span class="line">    <span class="type">char</span> A;  <span class="comment">// 1 字节</span></span><br><span class="line">    <span class="type">int</span> C;   <span class="comment">// 4 字节</span></span><br><span class="line">    <span class="type">char</span> B;  <span class="comment">// 1 字节</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
<ul>
<li>对于 S1，内存布局为：<code>A + B + padding + C</code>（总大小 8）</li>
<li>对于 S2，内存布局为：<code>A + padding + C + B + padding</code>（总大小 12）</li>
</ul>

        <h3 id="4-STL-和智能指针"   >
          <a href="#4-STL-和智能指针" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-STL-和智能指针" class="headerlink" title="4. STL 和智能指针"></a><strong>4. STL 和智能指针</strong></h3>
      
        <h4 id="1-智能指针概览"   >
          <a href="#1-智能指针概览" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-智能指针概览" class="headerlink" title="(1) 智能指针概览"></a><strong>(1) 智能指针概览</strong></h4>
      <p>C++ 标准库提供了三种智能指针：</p>
<ol>
<li><strong><code>std::unique_ptr</code></strong>: 独占所有权，不可复制。</li>
<li><strong><code>std::shared_ptr</code></strong>: 共享所有权，使用引用计数。</li>
<li><strong><code>std::weak_ptr</code></strong>: 使用弱引用，依赖 <code>shared_ptr</code>，避免循环引用。</li>
</ol>

        <h4 id="2-std-shared-ptr-的实际应用"   >
          <a href="#2-std-shared-ptr-的实际应用" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-std-shared-ptr-的实际应用" class="headerlink" title="(2) std::shared_ptr 的实际应用"></a><strong>(2) <code>std::shared_ptr</code> 的实际应用</strong></h4>
      <ul>
<li>场景：共享资源的生命周期管理（如线程池中的任务对象）。</li>
<li>示例：<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; q = p; <span class="comment">// 引用计数+1</span></span><br><span class="line">&#125; <span class="comment">// q 离开作用域，引用计数-1</span></span><br></pre></td></tr></table></div></figure></li>
</ul>
<p><strong>使用智能指针（如 std::shared_ptr）的优点</strong>：</p>
<p>自动化的内存管理，避免内存泄漏和悬垂指针。简化代码逻辑，减少人工管理内存的复杂性。更容易与标准容器（如 std::vector）配合使用。不使用智能指针是可以的，</p>
<p>但代价是：</p>
<p>更容易引入 bug，例如内存泄漏、悬垂指针问题。<br>增加代码维护难度，并且可能需要大量的单元测试来覆盖所有的边界情况。<br>难以保证代码的健壮性，特别是在复杂的资源关系中。</p>

        <h3 id="RAII是什么"   >
          <a href="#RAII是什么" class="heading-link"><i class="fas fa-link"></i></a><a href="#RAII是什么" class="headerlink" title="RAII是什么"></a>RAII是什么</h3>
      <p>RAII（Resource Acquisition Is Initialization，资源获取即初始化）是一种资源管理的编程惯用法，是 C++ 中处理资源管理的重要设计理念。它通过将资源的生命周期与对象的生命周期绑定来确保资源得到正确的分配和释放，从而避免资源泄漏。</p>
<p><strong>核心思想</strong></p>
<ol>
<li><p><strong>资源绑定到对象的生命周期</strong>：</p>
<ul>
<li>当一个对象在栈上或通过堆分配时，与该对象相关联的资源（例如内存、文件句柄、锁、网络连接等）也随之初始化。</li>
<li>当该对象离开作用域（或者析构）时，资源会被自动释放。</li>
</ul>
</li>
<li><p><strong>依靠析构函数来释放资源</strong>：</p>
<ul>
<li>C++ 中，当一个对象生命周期结束时，其析构函数会被自动调用。因此，可以利用析构函数自动释放资源，而无需手动释放。</li>
<li>通过 RAII，资源分配后不用担心异常、早退或其他复杂逻辑干扰正确释放。</li>
</ul>
</li>
</ol>
<p><strong>RAII 的优点</strong></p>
<ol>
<li><strong>自动化资源管理</strong>：用户不需要手动释放资源，不用担心遗漏或错误。</li>
<li><strong>异常安全</strong>：即使代码中间发生异常，析构函数仍然会自动释放资源。</li>
<li><strong>代码简洁</strong>：减少了显式的资源释放代码，避免了冗余或错误。</li>
</ol>
<p><strong>应用场景</strong></p>
<p>RAII 在内存分配、文件操作、线程锁、数据库连接等场景广泛应用。例如：</p>
<ol>
<li><strong>智能指针</strong>：<ul>
<li><code>std::unique_ptr</code>：独占资源，适合动态内存管理。</li>
<li><code>std::shared_ptr</code>：共享资源，适合多个对象共享动态内存。</li>
</ul>
</li>
<li><strong>互斥锁</strong>：<ul>
<li><code>std::lock_guard&lt;std::mutex&gt;</code> 和 <code>std::unique_lock</code>。</li>
</ul>
</li>
<li><strong>文件与流对象</strong>：<ul>
<li>C++ 的 IO 流类如 <code>std::ifstream</code> 和 <code>std::ofstream</code>。</li>
</ul>
</li>
<li><strong>其他自定义的资源管理类</strong>：<ul>
<li>如管理数据库连接、网络套接字、句柄等。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<p>RAII 的核心就是将资源的生命周期绑定到对象的生命周期，通过构造函数和析构函数确保资源的正确分配和释放。这种机制有效避免了手动管理资源时的各种问题（如资源泄漏、重复释放等），是 C++ 中非常重要的编程思想，尤其在异常安全和代码简洁性方面效果显著。</p>
<p>面试中，如果被问到 RAII，你可以直接引用 C++ 智能指针、文件流或锁管理类作为例子展开解释。进一步可以说明 RAII 提升了程序的安全性及简洁性，使 C++ 的资源管理更加工程化和易用化。</p>

        <h3 id="5-操作系统"   >
          <a href="#5-操作系统" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-操作系统" class="headerlink" title="5. 操作系统"></a><strong>5. 操作系统</strong></h3>
      
        <h4 id="1-并发与并行的区别"   >
          <a href="#1-并发与并行的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-并发与并行的区别" class="headerlink" title="(1) 并发与并行的区别"></a><strong>(1) 并发与并行的区别</strong></h4>
      <ul>
<li><strong>并发（Concurrency）</strong>：多个任务在逻辑上<strong>同时进行</strong>，但实际上可能是按时间片交替执行。</li>
<li><strong>并行（Parallelism）</strong>：多个任务在物理上<strong>真正同时运行</strong>（需要多核 CPU 支持）。</li>
</ul>

        <h4 id="2-最大并发线程池设计"   >
          <a href="#2-最大并发线程池设计" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-最大并发线程池设计" class="headerlink" title="(2) 最大并发线程池设计"></a><strong>(2) 最大并发线程池设计</strong></h4>
      <ul>
<li>关键点：<ol>
<li>使用任务队列管理任务。</li>
<li>通过信号量或条件变量限制线程并发数量。</li>
<li>动态创建、销毁线程降低资源消耗（即线程复用）。</li>
</ol>
</li>
</ul>
<hr>

        <h3 id="6-网络"   >
          <a href="#6-网络" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-网络" class="headerlink" title="6. 网络"></a><strong>6. 网络</strong></h3>
      
        <h4 id="1-HTTPS-的通信过程"   >
          <a href="#1-HTTPS-的通信过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-HTTPS-的通信过程" class="headerlink" title="(1) HTTPS 的通信过程"></a><strong>(1) HTTPS 的通信过程</strong></h4>
      <ol>
<li><strong>客户端发送请求</strong>，包括支持的协议版本、加密套件等。</li>
<li><strong>服务器发送证书</strong>，客户端验证证书的合法性。</li>
<li><strong>TLS 握手</strong>，双方协商对称密钥（通过非对称加密交换密钥）。</li>
<li><strong>加密通信</strong>，之后的所有数据使用对称密钥加密。</li>
</ol>
<hr>

        <h3 id="7-项目挑战"   >
          <a href="#7-项目挑战" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-项目挑战" class="headerlink" title="7. 项目挑战"></a><strong>7. 项目挑战</strong></h3>
      
        <h4 id="Buffer-的思想"   >
          <a href="#Buffer-的思想" class="heading-link"><i class="fas fa-link"></i></a><a href="#Buffer-的思想" class="headerlink" title="Buffer 的思想"></a><strong>Buffer 的思想</strong></h4>
      <ul>
<li><strong>临时缓存</strong>用于解决数据处理速度的差异（如网络接收速度慢于处理速度）。</li>
<li>**自动增长：**通过动态分配内存扩容实现，常用 <strong>指数增长（2 倍增长）</strong> 策略；也可以按照具体业务需要调整。</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2025/09/10/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/">智能指针</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2025-09-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2025-11-26</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="智能指针"   >
          <a href="#智能指针" class="heading-link"><i class="fas fa-link"></i></a><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2>
      
        <h3 id="unique-ptr"   >
          <a href="#unique-ptr" class="heading-link"><i class="fas fa-link"></i></a><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a><strong>unique_ptr</strong></h3>
      <p>作用域指针，不能复制</p>
<p>栈分配指针，当死亡时，自动释放所管理的内存，无需显示调用delete</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; p1 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>); <span class="comment">// 管理动态分配的内存</span></span><br><span class="line"><span class="comment">// std::unique_ptr&lt;int&gt; p2 = p1; // 错误！unique_ptr不支持拷贝</span></span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; p2 = std::<span class="built_in">move</span>(p1); <span class="comment">// 通过 std::move 转移所有权</span></span><br></pre></td></tr></table></div></figure>

<p>只能显示调用构造函数，因为其构造函数有<code>explicit</code>关键字，没有了构造函数的隐式转换</p>
<p>最好的调用还是使用<code>make_unique</code>会捕获异常，不会产生悬空指针问题</p>

        <h3 id="shared-ptr"   >
          <a href="#shared-ptr" class="heading-link"><i class="fas fa-link"></i></a><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a><strong>shared_ptr</strong></h3>
      <p>追踪引用计数，如果引用为0，则释放内存</p>
<p>需要分配内存用于计数</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;Entity&gt; p = <span class="built_in">make_shared</span>&lt;Entity&gt;();</span><br></pre></td></tr></table></div></figure>

<p>作用主要包括：</p>
<ol>
<li>自动管理动态分配的对象，避免手动调用 <code>delete</code>。</li>
<li>支持共享所有权，让多个 <code>shared_ptr</code> 可以安全地访问同一对象。</li>
<li>借助引用计数机制，实现对象的生命周期控制，当最后一个 <code>shared_ptr</code> 销毁后，自行释放资源。</li>
</ol>
<p><strong><code>unique_ptr</code></strong>：独占所有权，不支持多个指针管理同一个对象；更轻量且不存在循环引用问题。</p>
<p><strong><code>weak_ptr</code></strong>：用于观察 <code>shared_ptr</code> 管理的对象，不增加引用计数；主要用于辅助 <code>shared_ptr</code>，避免循环引用的问题。</p>

        <h3 id="std-weak-ptr"   >
          <a href="#std-weak-ptr" class="heading-link"><i class="fas fa-link"></i></a><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a>std::weak_ptr</h3>
      <p><code>std::weak_ptr</code> 是 C++11 引入的一种智能指针，和 <code>std::shared_ptr</code> 一起使用，用于避免 <strong>循环引用</strong> 问题，同时提供了一种对 <code>std::shared_ptr</code> 所管理对象的弱引用（non-owning reference）。它不改变所管理对象的引用计数。</p>
<ul>
<li><strong>循环引用问题</strong>：<br>在使用 <code>std::shared_ptr</code> 时，如果两个对象互相以 <code>shared_ptr</code> 引用彼此，会导致<strong>内存泄漏</strong>，因为它们的引用计数无法递减到 0。<ul>
<li><code>shared_ptr</code> 通过引用计数管理对象的生命周期，当引用计数为 0 时，自动释放对象。</li>
<li>如果存在循环引用，两个对象会始终持有对方，这样它们的引用计数永远不会减为 0，因此无法释放内存。</li>
</ul>
</li>
<li><strong>非拥有性的弱引用</strong>：<br>有时候，一个对象只需要 “观察” 对另一个对象的引用，而无需控制它的生命周期。这时使用 <code>std::weak_ptr</code> 是更合理的选择。</li>
</ul>
<p><code>std::weak_ptr</code> 提供了一种临时、不影响生命周期的引用，从而解决了上述问题。</p>
<p><strong>总结</strong></p>
<p><code>std::weak_ptr</code> 的主要使用场景包括：</p>
<ol>
<li><strong>解决 <code>std::shared_ptr</code> 的循环引用问题</strong>。</li>
<li><strong>跨组件之间的非拥有性引用</strong>，例如缓存对象的管理。</li>
<li><strong>事件监听器或回调函数，避免悬垂指针的产生</strong>。</li>
<li>在弱引用需求场景下提供更加灵活的资源管理，而不是一味增加强引用计数。</li>
</ol>
<p><strong><code>std::weak_ptr</code> 的特点</strong></p>
<ol>
<li><strong>不控制对象的生命周期</strong>：</li>
<li><strong>检测对象是否已销毁</strong>：<ul>
<li>可以通过调用 <code>weak_ptr</code> 的 <code>expired()</code> 方法来检查被引用的对象是否已经销毁。</li>
</ul>
</li>
<li><strong>使用 <code>lock()</code> 转换为 <code>shared_ptr</code></strong>：<ul>
<li>如果需要安全地访问被引用的对象，可以调用 <code>weak_ptr</code> 的 <code>lock()</code> 方法，返回一个临时的 <code>shared_ptr</code>。如果对象已销毁，<code>lock()</code> 会返回一个空指针。</li>
</ul>
</li>
</ol>
<p>假设我们有两个类 <code>A</code> 和 <code>B</code>，它们通过 <code>std::shared_ptr</code> 互相引用。如果没有使用 <code>weak_ptr</code>，将会发生循环引用，导致内存泄漏。</p>
<p><strong>示例代码（循环引用问题）</strong>：</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>; <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;B&gt; ptrB; <span class="comment">// A 持有共享指针引用 B</span></span><br><span class="line">    ~<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A destroyed&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;A&gt; ptrA; <span class="comment">// B 持有共享指针引用 A</span></span><br><span class="line">    ~<span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;B destroyed&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建循环引用</span></span><br><span class="line">    <span class="keyword">auto</span> a = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">    <span class="keyword">auto</span> b = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line">    a-&gt;ptrB = b; <span class="comment">// A 持有 B</span></span><br><span class="line">    b-&gt;ptrA = a; <span class="comment">// B 持有 A</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 离开 main() 作用域时，A 和 B 的引用计数不会减到 0，导致内存泄漏</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行结果：</p>
<figure class="highlight text"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 没有输出，因为 `A` 和 `B` 无法正常析构，发生内存泄漏。</span><br></pre></td></tr></table></div></figure>

<p><strong>解决循环引用的正确做法</strong>：<br>将其中一个引用改为 <code>std::weak_ptr</code>，避免两个对象互相增加引用计数。</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>; <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::weak_ptr&lt;B&gt; ptrB; <span class="comment">// 弱引用 B</span></span><br><span class="line">    ~<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A destroyed&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;A&gt; ptrA; <span class="comment">// 共享指针持有 A</span></span><br><span class="line">    ~<span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;B destroyed&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">    <span class="keyword">auto</span> b = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line">    a-&gt;ptrB = b; <span class="comment">// A 弱引用 B</span></span><br><span class="line">    b-&gt;ptrA = a; <span class="comment">// B 持有 A</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 离开作用域时，A 和 B 都将正确析构</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行结果：</p>
<figure class="highlight text"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B destroyed</span><br><span class="line">A destroyed</span><br></pre></td></tr></table></div></figure>

<p>通过将某一侧的引用改为 <code>std::weak_ptr</code>，打破了循环引用。</p>
<hr>
<p><strong>跨组件间的弱引用</strong></p>
<p>如果某些对象之间并无强依赖关系，但仍需临时引用，则可以使用 <code>std::weak_ptr</code>。</p>
<p><strong>示例 1：缓存管理</strong><br>在缓存系统中，如果一个对象的存在依赖于被缓存的内容，则可以使用 <code>std::weak_ptr</code>：</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CachedObject</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CachedObject</span>(std::string name) : <span class="built_in">name</span>(name) &#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; created&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">CachedObject</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; destroyed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printName</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Object name: &quot;</span> &lt;&lt; name &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unordered_map&lt;std::string, std::weak_ptr&lt;CachedObject&gt;&gt; cache;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> obj1 = std::<span class="built_in">make_shared</span>&lt;CachedObject&gt;(<span class="string">&quot;Object1&quot;</span>);</span><br><span class="line">        cache[<span class="string">&quot;key1&quot;</span>] = obj1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> obj2 = std::<span class="built_in">make_shared</span>&lt;CachedObject&gt;(<span class="string">&quot;Object2&quot;</span>);</span><br><span class="line">        cache[<span class="string">&quot;key2&quot;</span>] = obj2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用缓存中的对象</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> obj = cache[<span class="string">&quot;key1&quot;</span>].<span class="built_in">lock</span>()) &#123;</span><br><span class="line">            obj-&gt;<span class="built_in">printName</span>(); <span class="comment">// 输出：Object name: Object1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// obj1 和 obj2 均超出作用域，被释放</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试访问释放的对象</span></span><br><span class="line">    <span class="keyword">if</span> (cache[<span class="string">&quot;key1&quot;</span>].<span class="built_in">expired</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Object1 no longer exists&quot;</span> &lt;&lt; std::endl; <span class="comment">// 输出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行结果：</p>
<figure class="highlight text"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object1 created</span><br><span class="line">Object2 created</span><br><span class="line">Object name: Object1</span><br><span class="line">Object2 destroyed</span><br><span class="line">Object1 destroyed</span><br><span class="line">Object1 no longer exists</span><br></pre></td></tr></table></div></figure>

<hr>
<p><strong>事件回调（防止悬垂引用）</strong></p>
<p>如果某类对象注册了一个事件监听器或回调函数，而监听器的生命周期可能比被观察的对象短，那么可以使用 <code>std::weak_ptr</code> 避免访问悬垂的指针。</p>
<p>例如：</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventSource</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Listener</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Listener</span>(std::shared_ptr&lt;EventSource&gt; source) : <span class="built_in">source</span>(source) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> src = source.<span class="built_in">lock</span>()) &#123; <span class="comment">// 检查 source 是否仍有效</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Event handled&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Source no longer exists&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::weak_ptr&lt;EventSource&gt; source;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventSource</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;EventSource&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fireEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (listener) <span class="built_in">listener</span>(); <span class="comment">// 调用回调</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setListener</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; callback)</span> </span>&#123;</span><br><span class="line">        listener = callback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; listener;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;EventSource&gt; source = std::<span class="built_in">make_shared</span>&lt;EventSource&gt;();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> listener = std::<span class="built_in">make_shared</span>&lt;Listener&gt;(source);</span><br><span class="line">        source-&gt;<span class="built_in">setListener</span>([listener]() &#123; listener-&gt;<span class="built_in">onEvent</span>(); &#125;);</span><br><span class="line"></span><br><span class="line">        source-&gt;<span class="built_in">fireEvent</span>(); <span class="comment">// 输出：Event handled</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Listener 已销毁，无悬垂引用</span></span><br><span class="line">    source-&gt;<span class="built_in">fireEvent</span>(); <span class="comment">// 不输出，Listener 已解除绑定</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/stun-logo.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">hello world</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/linyuww" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="http://47.104.22.42:3000/" target="_blank" rel="noopener" data-popover="social.Tetris" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fas fa-gamepad"></i></span></a><a class="sidebar-ov-social-item" href="http://47.104.22.42:5244/" target="_blank" rel="noopener" data-popover="Learning Materials" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fas fa-book"></i></span></a><div class="sidebar-ov-ha" style="text-align: center; margin-top: 10px;"><span class="sidebar-ov-social-item sidebar-ha-btn" style="cursor: pointer; display: inline-block;">哈</span><img class="sidebar-ha-img" src="/images/cat_ha.gif" style="display: none; width: 100%; margin-top: 10px;" alt="Ha"></div><script>document.addEventListener('DOMContentLoaded', function() {
  var container = document.querySelector('.sidebar-ov-ha');
  var btn = document.querySelector('.sidebar-ha-btn');
  var img = document.querySelector('.sidebar-ha-img');
  if (btn && img && container) {
    btn.addEventListener('click', function() {
      img.style.display = 'block';
    });
    container.addEventListener('mouseleave', function() {
      img.style.display = 'none';
    });
  }
});
</script></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">65</div><div class="sidebar-ov-state-item__name">Archives</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">5</div><div class="sidebar-ov-state-item__name">Categories</div></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="Search for Posts (Support multiple keywords)"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ Untitled ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', 'Please enter characters');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><div class="aplayer-container"><link class="aplayer-secondary-style-marker" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><meting-js server="netease" type="playlist" id="2556780013" fixed="true" autoplay="false" loop="all" order="list" preload="auto" list-folded="true" list-max-height="500px" lrc-type="0"></meting-js></div><script src="/js/utils.js?v=2.8.0"></script><script src="/js/stun-boot.js?v=2.8.0"></script><script src="/js/scroll.js?v=2.8.0"></script><script src="/js/header.js?v=2.8.0"></script><script src="/js/sidebar.js?v=2.8.0"></script><script type="application/json" src="/search.json"></script><canvas id="snow" style="position:fixed;top:0;left:0;width:100%;height:100%;z-index:99999;pointer-events:none"></canvas><script src="/js/snow.js"></script></body></html>