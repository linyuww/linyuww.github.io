<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.8.0" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.8.0" type="image/png" sizes="32x32"><meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary"><title>Hexo</title><link ref="canonical" href="http://example.com/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.8.0"><link rel="stylesheet" href="css/custom.css"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"Copy","copySuccess":"Copy Success","copyError":"Copy Error"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">Home</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">Archives</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">Hello Stun</div><div class="header-banner-info__subtitle">An elegant theme for Hexo</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2025/09/10/%E9%9D%A2%E8%AF%95/%E9%87%91%E5%B1%B1C++%E7%A0%94%E5%8F%91%E5%AE%9E%E4%B9%A0%E7%94%9F%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">[ Untitled ]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2025-09-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2025-05-16</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="金山C-研发实习生面试准备"   >
          <a href="#金山C-研发实习生面试准备" class="heading-link"><i class="fas fa-link"></i></a><a href="#金山C-研发实习生面试准备" class="headerlink" title="金山C++研发实习生面试准备"></a>金山C++研发实习生面试准备</h1>
      <p>1.自我介绍<br>2.拷打项目</p>
<p>3.拷打八股：</p>
<p>4.多态的实现</p>

        <h3 id="5-静态多态和动态多态"   >
          <a href="#5-静态多态和动态多态" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-静态多态和动态多态" class="headerlink" title="5.静态多态和动态多态"></a>5.静态多态和动态多态</h3>
      <p>静态多态是指在编译时多态，动态多态是指运行时多态</p>
<p>静态多态有函数重载（函数名相同，参数不同，返回值相同或不同），函数模板</p>
<p>动态多态（动态绑定）：即运行时的多态，在程序执行期间(非编译期)判断所引用对象的实际类型，根据其实际类型调用相应的方法。</p>

        <h3 id="6-动态多态怎么实现的"   >
          <a href="#6-动态多态怎么实现的" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-动态多态怎么实现的" class="headerlink" title="6.动态多态怎么实现的"></a>6.动态多态怎么实现的</h3>
      
        <h3 id="动态多态"   >
          <a href="#动态多态" class="heading-link"><i class="fas fa-link"></i></a><a href="#动态多态" class="headerlink" title="动态多态"></a>动态多态</h3>
      <p>通过每个类的虚函数和动态绑定</p>
<p>派生类实现动态绑定</p>
<ul>
<li>先拷贝基类的虚函数表</li>
<li>如果派生类重写了基类的某个虚函数，就用派生类的虚函数替换虚表同位置的基类虚函数</li>
<li>跟上派生类自己的虚函数</li>
</ul>
<p>指向基类的指针或引用</p>
<p>动态多态需要通过指向基类的 <strong>指针或引用</strong> 操作派生类对象。如果直接操作派生对象，则是静态绑定，而非动态绑定。</p>

        <h3 id="7-介绍一下虚函数表和虚指针"   >
          <a href="#7-介绍一下虚函数表和虚指针" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-介绍一下虚函数表和虚指针" class="headerlink" title="7.介绍一下虚函数表和虚指针"></a>7.介绍一下虚函数表和虚指针</h3>
      <p>虚函数表和虚指针是由<strong>编译器</strong>生成并使用的，它们是实现 <strong>动态绑定</strong> 和运行时多态的核心。</p>
<p>虚函数表是一种由编译器生成的 <strong>隐藏数据结构</strong>，它是一个函数指针数组，用来存储类中所有虚函数的地址。简单来说，虚函数表就是一个指针数组，每个元素指向一个虚函数的具体实现。</p>
<p>虚指针是一个 <strong>隐藏成员变量</strong>，存在于每个包含虚函数的类的对象中。虚指针用于指向当前对象所属类的虚函数表。</p>

        <h3 id="8-说一下构造函数和析构函数在父类和子类的执行顺序"   >
          <a href="#8-说一下构造函数和析构函数在父类和子类的执行顺序" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-说一下构造函数和析构函数在父类和子类的执行顺序" class="headerlink" title="8.说一下构造函数和析构函数在父类和子类的执行顺序"></a>8.说一下构造函数和析构函数在父类和子类的执行顺序</h3>
      <ul>
<li><strong>构造函数顺序</strong>：<br><strong>父类构造函数</strong> → <strong>成员对象的构造函数</strong> → <strong>子类构造函数</strong></li>
<li><strong>析构函数顺序</strong>：<br><strong>子类析构函数</strong> → <strong>成员对象的析构函数</strong> → <strong>父类析构函数</strong></li>
</ul>

        <h3 id="9-析构函数的作用"   >
          <a href="#9-析构函数的作用" class="heading-link"><i class="fas fa-link"></i></a><a href="#9-析构函数的作用" class="headerlink" title="9.析构函数的作用"></a>9.析构函数的作用</h3>
      <p>析构函数用于释放对象占用的资源（如内存、文件句柄等），在对象生命周期结束时自动调用，确保资源不会泄漏。</p>

        <h3 id="10-为什么析构函数通常定义为虚函数；不调用析构函数会怎样"   >
          <a href="#10-为什么析构函数通常定义为虚函数；不调用析构函数会怎样" class="heading-link"><i class="fas fa-link"></i></a><a href="#10-为什么析构函数通常定义为虚函数；不调用析构函数会怎样" class="headerlink" title="10.为什么析构函数通常定义为虚函数；不调用析构函数会怎样"></a>10.为什么析构函数通常定义为虚函数；不调用析构函数会怎样</h3>
      <ul>
<li><strong>原因</strong>：<br>若父类指针指向子类对象，且父类析构函数非虚，则通过父类指针删除对象时，只会调用父类析构函数，导致子类资源泄漏。</li>
<li><strong>后果</strong>：<br>不调用析构函数会导致资源泄漏（如内存、文件句柄未释放）。</li>
</ul>

        <h3 id="11-结构体为何通常要进行内存对齐；一般是几字节对齐"   >
          <a href="#11-结构体为何通常要进行内存对齐；一般是几字节对齐" class="heading-link"><i class="fas fa-link"></i></a><a href="#11-结构体为何通常要进行内存对齐；一般是几字节对齐" class="headerlink" title="11.结构体为何通常要进行内存对齐；一般是几字节对齐"></a>11.结构体为何通常要进行内存对齐；一般是几字节对齐</h3>
      <p>为了提高访问效率，为了时内存命中访问效率更高</p>
<p><strong>对齐原则</strong></p>
<p>结构体的内存对齐通常遵循以下原则：</p>
<ol>
<li>每个成员变量的起始地址必须是其自身大小的整数倍</li>
<li>结构体本身的大小必须是其最大对齐系数（对齐要求）的整数倍</li>
</ol>

        <h3 id="12-new-delete和malloc-free的区别"   >
          <a href="#12-new-delete和malloc-free的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#12-new-delete和malloc-free的区别" class="headerlink" title="12.new&#x2F;delete和malloc&#x2F;free的区别"></a>12.new&#x2F;delete和malloc&#x2F;free的区别</h3>
      <div class="table-container"><table>
<thead>
<tr>
<th>特性</th>
<th><code>new/delete</code></th>
<th><code>malloc/free</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>语言特性支持</strong></td>
<td>C++ 专有</td>
<td>C 风格（C 和 C++ 均支持）</td>
</tr>
<tr>
<td><strong>类型安全</strong></td>
<td>是</td>
<td>否（需要手动类型转换）</td>
</tr>
<tr>
<td><strong>初始化支持</strong></td>
<td>自动调用构造函数和析构函数</td>
<td>不调用，需要手动处理</td>
</tr>
<tr>
<td><strong>异常处理</strong></td>
<td>内存分配失败抛出 <code>std::bad_alloc</code></td>
<td>内存分配失败返回 <code>NULL</code></td>
</tr>
<tr>
<td><strong>灵活性</strong></td>
<td>适合对象管理和复杂场景</td>
<td>适合简单的POD或跨语言</td>
</tr>
<tr>
<td><strong>效率</strong></td>
<td>稍有额外开销（构造&#x2F;析构函数调用）</td>
<td>相对高效</td>
</tr>
</tbody></table></div>
<p><strong>什么时候选择哪一个？</strong></p>
<p><strong>使用 <code>new/delete</code>：</strong></p>
<ul>
<li>在C++程序中，需要创建具有构造函数和析构函数的复杂对象。</li>
<li>希望利用类型安全和异常处理机制，提高代码的健壮性。</li>
<li>更偏向于面向对象的编程风格。</li>
</ul>
<p><strong>使用 <code>malloc/free</code>：</strong></p>
<ul>
<li>在C语言程序中，或者需要与 C 的库&#x2F;代码接口。</li>
<li>需要跨语言兼容时（如 C 和 C++ 混合开发）。</li>
<li>只操作简单的内存（非对象）时，比如使用裸内存块或数组。</li>
</ul>
<p><strong>总结</strong></p>
<ol>
<li><code>new</code> 和 <code>delete</code> 是C++中的语法糖，功能更强大，更贴合现代编程需求。</li>
<li><code>malloc</code> 和 <code>free</code> 是底层内存管理工具，适合裸内存分配。</li>
<li>在C++开发中，通常推荐优先使用 <code>new</code> 和 <code>delete</code>，除非有特殊需要才选择 <code>malloc</code> 和 <code>free</code>。</li>
</ol>

        <h3 id="13-什么情况用mmap"   >
          <a href="#13-什么情况用mmap" class="heading-link"><i class="fas fa-link"></i></a><a href="#13-什么情况用mmap" class="headerlink" title="13.什么情况用mmap()"></a>13.什么情况用mmap()</h3>
      <p><code>mmap()</code> 是一个 POSIX 标准的内存映射函数，通常用于将文件或设备映射到进程虚拟内存空间中，使得我们可以通过内存访问文件内容，大大提高了 I&#x2F;O 的效率。它的使用场景主要集中在对文件的高效访问、大文件处理、共享内存以及特殊的内存管理需求等。以下是 <code>mmap()</code> 的典型使用情况、优缺点以及示例解释。</p>
<p>1.高效文件访问，减少内核态和用户态之间的拷贝开销</p>
<p>2.处理大文件，将文件内容按需映射到虚拟内存中</p>
<p>3.共享内存（进程间通信）</p>
<ul>
<li><code>mmap()</code> 支持使用 <code>MAP_SHARED</code> 标志创建共享内存，多个进程可以操作同一内存区域进行通信。</li>
<li>使用共享内存比使用消息队列、管道等传统 IPC 机制有更高的效率。</li>
</ul>
<p>4.文件修改或写入（内存作为缓冲区）适用于需要高效更新大文件的场景</p>
<p>5.实现内存映射I&#x2F;O</p>
<p>6.异步I&#x2F;O和并行处理</p>
<p>使用 <code>mmap()</code> 的场景主要是权衡性能与开销，以下是具体选择标准：</p>
<ol>
<li><strong>适合用 <code>mmap()</code> 的场景</strong>：<ul>
<li>需要频繁随机访问大文件。</li>
<li>文件的内容按需加载，不需要一次性加载到内存。</li>
<li>多进程需要共享文件或内存。</li>
<li>操作设备文件或硬件寄存器。</li>
<li>文件访问频繁，且希望减少用户态与内核态之间频繁的数据拷贝。</li>
</ul>
</li>
<li><strong>不太适合用 <code>mmap()</code> 的场景</strong>：<ul>
<li>操作小文件，或者一次性读取整个文件，不需要复杂的随机访问。</li>
<li>文件处理逻辑非常简单，而 <code>mmap()</code> 的复用性和管理开销反而适得其反。</li>
<li>跨平台兼容需求非常高的场景。</li>
</ul>
</li>
</ol>

        <h3 id="14-动态链接库用的brk-还是mmap"   >
          <a href="#14-动态链接库用的brk-还是mmap" class="heading-link"><i class="fas fa-link"></i></a><a href="#14-动态链接库用的brk-还是mmap" class="headerlink" title="14.动态链接库用的brk()还是mmap()"></a>14.动态链接库用的brk()还是mmap()</h3>
      <div class="table-container"><table>
<thead>
<tr>
<th>特性</th>
<th><code>brk()</code></th>
<th><code>mmap()</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>内存范围</strong></td>
<td>紧跟数据段末尾</td>
<td>任意空闲的虚拟地址空间</td>
</tr>
<tr>
<td><strong>按需加载</strong></td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td><strong>分页分配</strong></td>
<td>不支持</td>
<td>支持，以页为单位分配和管理</td>
</tr>
<tr>
<td><strong>碎片问题</strong></td>
<td>容易引发堆碎片</td>
<td>避免堆碎片，内存管理灵活</td>
</tr>
<tr>
<td><strong>共享内存</strong></td>
<td>不支持</td>
<td>支持共享内存（<code>MAP_SHARED</code> 标志）</td>
</tr>
<tr>
<td><strong>动态链接库加载</strong></td>
<td>不适用</td>
<td>是动态链接库的默认选择</td>
</tr>
</tbody></table></div>
<p>因此，动态链接库的加载和运行使用 <code>mmap()</code> 是最佳选择，它为动态链接库的按需加载、多进程共享、独立管理以及性能优化提供了完美支持。同时，<code>brk()</code> 由于其限制，已不适用于动态库加载。</p>

        <h3 id="15-动态链接和静态链接的区别"   >
          <a href="#15-动态链接和静态链接的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#15-动态链接和静态链接的区别" class="headerlink" title="15.动态链接和静态链接的区别"></a>15.动态链接和静态链接的区别</h3>
      <div class="table-container"><table>
<thead>
<tr>
<th>特性</th>
<th>静态链接</th>
<th>动态链接</th>
</tr>
</thead>
<tbody><tr>
<td><strong>生成的可执行文件体积</strong></td>
<td>较大，库代码直接嵌入</td>
<td>较小，仅包含对动态库的引用</td>
</tr>
<tr>
<td><strong>运行时依赖</strong></td>
<td>不依赖外部库，所有代码都在一个文件中</td>
<td>依赖外部库，运行时需要动态加载</td>
</tr>
<tr>
<td><strong>运行时性能</strong></td>
<td>加载速度快，无需加载外部库</td>
<td>加载速度稍慢，需要动态加载符号解析</td>
</tr>
<tr>
<td><strong>内存使用</strong></td>
<td>每个程序独立占用一份库的内存</td>
<td>多个程序共享同一个库，节省内存</td>
</tr>
<tr>
<td><strong>更新方式</strong></td>
<td>更新程序需要重新编译并链接静态库</td>
<td>可以通过更新库文件，无需重新编译程序</td>
</tr>
<tr>
<td><strong>跨平台兼容性</strong></td>
<td>静态库只与编译平台相关，适合封装依赖</td>
<td>动态库可能与运行时环境、平台设置相关</td>
</tr>
<tr>
<td><strong>调试难度</strong></td>
<td>相对简单，因为库已集成进可执行文件</td>
<td>调试更复杂，可能需要检查多个动态库</td>
</tr>
<tr>
<td><strong>符号冲突问题</strong></td>
<td>不会出现符号冲突，代码已固定</td>
<td>有可能发生符号冲突，需要小心处理</td>
</tr>
<tr>
<td><strong>磁盘存储</strong></td>
<td>每个可执行文件都包含完整的库代码</td>
<td>动态库存储独立，节省磁盘空间</td>
</tr>
<tr>
<td><strong>维护与分发</strong></td>
<td>更新程序和库需要重新分发完整的可执行文件</td>
<td>库文件可以单独更新，减少分发工作量</td>
</tr>
</tbody></table></div>

        <h3 id="16-红黑树特性；有哪些应用"   >
          <a href="#16-红黑树特性；有哪些应用" class="heading-link"><i class="fas fa-link"></i></a><a href="#16-红黑树特性；有哪些应用" class="headerlink" title="16.红黑树特性；有哪些应用"></a>16.红黑树特性；有哪些应用</h3>
      <ul>
<li><strong>特性</strong>：<ol>
<li>每个节点是红或黑。</li>
<li>根节点和叶子节点（NIL）是黑。</li>
<li>红节点的子节点必为黑。</li>
<li>从任一节点到其叶子节点的路径包含相同数量的黑节点。</li>
</ol>
</li>
<li><strong>应用</strong>：<br>C++ STL <code>map</code>&#x2F;<code>set</code>、Java <code>TreeMap</code>、Linux 内核调度器等。</li>
</ul>

        <h3 id="17-死锁的必要条件有哪些"   >
          <a href="#17-死锁的必要条件有哪些" class="heading-link"><i class="fas fa-link"></i></a><a href="#17-死锁的必要条件有哪些" class="headerlink" title="17.死锁的必要条件有哪些"></a>17.死锁的必要条件有哪些</h3>
      <ol>
<li><strong>互斥</strong>：资源只能被一个进程占用。</li>
<li><strong>持有并等待</strong>：进程持有资源并等待其他资源。</li>
<li><strong>不可抢占</strong>：资源只能由持有者主动释放。</li>
<li><strong>循环等待</strong>：存在进程资源的环形等待链。</li>
</ol>

        <h3 id="18-线程安全实现方式"   >
          <a href="#18-线程安全实现方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#18-线程安全实现方式" class="headerlink" title="18.线程安全实现方式"></a>18.线程安全实现方式</h3>
      <ol>
<li><strong>互斥锁（Mutex）</strong>：保证临界区代码原子性。</li>
<li><strong>原子操作（Atomic）</strong>：通过硬件支持的原子指令（如 CAS）。</li>
<li><strong>无锁编程</strong>：如使用无锁数据结构。</li>
<li><strong>线程局部存储（TLS）</strong>：避免共享数据。</li>
<li><strong>读写锁（Read-Write Lock）</strong>：区分读&#x2F;写操作。</li>
<li><strong>条件变量（Condition Variable）</strong>：线程间同步。</li>
</ol>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2025/09/10/%E9%9D%A2%E8%AF%95/%E7%BA%A2%E9%BB%91%E6%A0%91/">[ Untitled ]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2025-09-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2025-05-15</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="红黑树"   >
          <a href="#红黑树" class="heading-link"><i class="fas fa-link"></i></a><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2>
      
        <h3 id="基本规则："   >
          <a href="#基本规则：" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本规则：" class="headerlink" title="基本规则："></a>基本规则：</h3>
      <p><strong>隐藏的空节点是黑色</strong></p>
<p>满足Avl树</p>
<p>根节点和叶子节点都是黑色</p>
<p>不能有连续两个红色节点</p>
<p>从根节点到叶子节点的每个路径上黑色节点数量都一致</p>

        <h3 id="插入："   >
          <a href="#插入：" class="heading-link"><i class="fas fa-link"></i></a><a href="#插入：" class="headerlink" title="插入："></a>插入：</h3>
      <p>插入节点是根节点；直接变黑</p>
<p>插入节点的叔叔是红色；叔父爷爷变色，爷爷变插入节点继续调整</p>
<p>插入节点的叔叔是黑 ；（LL，RL，LR，RL）旋转，然后变色</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Xm421x7Lg/?spm_id_from=333.337.search-card.all.click&vd_source=07ce431f0897d40efe75d8ff3761e5f6" >红黑树 - 定义, 插入, 构建_哔哩哔哩_bilibili</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2025/09/10/%E9%9D%A2%E8%AF%95/%E5%85%B6%E4%BB%96%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98/">[ Untitled ]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2025-09-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2025-04-29</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h3 id="为什么服务器要以root身份启动，不能以root身份运行"   >
          <a href="#为什么服务器要以root身份启动，不能以root身份运行" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么服务器要以root身份启动，不能以root身份运行" class="headerlink" title="为什么服务器要以root身份启动，不能以root身份运行"></a>为什么服务器要以root身份启动，不能以root身份运行</h3>
      <p>为什么要以 root 启动？</p>
<p>绑定低编号端口（如 80、443）。<br>配置共享内存、设备文件、调整资源等需要的高权限操作。</p>
<p>为什么不能以 root 运行？</p>
<p>潜在漏洞可能导致系统被完全攻破。<br>不符合最小权限原则。<br>服务隔离无法实现，其他服务可能受到影响。<br>意外操作可能导致灾难性的后果。<br>如何解决这个问题？</p>
<p>启动时以 root 完成特权操作，然后立刻降级为普通用户运行。<br>使用 setuid() 和 setgid() 等 Linux 用户管理接口实现特权降级。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2025/09/10/%E9%9D%A2%E8%AF%95/%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98/">[ Untitled ]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2025-09-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2025-04-17</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="Mysql问题"   >
          <a href="#Mysql问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#Mysql问题" class="headerlink" title="Mysql问题"></a>Mysql问题</h2>
      <p> 说一说事物隔离级别 </p>
<p>SQL标准的事务隔离级别包括：</p>
<p>读未提交，读提交，可重复读，串行化</p>
<p> 事务的四大特性有哪些？ </p>
<p>原子性，一致性，隔离性，持久性</p>

        <h2 id="Linux系统目录"   >
          <a href="#Linux系统目录" class="heading-link"><i class="fas fa-link"></i></a><a href="#Linux系统目录" class="headerlink" title="Linux系统目录"></a>Linux系统目录</h2>
      <p><img src="C:/Users/86147/Desktop/%E9%9D%A2%E8%AF%95/%E7%9B%AE%E5%BD%952.webp" alt="目录2"></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2025/09/10/%E9%9D%A2%E8%AF%95/%E5%85%B3%E4%BA%8E%E9%A1%B9%E7%9B%AE/">[ Untitled ]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2025-09-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2025-06-06</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>项目背景： 设计并实现了一个基于 Linux 平台的轻量级 HTTP 服务器，采用<strong>多 Reactor 多线程</strong>高并发模型，通过 <strong>epoll 提供高效的 I&#x2F;O 复用</strong>。结合<strong>自动增长缓冲区</strong>、<strong>定时器和异步日志</strong>等技术，实现了高性能和稳定运行的目标。 </p>
<p>主要工作  </p>
<p>内存优化：设计了<strong>内存池和 LFU 缓存</strong>，减少内存碎片，提升内存使用效率。  </p>
<p>高效事件处理：利用 <strong>epoll 多路复用机制</strong>，高效监听和处理客户端连接及数据传输事件。  </p>
<p>高并发模型：基于 <strong>Reactor 模型</strong>，实现 <strong>One Loop per Thread</strong>，支持多客户端并发连接。  </p>
<p>动态缓冲区：实现<strong>自动增长缓冲区</strong>，动态调整大小以适配不同请求，优化内存分配。  </p>
<p>连接管理：使用<strong>小根堆实现高效定时器</strong>，管理连接超时时间，防止长期空闲连接浪费资源。  </p>
<p>异步日志：设计<strong>异步日志</strong>模块，基于<strong>单例模式和阻塞队列</strong>，实现高效日志写入，避免同步写入的性能开销。 </p>

        <h2 id="关于项目"   >
          <a href="#关于项目" class="heading-link"><i class="fas fa-link"></i></a><a href="#关于项目" class="headerlink" title="关于项目"></a>关于项目</h2>
      
        <h3 id="介绍一下"   >
          <a href="#介绍一下" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍一下" class="headerlink" title="介绍一下"></a>介绍一下</h3>
      <p>本项目是一个高性能的WEB服务器，使用C++实现，项目底层采用了多线程多Reactor的网络模型，并且在这基础上增加了内存池，高效的双缓冲异步日志系统，以及LFU的缓存。</p>
<p>服务器的网络模型是<strong>主从reactor加线程池</strong>的模式，IO处理使用了<strong>非阻塞IO和IO多路复用技术</strong>，具备<strong>处理多个客户端</strong>的http请求和ftp请求，以及对外<strong>提供轻量级储存</strong>的能力。</p>
<p>项目中的工作可以分为两部分，</p>
<p>一部分是服务器网络框架、日志系统、存储引擎等一些基本系统的搭建，</p>
<p>另一部分 是为了提高服务器性能所做的一些优化，比如缓存机制、内存池等一些额外系统的搭建。</p>
<p>最后还对系统中的部分功能进行了功能和压力测试。对于存储引擎的压力测试，</p>
<p>在本地测试下，存储引擎读操作的QPS可以达到36万，写操作的QPS可以达到30万。对于网络框架的测试，使用webbench创建1000个进程对服务器进行60s并发请求，测试结果表明，对于短连接的QPS为1.8万，对于长连接的QPS为5.2万。</p>

        <h3 id="项目难点"   >
          <a href="#项目难点" class="heading-link"><i class="fas fa-link"></i></a><a href="#项目难点" class="headerlink" title="项目难点"></a>项目难点</h3>
      <p>根据工作分为两部分</p>
<p>一部分是服务器网络框架，日志系统，存储引擎等一些基本系统的搭建，这部分的难点主要就是技术理解和选型，以及将一些开源的框架调整后应用到我的项目中去。</p>
<p>另一部分就是性能优化方面，比如缓存机制，内存池等一些额外系统的搭建。这部分的难点在于找出服务器的性能瓶颈所在，然后结合自己的想法突破瓶颈，提高服务器性能。</p>

        <h3 id="遇到的困难，怎么解决"   >
          <a href="#遇到的困难，怎么解决" class="heading-link"><i class="fas fa-link"></i></a><a href="#遇到的困难，怎么解决" class="headerlink" title="遇到的困难，怎么解决"></a>遇到的困难，怎么解决</h3>
      <p>一方面是对技术理解不够深刻，难以选出合适的技术框架，这部分主要是阅读作者的技术文档，找相关的解析文章看</p>
<p>另一部分是编程遇到的困难，由于工程能力不足出现bug，这部分主要是通过日志定位bug，推断bug出现的原因并尝试修复，如果以自己能力无法修复，先问问ai能提供什么思路，或者搜索相关的博客。</p>

        <h2 id="内存优化"   >
          <a href="#内存优化" class="heading-link"><i class="fas fa-link"></i></a><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h2>
      <p>设计了<strong>内存池</strong>和 <strong>LFU 缓存</strong></p>

        <h3 id="缓存机制"   >
          <a href="#缓存机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h3>
      
        <h3 id="为什么选择LFU"   >
          <a href="#为什么选择LFU" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么选择LFU" class="headerlink" title="为什么选择LFU"></a>为什么选择LFU</h3>
      <p>因为最近加入的数据因为起始的频率很低，容易被淘汰，而早期的热点数据会一直占据缓存。</p>

        <h2 id="高效事件处理："   >
          <a href="#高效事件处理：" class="heading-link"><i class="fas fa-link"></i></a><a href="#高效事件处理：" class="headerlink" title="高效事件处理："></a>高效事件处理：</h2>
      <p><strong>epoll 多路复用机制</strong></p>
<p>采用非阻塞I&#x2F;O模型，执行系统调用就立即返回，不检查事件是否发生，没有立即发生返回-1，errno设置为在处理中。所以要采用I&#x2F;O通知机制（I&#x2F;O复用和SIGIO信号）来得知就绪事件。</p>
<figure class="highlight tex"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">I/O多路复用技术</span><br><span class="line">I/O 多路复用允许一个线程同时监视多个 I/O 文件描述符（如网络 socket），并在其中一个或多个文件描述符变为&quot;可操作&quot;时返回。应用程序可以据此进行相应的 I/O 操作（如读、写）。</span><br><span class="line"></span><br><span class="line">1.1 select</span><br><span class="line">简介</span><br><span class="line">select 是一种最早的 I/O 多路复用接口，几乎所有主流平台都支持。</span><br><span class="line"></span><br><span class="line">它允许程序监视多个文件描述符，查询它们是否可读、可写或出现错误。</span><br><span class="line">select 的接口会使用三个位图（readset、writeset 和 exceptset）指定文件描述符的状态。</span><br><span class="line">工作原理</span><br><span class="line">调用 select 时，程序将文件描述符集（一个位图）传递给内核。</span><br><span class="line">内核在超时时间内扫描这些文件描述符并返回那些状态发生变化的描述符（如变为可读或可写）。</span><br><span class="line">用户态程序可根据返回结果进行相应的 I/O 操作。</span><br><span class="line">缺点</span><br><span class="line">支持的文件描述符数量有限（通常受 FD<span class="built_in">_</span>SETSIZE 限制，默认 1024）。</span><br><span class="line">每次调用时都需要将文件描述符的状态从用户态复制到内核态，这带来一定的性能开销。</span><br><span class="line">内核需要线性遍历所有文件描述符（效率低），尤其在大并发连接时性能较差。</span><br><span class="line">1.2 poll</span><br><span class="line">简介</span><br><span class="line">poll 是 select 的改进版本，克服了文件描述符数量限制的问题。</span><br><span class="line"></span><br><span class="line">它使用一个数组结构而不是位图来描述文件描述符及其事件。</span><br><span class="line">工作原理</span><br><span class="line">用户定义一个 pollfd 数组，该数组中每一个元素保存一个文件描述符及其相关事件。</span><br><span class="line">调用 poll 时，内核会遍历这个数组，检查哪些文件描述符有事件发生，并返回结果。</span><br><span class="line">优点</span><br><span class="line">支持任意数量的文件描述符，突破了 select 的 FD<span class="built_in">_</span>SETSIZE 限制。</span><br><span class="line">缺点</span><br><span class="line">和 select 类似，每次调用都需要将监控的文件描述符数组从用户态复制到内核态，开销较大。</span><br><span class="line">和 select 一样，内核需要线性遍历文件描述符，在高并发场景下效率仍然较低。</span><br><span class="line">1.3 epoll</span><br><span class="line">简介</span><br><span class="line">epoll 是 Linux 平台下提供的高性能 I/O 多路复用接口，它是 select 和 poll 的替代品。</span><br><span class="line"></span><br><span class="line">epoll 被设计用于解决 select 和 poll 的性能问题，是一种效率更高的方式处理大量并发连接的技术。</span><br><span class="line">工作原理</span><br><span class="line">epoll 的核心思想是使用事件驱动机制（Event-Driven）替代轮询机制。</span><br><span class="line"></span><br><span class="line">创建一个 epoll 实例（epoll<span class="built_in">_</span>create），用作事件管理器。</span><br><span class="line">使用 epoll<span class="built_in">_</span>ctl 向内核注册需要监听的具体文件描述符及其事件类型（关注可读、可写或异常事件）。</span><br><span class="line">调用 epoll<span class="built_in">_</span>wait，等待事件发生。</span><br><span class="line">发生事件的文件描述符被加入到一个内核维护的就绪列表，并从中直接返回。</span><br><span class="line">这避免了不必要的遍历额外文件描述符的开销。</span><br><span class="line">优点</span><br><span class="line">事件驱动模型：文件描述符有变化时通过回调机制加入就绪列表，只需处理活跃文件描述符。</span><br><span class="line">无大小限制：最大受限于系统的内存资源，而非固定限制。</span><br><span class="line">高性能：避免了线性遍历，即使监视十万连接，只需处理少量已就绪的描述符。</span><br><span class="line">缺点</span><br><span class="line">仅支持 Linux 系统，不跨平台。</span><br><span class="line">epoll 的两种触发模式</span><br><span class="line">LT（Level Trigger，水平触发）： 默认模式，文件描述符只要处于就绪状态，就会不断返回。</span><br><span class="line">ET（Edge Trigger，边缘触发）： 更高效，只在文件描述符状态从未就绪到就绪时触发（适用于非阻塞 I/O）</span><br></pre></td></tr></table></div></figure>


        <h3 id="IO多路复用"   >
          <a href="#IO多路复用" class="heading-link"><i class="fas fa-link"></i></a><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3>
      
        <h3 id="LT与ET"   >
          <a href="#LT与ET" class="heading-link"><i class="fas fa-link"></i></a><a href="#LT与ET" class="headerlink" title="LT与ET"></a>LT与ET</h3>
      <p>LT:水平触发模式，只要内核缓冲区有数据就一直通知，只要socket处于可读状态就一直返回sockfd；是默认的工作模式，支持阻塞IO和非阻塞IO</p>
<p>ET：边沿触发模式，只有状态发生变化才通知并且这个状态只会通知一次，只有当socket由不可写到可写或由不可读到可读，才会返回sockfd：只支持非阻塞IO</p>

        <h3 id="为什么用epoll，其他多路复用方式以及区别"   >
          <a href="#为什么用epoll，其他多路复用方式以及区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么用epoll，其他多路复用方式以及区别" class="headerlink" title="为什么用epoll，其他多路复用方式以及区别"></a>为什么用epoll，其他多路复用方式以及区别</h3>
      
        <h2 id="高并发模型"   >
          <a href="#高并发模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#高并发模型" class="headerlink" title="高并发模型"></a>高并发模型</h2>
      <p>基于 <strong>Reactor 模型</strong>，实现 One Loop per Thread</p>
<p>Reactor模式通常用同步I&#x2F;O模型实现</p>
<p>Proactor模式通常用异步I&#x2F;O模型实现</p>
<ol>
<li>主线程往epoll内核事件表注册socket读就绪事件</li>
<li>主线程调用epoll_wait等待socket上有数据可读</li>
<li>当socket上有数据可读时，epoll_wait通知主线程，主线程将socket可读事件放入请求队列</li>
<li>工作线程被唤醒，读数据处理请求，然后往epoll内核事件表注测socket写就绪事件</li>
<li>主线程调用epoll_wait等待socket可写</li>
<li>当socket可写，epoll_wait通知主线程，主线程将socket可写事件放入请求队列</li>
<li>睡眠在请求队列的工作线程被唤醒，往socket上写入服务器处理客户请求的结果</li>
</ol>

        <h2 id="动态缓冲区"   >
          <a href="#动态缓冲区" class="heading-link"><i class="fas fa-link"></i></a><a href="#动态缓冲区" class="headerlink" title="动态缓冲区"></a>动态缓冲区</h2>
      <p>实现<strong>自动增长缓冲区</strong></p>
<p><strong>1. 核心数据结构</strong></p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">char</span>&gt; buffer_;  <span class="comment">// 主缓冲区（使用vector自动管理内存）</span></span><br><span class="line">    <span class="type">size_t</span> readerIndex_;         <span class="comment">// 读指针（数据起始位置）</span></span><br><span class="line">    <span class="type">size_t</span> writerIndex_;         <span class="comment">// 写指针（数据结束位置）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>采用vector作为底层容器，自动处理内存分配&#x2F;释放</p>
<p>读写指针分离设计，支持零拷贝操作</p>
<p><code>零拷贝是指计算机执行IO操作时，CPU不需要将数据从一个存储区域复制到另一个存储区域，从而可以减少上下文切换以及CPU的拷贝时间。它是一种I/O操作优化技术。</code></p>
<p><strong>2. 自动增长机制</strong></p>
<p><strong>(1) 扩容触发条件</strong></p>
<p>当<code>writableBytes() &lt; 待写入数据量</code>时自动扩容</p>
<p>通过vector的resize实现：</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* data, <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">writableBytes</span>() &lt; len) &#123;</span><br><span class="line">        <span class="built_in">makeSpace</span>(len);  <span class="comment">// 扩容操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">copy</span>(data, data+len, <span class="built_in">beginWrite</span>());</span><br><span class="line">    writerIndex_ += len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>(2) 智能扩容策略</strong></p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeSpace</span><span class="params">(<span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">writableBytes</span>() + <span class="built_in">prependableBytes</span>() &lt; len) &#123;</span><br><span class="line">        <span class="comment">// 需要真正扩容：vector.resize(writerIndex_ + len)</span></span><br><span class="line">        buffer_.<span class="built_in">resize</span>(writerIndex_ + len);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 通过移动数据复用空间</span></span><br><span class="line">        <span class="type">size_t</span> readable = <span class="built_in">readableBytes</span>();</span><br><span class="line">        std::<span class="built_in">copy</span>(<span class="built_in">begin</span>()+readerIndex_, <span class="built_in">begin</span>()+writerIndex_, <span class="built_in">begin</span>());</span><br><span class="line">        readerIndex_ = <span class="number">0</span>;</span><br><span class="line">        writerIndex_ = readable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



<p><strong>3. 高性能IO优化</strong></p>
<p><strong>(1) 双缓冲区读操作</strong></p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">readFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* saveErrno)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> extrabuf[<span class="number">65536</span>]; <span class="comment">// 64KB栈缓冲区</span></span><br><span class="line">    iovec vec[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    vec[<span class="number">0</span>].iov_base = <span class="built_in">begin</span>() + writerIndex_;</span><br><span class="line">    vec[<span class="number">0</span>].iov_len = <span class="built_in">writableBytes</span>();</span><br><span class="line">    vec[<span class="number">1</span>].iov_base = extrabuf;</span><br><span class="line">    vec[<span class="number">1</span>].iov_len = <span class="built_in">sizeof</span>(extrabuf);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据剩余空间决定使用1个还是2个缓冲区</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> iovcnt = (<span class="built_in">writableBytes</span>() &lt; <span class="built_in">sizeof</span>(extrabuf)) ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="type">ssize_t</span> n = <span class="built_in">readv</span>(fd, vec, iovcnt);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理读入的数据...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>使用<code>readv</code>系统调用实现分散读</p>
<p>优先使用主缓冲区空间，不足时使用栈缓冲区过渡</p>
<p>避免频繁扩容带来的性能损耗</p>
<p><strong>(2) 写操作优化</strong></p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">writeFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* saveErrno)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ::<span class="built_in">write</span>(fd, <span class="built_in">peek</span>(), <span class="built_in">readableBytes</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>直接使用<code>write</code>系统调用</p>
<p><code>peek()</code>返回有效数据起始指针，避免内存拷贝</p>
<p><strong>4. 关键特性总结</strong></p>
<ol>
<li><p><strong>智能扩容</strong>：按需自动增长，兼顾内存使用效率</p>
</li>
<li><p><strong>零拷贝设计</strong>：读写指针分离，减少内存拷贝</p>
</li>
<li><p><strong>双缓冲策略</strong>：栈空间+主缓冲区组合优化IO性能</p>
</li>
<li><p><strong>线程安全</strong>：单次IO操作原子性保证</p>
</li>
<li><p><strong>内存高效</strong>：自动回收已读区域空间</p>
</li>
</ol>
<p>典型工作流程：</p>
<ol>
<li><p>读取数据时优先使用主缓冲区空间</p>
</li>
<li><p>空间不足时暂存到栈缓冲区</p>
</li>
<li><p>触发自动扩容后合并数据</p>
</li>
<li><p>写入数据时直接操作有效数据区域</p>
</li>
</ol>

        <h2 id="连接管理"   >
          <a href="#连接管理" class="heading-link"><i class="fas fa-link"></i></a><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2>
      <p>使用<strong>小根堆实现高效定时器</strong>，管理连接超时时间</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Entry = std::pair&lt;Timestamp, Timer*&gt;; <span class="comment">// 以时间戳作为键值获取定时器</span></span><br><span class="line"><span class="keyword">using</span> TimerList = std::set&lt;Entry&gt;;          <span class="comment">// 底层使用红黑树管理，自动按照时间戳进行排序</span></span><br></pre></td></tr></table></div></figure>

<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定时器管理红黑树插入此新定时器</span></span><br><span class="line">timers_.<span class="built_in">insert</span>(<span class="built_in">Entry</span>(when, timer));</span><br></pre></td></tr></table></div></figure>








        <h2 id="异步日志"   >
          <a href="#异步日志" class="heading-link"><i class="fas fa-link"></i></a><a href="#异步日志" class="headerlink" title="异步日志"></a>异步日志</h2>
      <p>设计<strong>异步日志</strong>模块，基于<strong>单例模式和阻塞队列</strong></p>
<p>日志系统是多生产者，单消费者的任务场景</p>
<p>多生产者负责把日志写入缓冲区，单消费者负责把缓冲区数据写入文件</p>
<p><img   src="https://cdn.nlark.com/yuque/0/2025/png/47188040/1737792284038-49feb6bc-6920-4e1c-9c4a-516ffee44982.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_26,text_5Luj56CB6ZqP5oOz5b2V55-l6K-G5pif55CD,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" style="width: image/watermark,type_d3F5LW1pY3JvaGVp,size_26,tepx;height: t_5Luj56CB6ZqP5oOz5b2V55-l6K-G5pif55CD,color_FFFFFF,shadow_50,t_80,g_se,px;"  alt="img"></p>
<p>前端往后端写，后端往硬盘写</p>
<p>双缓冲技术 ，写满就交换，相当于将多条日志拼接成一个大buffer传送到后端然后写入文件，减少了线程开销</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2025/09/10/%E9%9D%A2%E8%AF%95/C++11%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/">[ Untitled ]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2025-09-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2025-06-06</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="C-11新特性总结"   >
          <a href="#C-11新特性总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#C-11新特性总结" class="headerlink" title="C++11新特性总结"></a>C++11新特性总结</h1>
      
        <h3 id="final关键字"   >
          <a href="#final关键字" class="heading-link"><i class="fas fa-link"></i></a><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3>
      <p>使派生类不可覆盖它所修饰的虚函数</p>

        <h3 id="override描述符"   >
          <a href="#override描述符" class="heading-link"><i class="fas fa-link"></i></a><a href="#override描述符" class="headerlink" title="override描述符"></a>override描述符</h3>
      <p>如果派生类在虚函数声明时使用了override描述符，那么该函数必须重载其基类中的同名函数</p>

        <h3 id="关于左值，右值"   >
          <a href="#关于左值，右值" class="heading-link"><i class="fas fa-link"></i></a><a href="#关于左值，右值" class="headerlink" title="关于左值，右值"></a>关于左值，右值</h3>
      <p><code>C++</code>中所有的值都必然属于左值、右值二者之一。左值是指表达式结束后依然存在的<em>持久化对象</em>，右值是指表达式结束时就不再存在的<em>临时对象</em>。所有的具名变量或者对象都是左值，而右值不具名。很难得到左值和右值的真正定义，但是有一个可以区分左值和右值的便捷方法：<strong>看能不能对表达式取地址，如果能，则为左值，否则为右值</strong>。</p>

        <h3 id="右值引用"   >
          <a href="#右值引用" class="heading-link"><i class="fas fa-link"></i></a><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3>
      <p>左值是指可以出现在&#x3D;左侧者，</p>
<p>右值是指只能出现在&#x3D;右侧者</p>
<p>临时对象是个右值</p>

        <h5 id="右值引用与move语义的关系"   >
          <a href="#右值引用与move语义的关系" class="heading-link"><i class="fas fa-link"></i></a><a href="#右值引用与move语义的关系" class="headerlink" title="右值引用与move语义的关系"></a>右值引用与move语义的关系</h5>
      <ul>
<li>关联性: 右值引用是实现move语义的基础</li>
<li>作用: 允许”偷取”临时对象的资源而非复制</li>
<li>应用场景: 容器操作中大量临时对象的处理</li>
</ul>

        <h3 id="移动语义"   >
          <a href="#移动语义" class="heading-link"><i class="fas fa-link"></i></a><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h3>
      <p>右值则临时对象</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.<span class="built_in">insert</span>(ite,<span class="built_in">Vtype</span>(buf));</span><br></pre></td></tr></table></div></figure>

<p>左值则使用move关键字</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">M <span class="title">c1</span><span class="params">(c)</span></span>;</span><br><span class="line"><span class="function">M <span class="title">c2</span><span class="params">(std::move(c1))</span></span>;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>核心机制<ul>
<li>当赋值右侧是右值时，左侧对象可直接”偷取”资源</li>
<li>避免不必要的资源分配和拷贝</li>
</ul>
</li>
<li>实现要点<ul>
<li>类需要同时实现拷贝和移动语义版本</li>
<li>移动操作后原对象应处于有效但未定义状态</li>
<li>容器需要支持右值版本的插入操作</li>
</ul>
</li>
<li>注意事项<ul>
<li>被移动后的对象不应再使用</li>
<li>移动构造函数应标记为noexcept</li>
<li>临时对象自动被视为右值</li>
</ul>
</li>
<li>典型应用<ul>
<li>容器扩容时的元素迁移</li>
<li>返回临时对象的优化</li>
<li>明确不再使用的左值资源转移</li>
</ul>
</li>
</ul>
<p>应用</p>
<ol>
<li><strong>函数返回值优化</strong>。</li>
<li><strong>STL 容器的高效插入与操作</strong>。</li>
<li><strong>动态资源管理（如智能指针）</strong>。</li>
</ol>

        <h3 id="完美转发"   >
          <a href="#完美转发" class="heading-link"><i class="fas fa-link"></i></a><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h3>
      </div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2025/09/10/linux%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/%E9%85%8D%E7%BD%AEzsh%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/">[ Untitled ]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2025-09-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2024-10-30</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h3 id="配置zsh遇到的问题"   >
          <a href="#配置zsh遇到的问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#配置zsh遇到的问题" class="headerlink" title="配置zsh遇到的问题"></a>配置zsh遇到的问题</h3>
      <p>今天打开wsl，发现外观莫名其妙全变了，修改powershell的外观设置后，发现zsh的命令行颜色怎么改还是舒服，文件夹是蓝底白字的，想修改成蓝底黑字，网上搜索之后发现并没有关于配置文件的教程</p>
<p>我就又去查找了我安装的主题p10k,找到了这篇博客，<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36835255/article/details/128101588#:~:text=DIR%E6%98%AF%E6%AE%B5%E7%9A%84%E5%90%8D%E7%A7%B0%EF%BC%8CB" >powerlevel10k 颜色和图标的自定义设置-CSDN博客</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>打开<code>~/.p10k.zsh</code>搜索关键词<code>DIR</code></p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############################[ dir: 当前目录 ]###########################</span></span><br><span class="line"><span class="comment"># 当前目录的背景色。</span></span><br><span class="line"><span class="built_in">typeset</span> -g POWERLEVEL9K_DIR_BACKGROUND=4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前目录的默认前景色。</span></span><br><span class="line"><span class="built_in">typeset</span> -g POWERLEVEL9K_DIR_FOREGROUND=232</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果目录过长，缩短其中一些段为最短的唯一前缀。缩短后的目录仍可通过 Tab 键补全为原来的完整路径。</span></span><br><span class="line"><span class="built_in">typeset</span> -g POWERLEVEL9K_SHORTEN_STRATEGY=truncate_to_unique</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用此符号替换被移除的目录段后缀。</span></span><br><span class="line"><span class="built_in">typeset</span> -g POWERLEVEL9K_SHORTEN_DELIMITER=</span><br><span class="line"></span><br><span class="line"><span class="comment"># 缩短后的目录段的颜色。</span></span><br><span class="line"><span class="built_in">typeset</span> -g POWERLEVEL9K_DIR_SHORTENED_FOREGROUND=232</span><br><span class="line"></span><br><span class="line"><span class="comment"># 锚点目录段的颜色。锚点段永远不会被缩短。第一个段始终是锚点。</span></span><br><span class="line"><span class="built_in">typeset</span> -g POWERLEVEL9K_DIR_ANCHOR_FOREGROUND=232</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将锚点目录段以加粗方式显示。</span></span><br><span class="line"><span class="built_in">typeset</span> -g POWERLEVEL9K_DIR_ANCHOR_BOLD=<span class="literal">true</span></span><br></pre></td></tr></table></div></figure>

<p>注释交给gpt翻译了一下，修改即可</p>
<p>按照上面教程的方法，颜色代码可以输入以下命令查看</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> code (&#123;000..255&#125;) <span class="built_in">print</span> -P -- <span class="string">&quot;<span class="variable">$code</span>: %F&#123;<span class="variable">$code</span>&#125;最左侧三位数字即颜色值Text Color%f&quot;</span></span><br></pre></td></tr></table></div></figure>

<p><strong>每次修改配置后一定要输入</strong></p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.p10k.zsh</span><br></pre></td></tr></table></div></figure>



<p>修改之后遇到问题，发现缩短后的锚点文件夹不能加粗显示，修改配置文件也不行。</p>
<p>经检查发现是powershell外观配置问题，把<code>外观-&gt;文本格式</code>强调文本格式部分设置成加粗字体即可</p>
<p>还有一个意外发现就是在复制上面配置文件时，发现vim不能和windows共享剪贴板</p>
<p>于是搜索得到以下解决方案</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://stackoverflow.com/questions/61550552/how-to-copy-paste-from-vim-in-wsl" >clipboard - How to copy&#x2F;paste from Vim in WSL - Stack Overflow</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>1.按<code>v</code>进入可视模式，滑动鼠标或者输入行数选中</p>
<p>2.按<code>:</code>，输入以下命令即可</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:<span class="string">&#x27;&lt;,&#x27;</span>&gt;w !clip.exe</span><br></pre></td></tr></table></div></figure>

<p>如果要复制全部文本则直接输入该命令</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:w !clip.exe</span><br></pre></td></tr></table></div></figure>



</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2025/09/10/linux%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98/">[ Untitled ]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2025-09-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2024-06-26</span></span></div></header><div class="post-body"><div class="post-excerpt"><figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Socket error Event: 32 Error: 10053.</span><br><span class="line">Connection closing...Socket close.</span><br><span class="line"></span><br><span class="line">Connection closed by foreign host.</span><br></pre></td></tr></table></div></figure>

<p>用手机连热点遇到的问题</p>
<p>推测不是负载过高导致的</p>
<p>端口：22，用手机和电脑上xshell连接有问题</p>
<p>刚进的时候可以，但是输入两到三行命令后会突然退出显示以上报错</p>
<p>排除xshell问题，因为手机端也不能正常连接</p>
<p>猜想排除网络问题，因为用4g网络，5g网络，wifi，都会出现以上情况</p>
<p>不是ip冲突导致的</p>
<p>输入last命令后</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Last login: Wed Jun 26 00:23:36 2024 from 223.104.40.248</span><br><span class="line">stydent@nihao:~$ last</span><br><span class="line">stydent  pts/0        223.104.40.248   Wed Jun 26 00:30   still logged <span class="keyword">in</span></span><br><span class="line">stydent  pts/0        223.104.40.248   Wed Jun 26 00:23 - 00:24  (00:00)</span><br><span class="line">stydent  pts/0        223.104.40.248   Wed Jun 26 00:16 - 00:17  (00:00)</span><br><span class="line">stydent  pts/0        223.104.40.248   Wed Jun 26 00:09 - 00:10  (00:00)</span><br><span class="line">stydent  pts/0        223.104.40.248   Wed Jun 26 00:02 - 00:03  (00:00)</span><br><span class="line">stydent  pts/0        120.244.62.97    Tue Jun 25 23:20 - 23:21  (00:00)</span><br><span class="line">stydent  pts/0        223.104.40.248   Tue Jun 25 16:23 - 16:32  (00:09)</span><br><span class="line">stydent  pts/1        223.104.40.248   Tue Jun 25 16:16 - 16:25  (00:08)</span><br><span class="line">stydent  pts/0        223.104.40.248   Tue Jun 25 16:10 - 16:19  (00:08)</span><br><span class="line">stydent  pts/0        223.104.40.248   Tue Jun 25 16:02 - 16:09  (00:06)</span><br><span class="line">stydent  pts/0        223.104.40.248   Tue Jun 25 15:55 - 15:58  (00:03)</span><br><span class="line">stydent  pts/2        223.104.40.248   Tue Jun 25 15:32 - 15:46  (00:14)</span><br><span class="line">stydent  pts/1        120.244.62.221   Tue Jun 25 14:56 - 15:38  (00:42)</span><br><span class="line">stydent  pts/0        120.244.62.221   Tue Jun 25 14:55 - 15:36  (00:40)</span><br><span class="line">reboot   system boot  5.15.0-1064-azur Tue Jun 25 14:53   still running</span><br></pre></td></tr></table></div></figure>

<p>更换ip后依然不行，停止后重启暂时修复</p>
<p>启动机器人后突然挂掉，应该是负载问题</p>
<p>真相了</p>
<p><strong>连接校园网就没问题</strong></p>
<p><strong>应该是手机热点导致的ip冲突</strong></p>
<p><strong>彻底真相了</strong></p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lastb</span><br></pre></td></tr></table></div></figure>

<p>随便截取一些记录</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">user     ssh:notty    43.134.171.154   Tue Jun 25 16:03 - 16:03  (00:00)</span><br><span class="line">user     ssh:notty    43.134.171.154   Tue Jun 25 16:03 - 16:03  (00:00)</span><br><span class="line">root     ssh:notty    43.163.200.19    Tue Jun 25 16:03 - 16:03  (00:00)</span><br><span class="line">oracle   ssh:notty    43.163.247.189   Tue Jun 25 16:03 - 16:03  (00:00)</span><br><span class="line">oracle   ssh:notty    43.163.247.189   Tue Jun 25 16:02 - 16:02  (00:00)</span><br><span class="line">root     ssh:notty    105.28.108.165   Tue Jun 25 16:02 - 16:02  (00:00)</span><br><span class="line">daniel   ssh:notty    201.234.7.122    Tue Jun 25 16:02 - 16:02  (00:00)</span><br><span class="line">daniel   ssh:notty    201.234.7.122    Tue Jun 25 16:02 - 16:02  (00:00)</span><br><span class="line"><span class="built_in">test</span>     ssh:notty    43.134.171.154   Tue Jun 25 16:02 - 16:02  (00:00)</span><br><span class="line"><span class="built_in">test</span>     ssh:notty    43.134.171.154   Tue Jun 25 16:02 - 16:02  (00:00)</span><br><span class="line">root     ssh:notty    43.163.200.19    Tue Jun 25 16:02 - 16:02  (00:00)</span><br><span class="line">daniel   ssh:notty    43.163.247.189   Tue Jun 25 16:02 - 16:02  (00:00)</span><br><span class="line">daniel   ssh:notty    43.163.247.189   Tue Jun 25 16:02 - 16:02  (00:00)</span><br><span class="line">ubuntu   ssh:notty    43.163.200.19    Tue Jun 25 16:01 - 16:01  (00:00)</span><br><span class="line">root     ssh:notty    201.234.7.122    Tue Jun 25 16:01 - 16:01  (00:00)</span><br><span class="line">root     ssh:notty    105.28.108.165   Tue Jun 25 16:01 - 16:01  (00:00)</span><br><span class="line">ubuntu   ssh:notty    43.163.200.19    Tue Jun 25 16:01 - 16:01  (00:00)</span><br><span class="line">root     ssh:notty    43.134.171.154   Tue Jun 25 16:01 - 16:01  (00:00)</span><br><span class="line">root     ssh:notty    43.163.247.189   Tue Jun 25 16:01 - 16:01  (00:00)</span><br><span class="line">root     ssh:notty    43.163.200.19    Tue Jun 25 16:00 - 16:00  (00:00)</span><br><span class="line">root     ssh:notty    43.134.171.154   Tue Jun 25 16:00 - 16:00  (00:00)</span><br><span class="line">root     ssh:notty    201.234.7.122    Tue Jun 25 16:00 - 16:00  (00:00)</span><br><span class="line">root     ssh:notty    43.163.247.189   Tue Jun 25 15:59 - 15:59  (00:00)</span><br><span class="line">root     ssh:notty    105.28.108.165   Tue Jun 25 15:59 - 15:59  (00:00)</span><br><span class="line">root     ssh:notty    140.246.109.211  Tue Jun 25 15:57 - 15:57  (00:00)</span><br><span class="line">Admin    ssh:notty    43.163.200.19    Tue Jun 25 15:56 - 15:56  (00:00)</span><br></pre></td></tr></table></div></figure>

<p>看1panel的ssh登录日志，发现有两千多条和我无关的ip尝试登录，估计是被挤占的</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45698148/article/details/120229559" >linux问题解决：多种方法处理ssh暴力攻击_sshd:all:deny-CSDN博客</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2025/09/10/linux%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/%E6%B8%85%E7%90%86wsl%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4/">[ Untitled ]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2025-09-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2025-07-09</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="清理wsl磁盘空间"   >
          <a href="#清理wsl磁盘空间" class="heading-link"><i class="fas fa-link"></i></a><a href="#清理wsl磁盘空间" class="headerlink" title="清理wsl磁盘空间"></a>清理wsl磁盘空间</h1>
      
        <h3 id="先以管理员身份运行powershell"   >
          <a href="#先以管理员身份运行powershell" class="heading-link"><i class="fas fa-link"></i></a><a href="#先以管理员身份运行powershell" class="headerlink" title="先以管理员身份运行powershell"></a>先以管理员身份运行powershell</h3>
      <figure class="highlight cmd"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diskpart</span><br></pre></td></tr></table></div></figure>


        <h3 id="查看wsl发行版本"   >
          <a href="#查看wsl发行版本" class="heading-link"><i class="fas fa-link"></i></a><a href="#查看wsl发行版本" class="headerlink" title="查看wsl发行版本"></a>查看wsl发行版本</h3>
      <figure class="highlight powershell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">-l</span>  <span class="literal">-v</span></span><br></pre></td></tr></table></div></figure>

 <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> NAME              STATE           VERSION</span><br><span class="line"></span><br><span class="line">* Ubuntu-22.04      Stopped         2</span><br><span class="line">  docker-desktop    Stopped         2</span><br></pre></td></tr></table></div></figure>


        <h3 id="查找-Linux-发行版的-vhdx-文件和目录路径，"   >
          <a href="#查找-Linux-发行版的-vhdx-文件和目录路径，" class="heading-link"><i class="fas fa-link"></i></a><a href="#查找-Linux-发行版的-vhdx-文件和目录路径，" class="headerlink" title="查找 Linux 发行版的 .vhdx 文件和目录路径，"></a>查找 Linux 发行版的 <em>.vhdx</em> 文件和目录路径，</h3>
      <p>请打开 PowerShell 并使用以下脚本，将 <code>&lt;distribution-name&gt;</code> 替换为实际的发行版名称：</p>
<figure class="highlight powershell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">Get-ChildItem</span> <span class="literal">-Path</span> HKCU:\Software\Microsoft\Windows\CurrentVersion\Lxss | <span class="built_in">Where-Object</span> &#123; <span class="variable">$_</span>.GetValue(<span class="string">&quot;DistributionName&quot;</span>) <span class="operator">-eq</span> <span class="string">&#x27;&lt;Ubuntu-22.04&gt;&#x27;</span> &#125;).GetValue(<span class="string">&quot;BasePath&quot;</span>) + <span class="string">&quot;\ext4.vhdx&quot;</span></span><br></pre></td></tr></table></div></figure>

<p>结果将显示类似于 <code>%LOCALAPPDATA%\Packages\&lt;PackageFamilyName&gt;\LocalState\&lt;disk&gt;.vhdx</code> 的路径。 例如：</p>
<figure class="highlight powershell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\<span class="number">86147</span>\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu22.<span class="number">04</span>LTS_79rhkp1fndgsc\LocalState\ext4.vhdx</span><br></pre></td></tr></table></div></figure>

<p>这是与你列出的 Linux 发行版关联的 <code>ext4.vhdx</code> 文件的路径。</p>
<p>先关掉</p>
<figure class="highlight powershell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">--shutdown</span></span><br></pre></td></tr></table></div></figure>


        <h3 id="压缩磁盘文件"   >
          <a href="#压缩磁盘文件" class="heading-link"><i class="fas fa-link"></i></a><a href="#压缩磁盘文件" class="headerlink" title="压缩磁盘文件"></a>压缩磁盘文件</h3>
      <figure class="highlight powershell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//<span class="number">4</span><span class="literal">-3</span> 依次输入下列命令</span><br><span class="line">//选择目标磁盘文件</span><br><span class="line">diskpart</span><br><span class="line"></span><br><span class="line"><span class="built_in">select</span> vdisk file=<span class="string">&quot;C:\Users\86147\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu22.04LTS_79rhkp1fndgsc\LocalState\ext4.vhdx&quot;</span></span><br><span class="line">//以只读模式连接虚拟磁盘文件</span><br><span class="line">attach vdisk readonly</span><br><span class="line"></span><br><span class="line">//开始压缩虚拟磁盘文件</span><br><span class="line">compact vdisk</span><br><span class="line"></span><br><span class="line">//分离虚拟磁盘文件</span><br><span class="line">detach vdisk</span><br><span class="line"></span><br><span class="line">//退出diskpart工具</span><br><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></div></figure>





<p>显示与此虚拟磁盘关联的详细信息，包括<strong>虚拟大小</strong>，表示当前分配给 VHD 的大小上限</p>
<figure class="highlight cmd"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">detail vdisk</span><br></pre></td></tr></table></div></figure>



<p>扩展空间</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/wsl/disk-space#how-to-locate-the-vhdx-file-and-disk-path-for-your-linux-distribution" >如何管理 WSL 磁盘空间 | Microsoft Learn</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h1 id="清理docker"   >
          <a href="#清理docker" class="heading-link"><i class="fas fa-link"></i></a><a href="#清理docker" class="headerlink" title="清理docker"></a>清理docker</h1>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/arvinrong/article/details/135723290" >Windows WSL2 占用磁盘空间清理释放_wsl占用空间太大-CSDN博客</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<figure class="highlight powershell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker system prune</span><br><span class="line">WARNING! This will remove:</span><br><span class="line">  - all stopped containers</span><br><span class="line">  - all networks not used by at least one container</span><br><span class="line">  - all dangling images</span><br><span class="line">  - unused build cache</span><br><span class="line"></span><br><span class="line">Are you sure you want to <span class="keyword">continue</span>? [<span class="type">y</span>/<span class="type">N</span>] y</span><br><span class="line">Total reclaimed space: <span class="number">0</span>B</span><br></pre></td></tr></table></div></figure>

</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2025/09/10/linux%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9Fpython%E7%8E%AF%E5%A2%83%EF%BC%8C%E9%87%87%E7%94%A8%E8%BD%BB%E9%87%8F%E5%8C%96%E7%9A%84%E6%96%B9%E6%A1%88/">[ Untitled ]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2025-09-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2025-07-09</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="安装虚拟python环境，采用轻量化的方案"   >
          <a href="#安装虚拟python环境，采用轻量化的方案" class="heading-link"><i class="fas fa-link"></i></a><a href="#安装虚拟python环境，采用轻量化的方案" class="headerlink" title="安装虚拟python环境，采用轻量化的方案"></a>安装虚拟python环境，采用轻量化的方案</h2>
      <p>创建一个轻量化的 Python 虚拟环境可以通过 <code>venv</code> 或 <code>virtualenv</code> 实现。这里我将介绍使用 <code>venv</code> 的方法，因为它是 Python 自带的模块，并且通常更简单。以下步骤适用于基于 Debian 的 Linux 发行版（例如 Ubuntu 和 WSL 的 Ubuntu 版本）。</p>

        <h3 id="1-安装-Python-和-venv"   >
          <a href="#1-安装-Python-和-venv" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-安装-Python-和-venv" class="headerlink" title="1. 安装 Python 和 venv"></a>1. 安装 Python 和 venv</h3>
      <p>确保你安装了 Python 和 <code>venv</code> 模块。在大多数情况下，Python 会默认包含 <code>venv</code> 模块，但你可以通过以下命令确认：</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install python3 python3-venv</span><br></pre></td></tr></table></div></figure>


        <h3 id="2-创建虚拟环境"   >
          <a href="#2-创建虚拟环境" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-创建虚拟环境" class="headerlink" title="2. 创建虚拟环境"></a>2. 创建虚拟环境</h3>
      <p>选择一个目录来存放你的虚拟环境，例如在你的项目文件夹中。</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /path/to/your/project</span><br><span class="line">python3 -m venv myenv</span><br></pre></td></tr></table></div></figure>

<p>将 <code>myenv</code> 替换为你希望给虚拟环境起的名字。</p>

        <h3 id="3-激活虚拟环境"   >
          <a href="#3-激活虚拟环境" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-激活虚拟环境" class="headerlink" title="3. 激活虚拟环境"></a>3. 激活虚拟环境</h3>
      <p>激活虚拟环境，以便你在这个环境中安装的任何 Python 包都不会影响系统的全局 Python 设置。</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> myenv/bin/activate</span><br></pre></td></tr></table></div></figure>

<p>当虚拟环境激活后，你的命令行提示符通常会显示环境名称，例如 <code>(myenv)</code>。</p>

        <h3 id="4-安装所需的包"   >
          <a href="#4-安装所需的包" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-安装所需的包" class="headerlink" title="4. 安装所需的包"></a>4. 安装所需的包</h3>
      <p>在激活的虚拟环境中，你可以使用 <code>pip</code> 安装任何你需要的 Python 包。例如，安装 <code>requests</code> 库：</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></div></figure>


        <h3 id="5-清理不必要的包"   >
          <a href="#5-清理不必要的包" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-清理不必要的包" class="headerlink" title="5. 清理不必要的包"></a>5. 清理不必要的包</h3>
      <p>如果你希望保持环境轻量化，可以在使用完后移除不再需要的包。可以使用以下命令检查已安装的包：</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip list</span><br></pre></td></tr></table></div></figure>

<p>并使用以下命令卸载不需要的包：</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip uninstall package_name</span><br></pre></td></tr></table></div></figure>


        <h3 id="6-退出虚拟环境"   >
          <a href="#6-退出虚拟环境" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-退出虚拟环境" class="headerlink" title="6. 退出虚拟环境"></a>6. 退出虚拟环境</h3>
      <p>完成工作后，可以通过以下命令退出虚拟环境：</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></div></figure>


        <h3 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h3>
      <p>通过以上步骤，你可以创建一个轻量化的 Python 虚拟环境，并在其中安装所需的包。<code>venv</code> 提供了一个相对简单的方式来管理项目所需的依赖，同时保持系统 Python 环境的干净。在项目开发和测试中使用虚拟环境是良好的实践。</p>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/stun-logo.svg" alt="avatar"></div><p class="sidebar-ov-author__text">Hello Stun</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">60</div><div class="sidebar-ov-state-item__name">Archives</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="Creative Commons" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2025</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>John Doe</span></div><div><span>Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a></span><span> v7.3.0</span><span class="footer__devider">|</span><span>Theme - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.8.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.8.0"></script><script src="/js/stun-boot.js?v=2.8.0"></script><script src="/js/scroll.js?v=2.8.0"></script><script src="/js/header.js?v=2.8.0"></script><script src="/js/sidebar.js?v=2.8.0"></script></body></html>